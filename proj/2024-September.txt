From j1 at jimenezshaw.com  Tue Sep  3 01:39:21 2024
From: j1 at jimenezshaw.com (Javier Jimenez Shaw)
Date: Tue, 3 Sep 2024 10:39:21 +0200
Subject: [PROJ] Transformations in ITRF2020
In-Reply-To: <62d0636a-98c1-400e-b11d-e13e311e7913@spatialys.com>
References: <CADRrdKuP1wWPOT4a_TUduBNM_0Hfgp0qfhEp1aadpECng8hyCg@mail.gmail.com>
 <62d0636a-98c1-400e-b11d-e13e311e7913@spatialys.com>
Message-ID: <CADRrdKsHS_4X_SpunFV0KJe2Ng4ZtTxB1qFYiNWUAgfSBA38CA@mail.gmail.com>

Thanks Even.

In the DB, the operation registered is ETRS89_TO_ETRF2020, so it has to be
"inverted". However, I do not see any way to indicate that in the
concatenated operation.

For instance, this concatenated operation does not mention that the second
step should be "inverted" (if I understood correctly)
    ('NKG', 'ITRF2014_TO_DK', 1, 'EPSG', '8366'), -- ITRF2014 -> ETRF2014
    ('NKG', 'ITRF2014_TO_DK', 2, 'NKG', 'NKG_ETRF14_TO_ETRF2014'),
    ('NKG', 'ITRF2014_TO_DK', 3, 'NKG', 'PAR_2020_DK'),
    ('NKG', 'ITRF2014_TO_DK', 4, 'NKG', 'DK_2020_INTRAPLATE')

Does it mean that PROJ is finding it automatically?

Thanks.

PS Should I add the concatenated operation (ITRF2020->ETRS89) to PROJ in a
PR? There are different "paths" from ITRF2020 to ETRS89. All apparently
equivalent, but probably not exactly the same.

On Tue, 27 Aug 2024 at 19:55, Even Rouault <even.rouault at spatialys.com>
wrote:

> Javier,
>
> I believe that registering a concatenated operation for ITRF2020 -> ETRS89
> = ITF2020->ETRF2020+ETRF2020->ETRS89 in the database should be enough for
> PROJ to infer the ITRF2020 -> CH1903+ pipeline
>
> Even
> Le 27/08/2024 ? 19:29, Javier Jimenez Shaw via PROJ a ?crit :
>
> Hi
>
> I am now facing transformations with ITRF2020 with time(yes, because
> Skylark, but I guess more NTRIPs are going to do (or already doing) the
> same)
>
> The point is when the destination CRS does not have a direct
> transformation from ITRF2020 (or almost).
>
> For instance, EPSG:4150, CH1903+ (the geographic of LV95, in Switzerland)
> is only connected to ETRS89. See that CH1903+ is in the European tectonic
> plate, as ETRS89
>
> A direct transformation is completely ballpark
>
> echo 42 6 0 2024.6 | ./cs2cs EPSG:9989 EPSG:4150 -d 9 --3d
> 42.000000000 6.000000000 0.000000000 2024.6
>
> However, from ITRF2020 to ETRS89 there is some change due to the time (the
> European plate moving at 2.5 cm/a since 2015):
> echo 42 6 0 2024.6 | ./cs2cs EPSG:9989 EPSG:4937 -d 9 --3d
> 41.999994981 5.999991317 -0.001861237 2024.6
>
> and from ETRS89 to CH1903+ due to the datum offset:
> echo 42 6 0 2024.6 | ./cs2cs EPSG:4937 EPSG:4150 -d 9 --3d
> 42.000742733 6.000670188 -60.682799297 2024.6
>
> Looking at the pipelines, the steps would be ITRF2020 -> ETRF2020 ->
> ETRS89 -> CH1903+
> (btw, only since PROJ 9.4.1, when ETRF2020 was added)
>
> I understand that the only way to get the proper transformation is
> chaining these two manually. Via ETRS89 ... because I know it. Right?
>
> Well, the future does not look so promising to me: in EPSG I only see
> transformations from ITRF2020 to ETRF family, NAD83(2011) family and
> NAD83(CSRS)v8. That is Europe, USA and Canada. That's all, folks.
>
> Thanks,
> .___ ._ ..._ .. . ._.  .___ .. __ . _. . __..  ... .... ._ .__
> Javier Jimenez Shaw
> Mercator str 42.
> Null-Island
>
> _______________________________________________
> PROJ mailing listPROJ at lists.osgeo.orghttps://lists.osgeo.org/mailman/listinfo/proj
>
> -- http://www.spatialys.com
> My software is free, but my time generally not.
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240903/aa62a8c9/attachment.htm>

From even.rouault at spatialys.com  Tue Sep  3 04:21:39 2024
From: even.rouault at spatialys.com (Even Rouault)
Date: Tue, 3 Sep 2024 13:21:39 +0200
Subject: [PROJ] Transformations in ITRF2020
In-Reply-To: <CADRrdKsHS_4X_SpunFV0KJe2Ng4ZtTxB1qFYiNWUAgfSBA38CA@mail.gmail.com>
References: <CADRrdKuP1wWPOT4a_TUduBNM_0Hfgp0qfhEp1aadpECng8hyCg@mail.gmail.com>
 <62d0636a-98c1-400e-b11d-e13e311e7913@spatialys.com>
 <CADRrdKsHS_4X_SpunFV0KJe2Ng4ZtTxB1qFYiNWUAgfSBA38CA@mail.gmail.com>
Message-ID: <865152be-1d41-4e08-97d9-9e6bf1ea5360@spatialys.com>

Javier,
>
> In the DB, the operation registered is ETRS89_TO_ETRF2020, so it has 
> to be "inverted". However, I do not see any way to indicate that in 
> the concatenated operation.
>
> For instance, this concatenated operation does not mention that the 
> second step should be "inverted" (if I understood correctly)
> ? ? ('NKG', 'ITRF2014_TO_DK', 1, 'EPSG', '8366'), -- ITRF2014 -> ETRF2014
> ? ? ('NKG', 'ITRF2014_TO_DK', 2, 'NKG', 'NKG_ETRF14_TO_ETRF2014'),
> ? ? ('NKG', 'ITRF2014_TO_DK', 3, 'NKG', 'PAR_2020_DK'),
> ? ? ('NKG', 'ITRF2014_TO_DK', 4, 'NKG', 'DK_2020_INTRAPLATE')
>
> Does it mean that PROJ is finding it automatically?
Unfortunately yes, PROJ has to figure out the direction of operations, 
and it is an awful and error prone job, especially when one of the step 
is a conversion which lacks explicit source and target CRS. I complained 
about that to IOGP to ask to add a direction (forward/inverse) column in 
the coordinate_step table, but I wasn't apparently sufficiently convincing.
>
> Thanks.
>
> PS Should I add the concatenated operation (ITRF2020->ETRS89) to PROJ 
> in a PR? There are different "paths" from ITRF2020 to ETRS89. All 
> apparently equivalent, but probably not exactly the same.

Maybe try first to see if EPSG wants to add it?


-- 
http://www.spatialys.com
My software is free, but my time generally not.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240903/a664cb1b/attachment.htm>

From j1 at jimenezshaw.com  Tue Sep  3 07:35:20 2024
From: j1 at jimenezshaw.com (Javier Jimenez Shaw)
Date: Tue, 3 Sep 2024 16:35:20 +0200
Subject: [PROJ] Transformations in ITRF2020
In-Reply-To: <865152be-1d41-4e08-97d9-9e6bf1ea5360@spatialys.com>
References: <CADRrdKuP1wWPOT4a_TUduBNM_0Hfgp0qfhEp1aadpECng8hyCg@mail.gmail.com>
 <62d0636a-98c1-400e-b11d-e13e311e7913@spatialys.com>
 <CADRrdKsHS_4X_SpunFV0KJe2Ng4ZtTxB1qFYiNWUAgfSBA38CA@mail.gmail.com>
 <865152be-1d41-4e08-97d9-9e6bf1ea5360@spatialys.com>
Message-ID: <CADRrdKtKaC4=K7PZD_zYX-1NXJRpcFR06HX5zEQqGd7dBcNKgw@mail.gmail.com>

Well. I tried it... and something does not work (probably a silly mistake)

at the end of data/sql/other_transformation_custom.sql I added this:

INSERT INTO "concatenated_operation"
VALUES('PROJ','ITRF2020_TO_ETRS89','ITRF2020 to ETRS89','Time-dependent
transformation from ITRF2020 to ETRS89 based on
EPSG:10573','EPSG','9990','EPSG','4258',0.1,NULL,0);
INSERT INTO "concatenated_operation_step"
VALUES('PROJ','ITRF2020_TO_ETRS89',1,'EPSG','10573');
INSERT INTO "concatenated_operation_step"
VALUES('PROJ','ITRF2020_TO_ETRS89',2,'PROJ','ETRS89_TO_ETRF2020');
INSERT INTO "usage" VALUES(
    'PROJ',
    'ITRF2020_TO_ETRS89_USAGE',
    'concatenated_operation',
    'PROJ',
    'ITRF2020_TO_ETRS89',
    'EPSG','1289', -- extent
    'EPSG','1024'  -- unknown
);

And the transformation is this ballpark:

PROJ_DATA=../data/ ./projinfo EPSG:9990 EPSG:4258 --spatial-test intersects
--bbox 7,42,8,43 -o proj
Candidate operations found: 1
-------------------------------------
Operation No. 1:

unknown id, Ballpark geographic offset from ITRF2020 to ETRS89, unknown
accuracy, World, has ballpark transformation

PROJ string:
+proj=noop

While without that change it is this (just showing the first transformation)

PROJ_DATA=../data/ ./projinfo EPSG:9990 EPSG:4258 --spatial-test intersects
--bbox 7,42,8,43 -o proj
Candidate operations found: 4
-------------------------------------
Operation No. 1:

unknown id, Conversion from ITRF2020 (geog2D) to ITRF2020 (geocentric) +
ITRF2020 to ETRF2020 (2) + Conversion from ETRF2020 (geocentric) to
ETRF2020 (geog2D) + Inverse of ETRS89 to ETRF2020, 0.1 m, Europe - onshore
and offshore - ETRF extent - approximately 16?W to 33?E and 33?N to 84?N.

PROJ string:
+proj=pipeline
  +step +proj=axisswap +order=2,1
  +step +proj=unitconvert +xy_in=deg +xy_out=rad
  +step +proj=cart +ellps=GRS80
  +step +proj=helmert +x=0 +y=0 +z=0 +rx=0.002236 +ry=0.013494
+rz=-0.019578 +s=0
        +dx=0 +dy=0 +dz=0 +drx=8.6e-05 +dry=0.000519 +drz=-0.000753 +ds=0
        +t_epoch=2015 +convention=position_vector
  +step +inv +proj=cart +ellps=GRS80
  +step +proj=unitconvert +xy_in=rad +xy_out=deg
  +step +proj=axisswap +order=2,1
...

Am I doing anything wrong?
I guessed that EPSG:10573 is a transformation between geocentric systems,
while PROJ:ETRS89_TO_ETRF2020 is between geographic 2D. So there could be a
missing geocentric->geographic2D in between. But I don't know how to set it.
It is also surprising that not only it is not finding this concatenated
operation, but not finding anyone!

Thanks,
Javier

On Tue, 3 Sept 2024 at 13:21, Even Rouault <even.rouault at spatialys.com>
wrote:

> Javier,
>
>
> In the DB, the operation registered is ETRS89_TO_ETRF2020, so it has to be
> "inverted". However, I do not see any way to indicate that in the
> concatenated operation.
>
> For instance, this concatenated operation does not mention that the second
> step should be "inverted" (if I understood correctly)
>     ('NKG', 'ITRF2014_TO_DK', 1, 'EPSG', '8366'), -- ITRF2014 -> ETRF2014
>     ('NKG', 'ITRF2014_TO_DK', 2, 'NKG', 'NKG_ETRF14_TO_ETRF2014'),
>     ('NKG', 'ITRF2014_TO_DK', 3, 'NKG', 'PAR_2020_DK'),
>     ('NKG', 'ITRF2014_TO_DK', 4, 'NKG', 'DK_2020_INTRAPLATE')
>
> Does it mean that PROJ is finding it automatically?
>
> Unfortunately yes, PROJ has to figure out the direction of operations, and
> it is an awful and error prone job, especially when one of the step is a
> conversion which lacks explicit source and target CRS. I complained about
> that to IOGP to ask to add a direction (forward/inverse) column in the
> coordinate_step table, but I wasn't apparently sufficiently convincing.
>
>
> Thanks.
>
> PS Should I add the concatenated operation (ITRF2020->ETRS89) to PROJ in a
> PR? There are different "paths" from ITRF2020 to ETRS89. All apparently
> equivalent, but probably not exactly the same.
>
> Maybe try first to see if EPSG wants to add it?
>
> -- http://www.spatialys.com
> My software is free, but my time generally not.
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240903/f1a4d6c4/attachment-0001.htm>

From even.rouault at spatialys.com  Tue Sep  3 08:04:03 2024
From: even.rouault at spatialys.com (Even Rouault)
Date: Tue, 3 Sep 2024 17:04:03 +0200
Subject: [PROJ] Transformations in ITRF2020
In-Reply-To: <CADRrdKtKaC4=K7PZD_zYX-1NXJRpcFR06HX5zEQqGd7dBcNKgw@mail.gmail.com>
References: <CADRrdKuP1wWPOT4a_TUduBNM_0Hfgp0qfhEp1aadpECng8hyCg@mail.gmail.com>
 <62d0636a-98c1-400e-b11d-e13e311e7913@spatialys.com>
 <CADRrdKsHS_4X_SpunFV0KJe2Ng4ZtTxB1qFYiNWUAgfSBA38CA@mail.gmail.com>
 <865152be-1d41-4e08-97d9-9e6bf1ea5360@spatialys.com>
 <CADRrdKtKaC4=K7PZD_zYX-1NXJRpcFR06HX5zEQqGd7dBcNKgw@mail.gmail.com>
Message-ID: <ad0c4f4f-cfef-4af9-9588-57ccb4a147db@spatialys.com>

Javier,

Inspecting with "projinfo -k operation PROJ:ITRF2020_TO_ETRS89", you got 
the extent code wrong, it should be EPSG:4755 (using the same one as ETRS89)

The magic in the instantiation of concatenated operations also takes 
care of inserting the appropriate geographic<-->geocentric conversion 
steps. Cf 
https://github.com/OSGeo/PROJ/blob/master/src/iso19111/operation/concatenatedoperation.cpp#L554-L571

Once fixed, "projinfo ETRS89 ITRF2020" (only) reports that transformation.

Even

Le 03/09/2024 ? 16:35, Javier Jimenez Shaw a ?crit?:
> Well. I tried it... and something does not work (probably a silly mistake)
>
> at the end of data/sql/other_transformation_custom.sql I added this:
>
> INSERT INTO "concatenated_operation" 
> VALUES('PROJ','ITRF2020_TO_ETRS89','ITRF2020 to 
> ETRS89','Time-dependent transformation from ITRF2020 to ETRS89 based 
> on EPSG:10573','EPSG','9990','EPSG','4258',0.1,NULL,0);
> INSERT INTO "concatenated_operation_step" 
> VALUES('PROJ','ITRF2020_TO_ETRS89',1,'EPSG','10573');
> INSERT INTO "concatenated_operation_step" 
> VALUES('PROJ','ITRF2020_TO_ETRS89',2,'PROJ','ETRS89_TO_ETRF2020');
> INSERT INTO "usage" VALUES(
> ? ? 'PROJ',
> ? ? 'ITRF2020_TO_ETRS89_USAGE',
> ? ? 'concatenated_operation',
> ? ? 'PROJ',
> ? ? 'ITRF2020_TO_ETRS89',
> ? ? 'EPSG','1289', -- extent
> ? ? 'EPSG','1024' ?-- unknown
> );
>
> And the transformation is this ballpark:
>
> PROJ_DATA=../data/ ./projinfo EPSG:9990 EPSG:4258 --spatial-test 
> intersects --bbox 7,42,8,43 -o proj
> Candidate operations found: 1
> -------------------------------------
> Operation No. 1:
>
> unknown id, Ballpark geographic offset from ITRF2020 to ETRS89, 
> unknown accuracy, World, has ballpark transformation
>
> PROJ string:
> +proj=noop
>
> While without that change it is this (just showing the first 
> transformation)
>
> PROJ_DATA=../data/ ./projinfo EPSG:9990 EPSG:4258 --spatial-test 
> intersects --bbox 7,42,8,43 -o proj
> Candidate operations found: 4
> -------------------------------------
> Operation No. 1:
>
> unknown id, Conversion from ITRF2020 (geog2D) to ITRF2020 (geocentric) 
> + ITRF2020 to ETRF2020 (2) + Conversion from ETRF2020 (geocentric) to 
> ETRF2020 (geog2D) + Inverse of ETRS89 to ETRF2020, 0.1 m, Europe - 
> onshore and offshore - ETRF extent - approximately 16?W to 33?E and 
> 33?N to 84?N.
>
> PROJ string:
> +proj=pipeline
> ? +step +proj=axisswap +order=2,1
> ? +step +proj=unitconvert +xy_in=deg +xy_out=rad
> ? +step +proj=cart +ellps=GRS80
> ? +step +proj=helmert +x=0 +y=0 +z=0 +rx=0.002236 +ry=0.013494 
> +rz=-0.019578 +s=0
> ? ? ? ? +dx=0 +dy=0 +dz=0 +drx=8.6e-05 +dry=0.000519 +drz=-0.000753 +ds=0
> ? ? ? ? +t_epoch=2015 +convention=position_vector
> ? +step +inv +proj=cart +ellps=GRS80
> ? +step +proj=unitconvert +xy_in=rad +xy_out=deg
> ? +step +proj=axisswap +order=2,1
> ...
>
> Am I doing anything wrong?
> I guessed that EPSG:10573 is a transformation between geocentric 
> systems, while PROJ:ETRS89_TO_ETRF2020 is between geographic 2D. So 
> there could be a missing geocentric->geographic2D in between. But I 
> don't know how to set it.
> It is also surprising that not only it is not finding this 
> concatenated operation, but not finding anyone!
>
> Thanks,
> Javier
>
> On Tue, 3 Sept 2024 at 13:21, Even Rouault 
> <even.rouault at spatialys.com> wrote:
>
>     Javier,
>>
>>     In the DB, the operation registered is ETRS89_TO_ETRF2020, so it
>>     has to be "inverted". However, I do not see any way to indicate
>>     that in the concatenated operation.
>>
>>     For instance, this concatenated operation does not mention that
>>     the second step should be "inverted" (if I understood correctly)
>>     ? ? ('NKG', 'ITRF2014_TO_DK', 1, 'EPSG', '8366'), -- ITRF2014 ->
>>     ETRF2014
>>     ? ? ('NKG', 'ITRF2014_TO_DK', 2, 'NKG', 'NKG_ETRF14_TO_ETRF2014'),
>>     ? ? ('NKG', 'ITRF2014_TO_DK', 3, 'NKG', 'PAR_2020_DK'),
>>     ? ? ('NKG', 'ITRF2014_TO_DK', 4, 'NKG', 'DK_2020_INTRAPLATE')
>>
>>     Does it mean that PROJ is finding it automatically?
>     Unfortunately yes, PROJ has to figure out the direction of
>     operations, and it is an awful and error prone job, especially
>     when one of the step is a conversion which lacks explicit source
>     and target CRS. I complained about that to IOGP to ask to add a
>     direction (forward/inverse) column in the coordinate_step table,
>     but I wasn't apparently sufficiently convincing.
>>
>>     Thanks.
>>
>>     PS Should I add the concatenated operation (ITRF2020->ETRS89) to
>>     PROJ in a PR? There are different "paths" from ITRF2020 to
>>     ETRS89. All apparently equivalent, but probably not exactly the same.
>
>     Maybe try first to see if EPSG wants to add it?
>
>
>     -- 
>     http://www.spatialys.com
>     My software is free, but my time generally not.
>
-- 
http://www.spatialys.com
My software is free, but my time generally not.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240903/151bf15a/attachment.htm>

From j1 at jimenezshaw.com  Tue Sep  3 08:30:12 2024
From: j1 at jimenezshaw.com (Javier Jimenez Shaw)
Date: Tue, 3 Sep 2024 17:30:12 +0200
Subject: [PROJ] Transformations in ITRF2020
In-Reply-To: <ad0c4f4f-cfef-4af9-9588-57ccb4a147db@spatialys.com>
References: <CADRrdKuP1wWPOT4a_TUduBNM_0Hfgp0qfhEp1aadpECng8hyCg@mail.gmail.com>
 <62d0636a-98c1-400e-b11d-e13e311e7913@spatialys.com>
 <CADRrdKsHS_4X_SpunFV0KJe2Ng4ZtTxB1qFYiNWUAgfSBA38CA@mail.gmail.com>
 <865152be-1d41-4e08-97d9-9e6bf1ea5360@spatialys.com>
 <CADRrdKtKaC4=K7PZD_zYX-1NXJRpcFR06HX5zEQqGd7dBcNKgw@mail.gmail.com>
 <ad0c4f4f-cfef-4af9-9588-57ccb4a147db@spatialys.com>
Message-ID: <CADRrdKvc+zXJXSKjgtF5yH7PBYr7HyvqLJE9BFWuS8Lxd3+40A@mail.gmail.com>

Thank you!
It connects now with the transformation to CH1903+

I was not expecting that having the same bbox, different extents were
producing different results.

Cheers.
Javier.

On Tue, 3 Sept 2024 at 17:04, Even Rouault <even.rouault at spatialys.com>
wrote:

> Javier,
>
> Inspecting with "projinfo -k operation PROJ:ITRF2020_TO_ETRS89", you got
> the extent code wrong, it should be EPSG:4755 (using the same one as ETRS89)
>
> The magic in the instantiation of concatenated operations also takes care
> of inserting the appropriate geographic<-->geocentric conversion steps. Cf
> https://github.com/OSGeo/PROJ/blob/master/src/iso19111/operation/concatenatedoperation.cpp#L554-L571
> Once fixed, "projinfo ETRS89 ITRF2020" (only) reports that transformation.
>
> Even
> Le 03/09/2024 ? 16:35, Javier Jimenez Shaw a ?crit :
>
> Well. I tried it... and something does not work (probably a silly mistake)
>
> at the end of data/sql/other_transformation_custom.sql I added this:
>
> INSERT INTO "concatenated_operation"
> VALUES('PROJ','ITRF2020_TO_ETRS89','ITRF2020 to ETRS89','Time-dependent
> transformation from ITRF2020 to ETRS89 based on
> EPSG:10573','EPSG','9990','EPSG','4258',0.1,NULL,0);
> INSERT INTO "concatenated_operation_step"
> VALUES('PROJ','ITRF2020_TO_ETRS89',1,'EPSG','10573');
> INSERT INTO "concatenated_operation_step"
> VALUES('PROJ','ITRF2020_TO_ETRS89',2,'PROJ','ETRS89_TO_ETRF2020');
> INSERT INTO "usage" VALUES(
>     'PROJ',
>     'ITRF2020_TO_ETRS89_USAGE',
>     'concatenated_operation',
>     'PROJ',
>     'ITRF2020_TO_ETRS89',
>     'EPSG','1289', -- extent
>     'EPSG','1024'  -- unknown
> );
>
> And the transformation is this ballpark:
>
> PROJ_DATA=../data/ ./projinfo EPSG:9990 EPSG:4258 --spatial-test
> intersects --bbox 7,42,8,43 -o proj
> Candidate operations found: 1
> -------------------------------------
> Operation No. 1:
>
> unknown id, Ballpark geographic offset from ITRF2020 to ETRS89, unknown
> accuracy, World, has ballpark transformation
>
> PROJ string:
> +proj=noop
>
> While without that change it is this (just showing the first
> transformation)
>
> PROJ_DATA=../data/ ./projinfo EPSG:9990 EPSG:4258 --spatial-test
> intersects --bbox 7,42,8,43 -o proj
> Candidate operations found: 4
> -------------------------------------
> Operation No. 1:
>
> unknown id, Conversion from ITRF2020 (geog2D) to ITRF2020 (geocentric) +
> ITRF2020 to ETRF2020 (2) + Conversion from ETRF2020 (geocentric) to
> ETRF2020 (geog2D) + Inverse of ETRS89 to ETRF2020, 0.1 m, Europe - onshore
> and offshore - ETRF extent - approximately 16?W to 33?E and 33?N to 84?N.
>
> PROJ string:
> +proj=pipeline
>   +step +proj=axisswap +order=2,1
>   +step +proj=unitconvert +xy_in=deg +xy_out=rad
>   +step +proj=cart +ellps=GRS80
>   +step +proj=helmert +x=0 +y=0 +z=0 +rx=0.002236 +ry=0.013494
> +rz=-0.019578 +s=0
>         +dx=0 +dy=0 +dz=0 +drx=8.6e-05 +dry=0.000519 +drz=-0.000753 +ds=0
>         +t_epoch=2015 +convention=position_vector
>   +step +inv +proj=cart +ellps=GRS80
>   +step +proj=unitconvert +xy_in=rad +xy_out=deg
>   +step +proj=axisswap +order=2,1
> ...
>
> Am I doing anything wrong?
> I guessed that EPSG:10573 is a transformation between geocentric systems,
> while PROJ:ETRS89_TO_ETRF2020 is between geographic 2D. So there could be a
> missing geocentric->geographic2D in between. But I don't know how to set it.
> It is also surprising that not only it is not finding this concatenated
> operation, but not finding anyone!
>
> Thanks,
> Javier
>
> On Tue, 3 Sept 2024 at 13:21, Even Rouault <even.rouault at spatialys.com>
> wrote:
>
>> Javier,
>>
>>
>> In the DB, the operation registered is ETRS89_TO_ETRF2020, so it has to
>> be "inverted". However, I do not see any way to indicate that in the
>> concatenated operation.
>>
>> For instance, this concatenated operation does not mention that the
>> second step should be "inverted" (if I understood correctly)
>>     ('NKG', 'ITRF2014_TO_DK', 1, 'EPSG', '8366'), -- ITRF2014 -> ETRF2014
>>     ('NKG', 'ITRF2014_TO_DK', 2, 'NKG', 'NKG_ETRF14_TO_ETRF2014'),
>>     ('NKG', 'ITRF2014_TO_DK', 3, 'NKG', 'PAR_2020_DK'),
>>     ('NKG', 'ITRF2014_TO_DK', 4, 'NKG', 'DK_2020_INTRAPLATE')
>>
>> Does it mean that PROJ is finding it automatically?
>>
>> Unfortunately yes, PROJ has to figure out the direction of operations,
>> and it is an awful and error prone job, especially when one of the step is
>> a conversion which lacks explicit source and target CRS. I complained about
>> that to IOGP to ask to add a direction (forward/inverse) column in the
>> coordinate_step table, but I wasn't apparently sufficiently convincing.
>>
>>
>> Thanks.
>>
>> PS Should I add the concatenated operation (ITRF2020->ETRS89) to PROJ in
>> a PR? There are different "paths" from ITRF2020 to ETRS89. All apparently
>> equivalent, but probably not exactly the same.
>>
>> Maybe try first to see if EPSG wants to add it?
>>
>> -- http://www.spatialys.com
>> My software is free, but my time generally not.
>>
>> -- http://www.spatialys.com
> My software is free, but my time generally not.
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240903/db142dcb/attachment-0001.htm>

From j1 at jimenezshaw.com  Wed Sep  4 02:27:54 2024
From: j1 at jimenezshaw.com (Javier Jimenez Shaw)
Date: Wed, 4 Sep 2024 11:27:54 +0200
Subject: [PROJ] Strange behaviour using PROJ from conda
Message-ID: <CADRrdKvvSA=VvUHek82me79ALadSfH7D8UQXtEjafCGQ4dMMpw@mail.gmail.com>

Hi

I installed today proj via conda, that includes a PROJ 9.4.1.
conda install -c conda-forge proj
...
proj               conda-forge/linux-64::proj-9.4.1-h54d7996_1

I am working with a (time dependent) transformation from ITRF2020 to
ETRS89. (not modifying the db ;)

The problem is that projinfo is suggesting a transformation that makes
sense, but cs2cs is doing a ballpark.

However, if I compile PROJ 9.4.1 on my own, it works fine.

Here are some commands.

In the Conda environment:

$ which cs2cs
/home/jshaw/anaconda3/envs/testproj/bin/cs2cs

$ cs2cs
Rel. 9.4.1, June 1st, 2024
...

$ echo 46 6 0 2024.6 | PROJ_DEBUG=3  cs2cs EPSG:9989 EPSG:4937 -d 9
pj_open_lib(proj.ini): call
fopen(/home/jshaw/anaconda3/envs/testproj/share/proj/proj.ini) - succeeded
pj_open_lib(proj.db): call
fopen(/home/jshaw/anaconda3/envs/testproj/share/proj/proj.db) - succeeded
... (removed for clarity. I can send it if needed) ...
Using coordinate operation Ballpark geographic offset from ITRF2020 to
ETRS89
46.000000000 6.000000000 0.000000000 2024.6

$ projinfo -s EPSG:9989 -t EPSG:4937 -o proj --bbox 5.5,45.5,6.5,46.5
Candidate operations found: 4
-------------------------------------
Operation No. 1:

unknown id, Conversion from ITRF2020 (geog3D) to ITRF2020 (geocentric) +
ITRF2020 to ETRF2020 (2) + Conversion from ETRF2020 (geocentric) to
ETRF2020 (geog2D) + Inverse of ETRS89 to ETRF2020 + Null geographic offset
from ETRS89 (geog2D) to ETRS89 (geog3D), 0.1 m, Europe - onshore and
offshore: Albania; Andorra; Austria; Belgium; Bosnia and Herzegovina;
Bulgaria; Croatia; Cyprus; Czechia; Denmark; Estonia; Faroe Islands;
Finland; France; Germany; Gibraltar; Greece; Hungary; Ireland; Italy;
Kosovo; Latvia; Liechtenstein; Lithuania; Luxembourg; Malta; Moldova;
Monaco; Montenegro; Netherlands; North Macedonia; Norway including Svalbard
and Jan Mayen; Poland; Portugal; Romania; San Marino; Serbia; Slovakia;
Slovenia; Spain; Sweden; Switzerland; United Kingdom (UK) including Channel
Islands and Isle of Man; Vatican City State.

PROJ string:
+proj=pipeline
  +step +proj=axisswap +order=2,1
  +step +proj=unitconvert +xy_in=deg +z_in=m +xy_out=rad +z_out=m
  +step +proj=cart +ellps=GRS80
  +step +proj=helmert +x=0 +y=0 +z=0 +rx=0.002236 +ry=0.013494
+rz=-0.019578 +s=0
        +dx=0 +dy=0 +dz=0 +drx=8.6e-05 +dry=0.000519 +drz=-0.000753 +ds=0
        +t_epoch=2015 +convention=position_vector
  +step +inv +proj=cart +ellps=GRS80
  +step +proj=unitconvert +xy_in=rad +z_in=m +xy_out=deg +z_out=m
  +step +proj=axisswap +order=2,1

-------------------------------------
...

If I run it in my compiled PROJ 9.4.1 out of Conda:

$ echo 46 6 0 2024.6 | PROJ_DEBUG=ON ./cs2cs EPSG:9989 EPSG:4937 -d 9
pj_open_lib(proj.ini): call
fopen(/home/jshaw/work/projs/proj_9.4.1/share/proj/proj.ini) - succeeded
pj_open_lib(proj.db): call
fopen(/home/jshaw/work/projs/proj_9.4.1/share/proj/proj.db) - succeeded
pj_open_lib(eur_nkg_nkgrf17vel.tif): call fopen(eur_nkg_nkgrf17vel.tif) -
failed
pj_open_lib(no_kv_NKGETRF14_EPSG7922_2000.tif): call
fopen(no_kv_NKGETRF14_EPSG7922_2000.tif) - failed
pj_open_lib(eur_nkg_nkgrf03vel_realigned.tif): call
fopen(eur_nkg_nkgrf03vel_realigned.tif) - failed
Using coordinate operation Conversion from ITRF2020 (geog3D) to ITRF2020
(geocentric) + ITRF2020 to ETRF2020 (2) + Conversion from ETRF2020
(geocentric) to ETRF2020 (geog2D) + Inverse of ETRS89 to ETRF2020 + Null
geographic offset from ETRS89 (geog2D) to ETRS89 (geog3D)
45.999994986 5.999991132 -0.001870790 2024.6

Any clue what is happening there?

Thank you.
Javier
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240904/cc798ecb/attachment.htm>

From gdt at lexort.com  Wed Sep  4 09:52:33 2024
From: gdt at lexort.com (Greg Troxel)
Date: Wed, 04 Sep 2024 12:52:33 -0400
Subject: [PROJ] -Wextra-semi breaking build with gcc7
Message-ID: <rmibk132wfi.fsf@s1.lexort.com>

CMakeLists.txt has

-Wextra-semi

but it does not validate that the compiler is ok with that option.
This leads to a failure on NetBSD 9 which has gcc 7.

For now I'm patching it out, but I wonder how cmake intends to deal with
this.  One can't assume that any particular nonstandard warning flags
are acceptable; I think each needs to have a trial compile and only be
added if that passes.  But I am not cmake-clueful enough to know how.


http://www.ki.nu/pkgsrc/reports/current/NetBSD-9.0/20240901.2232/proj-9.4.1/build.log

From even.rouault at spatialys.com  Wed Sep  4 09:56:04 2024
From: even.rouault at spatialys.com (Even Rouault)
Date: Wed, 4 Sep 2024 18:56:04 +0200
Subject: [PROJ] -Wextra-semi breaking build with gcc7
In-Reply-To: <rmibk132wfi.fsf@s1.lexort.com>
References: <rmibk132wfi.fsf@s1.lexort.com>
Message-ID: <94d956c4-44b1-4984-a37f-e7421bd464ce@spatialys.com>

Has already been fixed in master / 9.5dev per 
https://github.com/OSGeo/PROJ/commit/de8118616a668fe92f2c0aadc847449b0d0d122a

That said our CI no longer test such antiquated beasts, so you're on 
your own if you choose to support them.

Le 04/09/2024 ? 18:52, Greg Troxel via PROJ a ?crit?:
> CMakeLists.txt has
>
> -Wextra-semi
>
> but it does not validate that the compiler is ok with that option.
> This leads to a failure on NetBSD 9 which has gcc 7.
>
> For now I'm patching it out, but I wonder how cmake intends to deal with
> this.  One can't assume that any particular nonstandard warning flags
> are acceptable; I think each needs to have a trial compile and only be
> added if that passes.  But I am not cmake-clueful enough to know how.
>
>
> http://www.ki.nu/pkgsrc/reports/current/NetBSD-9.0/20240901.2232/proj-9.4.1/build.log
> _______________________________________________
> PROJ mailing list
> PROJ at lists.osgeo.org
> https://lists.osgeo.org/mailman/listinfo/proj

-- 
http://www.spatialys.com
My software is free, but my time generally not.


From even.rouault at spatialys.com  Wed Sep  4 12:00:58 2024
From: even.rouault at spatialys.com (Even Rouault)
Date: Wed, 4 Sep 2024 21:00:58 +0200
Subject: [PROJ] Strange behaviour using PROJ from conda
In-Reply-To: <CADRrdKvvSA=VvUHek82me79ALadSfH7D8UQXtEjafCGQ4dMMpw@mail.gmail.com>
References: <CADRrdKvvSA=VvUHek82me79ALadSfH7D8UQXtEjafCGQ4dMMpw@mail.gmail.com>
Message-ID: <a9f71395-056a-4e44-90cc-bd3e30b07068@spatialys.com>

Javier,

The Conda vs your build difference can be easily explained because Conda 
sets PROJ_NETWORK=ON in the conda environment.

When PROJ_NETWORK=ON, you can also get the expected result by adding 
--bbox as well to cs2cs.

Now, the real issue is why PROJ_NETWORK=ON without --box does 
(negatively) affect results .. ? The reason is that in that situation 
the heuristics first finds the NKG related operations, and does not 
think it needs to do extra efforts to consider intermediate CRSs to get 
other solutions. Unfortunately the NKG solutions only cover a small 
proportion of the area of use of the source/target CRS, so they are not 
good general purpose solutions.

I've tuned this in https://github.com/OSGeo/PROJ/pull/4244

Now:

$ echo 46 6 0 2024.6 |? PROJ_NETWORK=OFF bin/cs2cs EPSG:9989 EPSG:4937 -d 9
45.999994986??? 5.999991132 -0.001870790 2024.6
$ echo 46 6 0 2024.6 |? PROJ_NETWORK=ON bin/cs2cs EPSG:9989 EPSG:4937 -d 9
45.999994986??? 5.999991132 -0.001870790 2024.6
$ echo 46 6 0 2024.6 |? PROJ_NETWORK=OFF bin/cs2cs EPSG:9989 EPSG:4937 
-d 9 --bbox 5.5,45.5,6.5,46.5
45.999994986??? 5.999991132 -0.001870790 2024.6
$ echo 46 6 0 2024.6 |? PROJ_NETWORK=ON bin/cs2cs EPSG:9989 EPSG:4937 -d 
9 --bbox 5.5,45.5,6.5,46.5
45.999994986??? 5.999991132 -0.001870790 2024.6

(Anybody wanting to do a "Fast, reliable and geodetic-grade qualiy 
coordinate operation inference from a geodetic database" master or PhD 
thesis ... ? I may consider mentoring them, unless they decide to put 
some AI in the equation ;-) ;-). Or perhaps that's actually the way to 
do it. Spy all conversations occurring in offices of geodetic 
institutions and coordinate transformation software editors, 
speech-to-text them, ingest that into a LLM, and add some sanity filter 
on the garbage it spits out)

Even

-- 
http://www.spatialys.com
My software is free, but my time generally not.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240904/6b8cd472/attachment.htm>

From kristianevers at gmail.com  Mon Sep  9 05:01:45 2024
From: kristianevers at gmail.com (Kristian Evers)
Date: Mon, 9 Sep 2024 14:01:45 +0200
Subject: [PROJ] PROJ 9.5.0RC1 & PROJ-data 1.19RC1
Message-ID: <47648E58-2C47-4815-B367-6B10E765F0C3@gmail.com>

All,

in preparation for a new round of PROJ and PROJ-data release I have uploaded release candidates for both packages.

Download the archives here: 

https://download.osgeo.org/proj/proj-9.5.0RC1.tar.gz
https://download.osgeo.org/proj/proj-9.5.0RC1.zip

https://download.osgeo.org/proj/proj-data-1.19RC1.tar.gz
https://download.osgeo.org/proj/proj-data-1.19RC1.zip

The PROJ release includes various updates and bug fixes. See the release notes below.

The PROJ-data release is updated with grids related to the Greenlandic GLMSL and GLLAT.

Please test the release candidates and report any issues you may find with them.
Either here on the mailing list or on GitHub.

/Kristian


## 9.5.0

### Updates

* Database: add constraint for unicity of CRS and operation names (#4071)

* Make a few more functions that accept a `PJ*` to actually acccept a `const PJ*` (#4074)

* Database: Increase consistency in trigger checks (#4080)

* Speed-up `+proj=cart +inv` (#4087)

* Added EPSG:9656 "Cartesian Grid Offsets" operation method, and imported related records (#4094)

* Add a `WKTParser::grammarErrorList()` method so that `proj_create_from_wkt()` can behave as documented (#4108)

* `CRS::stripVerticalComponent()`: Redirect it to `demoteTo2D(std::string(), nullptr)` (#4127)

* Add `proj_context_set_user_writable_directory()` to public API (#4144)

* CMake: for Windows builds, defaults PROJ DLL to be just `proj_${PROJ_MAJOR_VERSION}.dll` (#4167)

* Add `toWGS84AutocorrectWrongValues()` method and use it in PROJ.4 and WKT1 CRS import (#4172)

* WKT import: add support for Oracle WKT "Albers_Conical_Equal_Area" spelling (#4181)

* Limit number of C++ exceptions thrown & caught internally (#4183)

* Database: update to EPSG 11.016 (#4241)

* CMake: add option `EMBED_PROJ_DATA_PATH` (#4207)

* Add SEA Inverse projection (#4211)

* projinfo: Add 2 args equivalent to usage of `-s` and `-t` (#4218)

* CMake: add TESTING_USE_NETWORK configure option (#4220)

* Add `PROJ_ERR_COORD_TRANSFM_MISSING_TIME` and `proj_coordoperation_requires_per_coordinate_input_time()` (#4221)

* Add new Conversion "Local Orthographic" (#4228, #4229)

* Add data/ITRF2020 with ITRF2020 to ITRFother, and ITRF2020 plate motion models (#4235)

### Bug Fixes

* Fix `imoll` and `imoll_o` zone calculations to correct inverse transformations near the "seams" (#4159)

* Fix wrong EPSG conversion code for UTM south (#4166)

* BoundCRS::exportToPROJ(): handle case of NADCON conus grid (#4168)

* `+proj=gridshift`: make projected grids work with `PROJ_NETWORK=ON` (#4174)

* `createOperations()`: make it work when transforming from/to a CompoundCRS with a DerivedVerticalCRS with ellipsoidal height (#4176)

* Support default context as `nullptr` in `CoordinateTransformer` (#4177)

* cct: emit error message and return error code when not being able to open input file (#4200)

* Fix race condition surrounding DB reopening during fork (#4231)

* `GeographicBoundingBox::create()`: accept degenerate bounding box reduced to a point or a line (#4237)

* `createOperation()`: tune so that ITRF2000->ETRS89 does not return only NKG grid based operations but also time-dependent Helmert (#4244)



From jerome at ecere.com  Tue Sep 10 18:19:20 2024
From: jerome at ecere.com (=?UTF-8?B?SsOpcsO0bWUgU3QtTG91aXM=?=)
Date: Tue, 10 Sep 2024 21:19:20 -0400
Subject: [PROJ] Geodetic to Authalic latitude conversions
Message-ID: <9ed4372a-f6a3-4420-b32b-232c3c4638b0@ecere.com>

Hi Even, all,

As suggested in https://github.com/OSGeo/PROJ/pull/4211 , I've just 
written an implementation of the authalic / geodetic latitude conversion 
with the goal to automatically perform this conversion when using ISEA 
with an non-spherical ellipsoid, and was wondering whether we would want 
to improve the PROJ version (/pj_authlat()/ for the geodetic ==> 
authalic), which is used for ISEA, but also by:

- Equal Area Cylindrical (cea.cpp)
- EqualEarth (eqearth.cpp)
- HEALPix (healpix.cpp) -- which might also imply rHEALPix
- Lambert Azimuthal Equal Area (laea.cpp)

The current version of /pj_authlat()/ uses a series expansion based on 
the eccentricity squared (I believe this is based on a Lagrange 
reversion <https://en.wikipedia.org/wiki/Lagrange_inversion_theorem> as 
mentioned here 
<https://en.wikipedia.org/wiki/Latitude#Inverse_formulae_and_series>), 
and Charles Karney in this paper <https://arxiv.org/pdf/2212.05818> 
establishes that:

> /series expansions using the third flattening as the small parameter 
> uniformly result in smaller truncation errors compared to using the 
> eccentricity./
The current version also only uses order 3, whereas GeographicLib would 
normally use order 6 for double precision, with order 4 being the 
minimum configuration.
The current order 3, which requires 2 /sin()/ calls, gives precision up 
to roughly 8 decimals.
Order 6 would mean twice the number of /sin()/ calls, and the 8 decimals 
should be enough to point to Waldo on a page <https://xkcd.com/2170/>, 
however C.K. argues that:

> /Modern geodetic libraries should strive to achieve full 
> double-precision accuracy /(page 4)/
> /

and I would much agree with that.

Based on the direction we want to go, I would submit a PR including 
adjustments to avoid the separate heap allocation for the doubles (as 
discussed here 
<https://github.com/OSGeo/PROJ/pull/4211#pullrequestreview-2233903246>), 
and adjustments for tests etc.

PROJ currently does not use the full GeographicLib which already 
includes code for conversion between different auxiliary latitudes, does it?

 ??? ( 
https://github.com/geographiclib/geographiclib/blob/main/src/AuxLatitude.cpp 
)

See my proposed new version below, which I wrote based on equation 20 on 
page 3, and matrix A20 on page 13 from the paper, applying optimizations 
similar to the current /pj_authlat()/.

Kind regards,

-Jerome

> void pj_authset(double a, double b, double cp[6])
> {
> ?? // https://arxiv.org/pdf/2212.05818
> ?? // ??(?) = S^(L)(?) ? C?? ? P^(M) (n) + O(n^L+1)??? -- (20)
> ?? double n = (a - b) / (a + b);? // Third flattening
> ?? static const double C[21] = // (A20)
> ?? {
> ????? 4 / 3.0,? 4 / 45.0,?? -16/35.0,? -2582 /14175.0,? 60136 
> /467775.0,??? 28112932/ 212837625.0,
> ?????????????? 46 / 45.0,? 152/945.0, -11966 /14175.0, -21016 / 
> 51975.0,?? 251310128/ 638512875.0,
> ???????????????????????? 3044/2835.0,?? 3802 /14175.0, -94388 / 
> 66825.0,??? -8797648/? 10945935.0,
> ??????????????????????????????????????? 6059 / 4725.0,? 41072 / 
> 93555.0, -1472637812/ 638512875.0,
> ?????????????????????????????????????????????????????? 768272 
> /467775.0,? -455935736/ 638512875.0,
> 4210684958/1915538625.0
> ?? };
> ?? double p;
>
> ?? cp[0]? = C[ 0] * n;
>
> ?? p = n * n;
> ?? cp[0] += C[ 1] * p;
> ?? cp[1]? = C[ 6] * p;
>
> ?? p *= n;
> ?? cp[0] += C[ 2] * p;
> ?? cp[1] += C[ 7] * p;
> ?? cp[2]? = C[11] * p;
>
> ?? p *= n;
> ?? cp[0] += C[ 3] * p;
> ?? cp[1] += C[ 8] * p;
> ?? cp[2] += C[12] * p;
> ?? cp[3]? = C[15] * p;
>
> ?? p *= n;
> ?? cp[0] += C[ 4] * p;
> ?? cp[1] += C[ 9] * p;
> ?? cp[2] += C[13] * p;
> ?? cp[3] += C[16] * p;
> ?? cp[4]? = C[18] * p;
>
> ?? p *= n;
> ?? cp[0] += C[ 5] * p;
> ?? cp[1] += C[10] * p;
> ?? cp[2] += C[14] * p;
> ?? cp[3] += C[17] * p;
> ?? cp[4] += C[19] * p;
> ?? cp[5]? = C[20] * p;
> }
>
> double pj_authlat(double auth, const double * cp)
> {
> ?? // https://arxiv.org/pdf/2212.05818
> ?? // ??(?) = S^(L)(?) ? C?? ? P^(M) (n) + O(n^L+1)??? -- (20)
> ?? double a2x = auth + auth, a4x = a2x + a2x, a8x = a4x + a4x;
> ?? return auth +
> ????? cp[0] * sin(a2x) +
> ????? cp[1] * sin(a4x) +
> ????? cp[2] * sin(a4x + a2x) +
> ????? cp[3] * sin(a8x) +
> ????? cp[4] * sin(a8x + a2x) +
> ????? cp[5] * sin(a8x + a4x);
> }
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240910/8866f84c/attachment.htm>

From jerome at ecere.com  Tue Sep 10 18:36:24 2024
From: jerome at ecere.com (=?UTF-8?B?SsOpcsO0bWUgU3QtTG91aXM=?=)
Date: Tue, 10 Sep 2024 21:36:24 -0400
Subject: [PROJ] Geodetic to Authalic latitude conversions
In-Reply-To: <9ed4372a-f6a3-4420-b32b-232c3c4638b0@ecere.com>
References: <9ed4372a-f6a3-4420-b32b-232c3c4638b0@ecere.com>
Message-ID: <450be707-b926-4e03-9025-f1b66badcd64@ecere.com>

Sorry I should correct a few confusing mistakes in my previous e-mail:

 ??? - I was talking mainly about authalic latitude ==> geodetic 
latitude conversion, not the other way around.
/pj_authlat()/ returns the geodetic latitude for a given authalic 
latitude (the name of the function is quite confusing -- I would propose 
to rename to something less ambiguous if it is only used internally)

 ??? - The function currently uses 3 /sin()/ calls for order 3 (not 2, 
made a typo)

 ??? - The ISEA projection does not currently make use of /pj_authlat()/ 
or /pj_qsfn() /for automatically converting authalic / geodetic 
latitudes, but I am proposing to introduce this when using non-spherical 
ellipsoid (just like LAEA of which it is a modified form).

Best,

-Jerome

On 9/10/24 9:19 PM, J?r?me St-Louis via PROJ wrote:
>
> Hi Even, all,
>
> As suggested in https://github.com/OSGeo/PROJ/pull/4211 , I've just 
> written an implementation of the authalic / geodetic latitude 
> conversion with the goal to automatically perform this conversion when 
> using ISEA with an non-spherical ellipsoid, and was wondering whether 
> we would want to improve the PROJ version (/pj_authlat()/ for the 
> geodetic ==> authalic), which is used for ISEA, but also by:
>
> - Equal Area Cylindrical (cea.cpp)
> - EqualEarth (eqearth.cpp)
> - HEALPix (healpix.cpp) -- which might also imply rHEALPix
> - Lambert Azimuthal Equal Area (laea.cpp)
>
> The current version of /pj_authlat()/ uses a series expansion based on 
> the eccentricity squared (I believe this is based on a Lagrange 
> reversion <https://en.wikipedia.org/wiki/Lagrange_inversion_theorem> 
> as mentioned here 
> <https://en.wikipedia.org/wiki/Latitude#Inverse_formulae_and_series>), 
> and Charles Karney in this paper <https://arxiv.org/pdf/2212.05818> 
> establishes that:
>
>> /series expansions using the third flattening as the small parameter 
>> uniformly result in smaller truncation errors compared to using the 
>> eccentricity./
> The current version also only uses order 3, whereas GeographicLib 
> would normally use order 6 for double precision, with order 4 being 
> the minimum configuration.
> The current order 3, which requires 2 /sin()/ calls, gives precision 
> up to roughly 8 decimals.
> Order 6 would mean twice the number of /sin()/ calls, and the 8 
> decimals should be enough to point to Waldo on a page 
> <https://xkcd.com/2170/>, however C.K. argues that:
>
>> /Modern geodetic libraries should strive to achieve full 
>> double-precision accuracy /(page 4)/
>> /
>
> and I would much agree with that.
>
> Based on the direction we want to go, I would submit a PR including 
> adjustments to avoid the separate heap allocation for the doubles (as 
> discussed here 
> <https://github.com/OSGeo/PROJ/pull/4211#pullrequestreview-2233903246>), 
> and adjustments for tests etc.
>
> PROJ currently does not use the full GeographicLib which already 
> includes code for conversion between different auxiliary latitudes, 
> does it?
>
> ??? ( 
> https://github.com/geographiclib/geographiclib/blob/main/src/AuxLatitude.cpp 
> )
>
> See my proposed new version below, which I wrote based on equation 20 
> on page 3, and matrix A20 on page 13 from the paper, applying 
> optimizations similar to the current /pj_authlat()/.
>
> Kind regards,
>
> -Jerome
>
>> void pj_authset(double a, double b, double cp[6])
>> {
>> ?? // https://arxiv.org/pdf/2212.05818
>> ?? // ??(?) = S^(L)(?) ? C?? ? P^(M) (n) + O(n^L+1)??? -- (20)
>> ?? double n = (a - b) / (a + b);? // Third flattening
>> ?? static const double C[21] = // (A20)
>> ?? {
>> ????? 4 / 3.0,? 4 / 45.0,?? -16/35.0,? -2582 /14175.0,? 60136 
>> /467775.0,??? 28112932/ 212837625.0,
>> ?????????????? 46 / 45.0,? 152/945.0, -11966 /14175.0, -21016 / 
>> 51975.0,?? 251310128/ 638512875.0,
>> ???????????????????????? 3044/2835.0,?? 3802 /14175.0, -94388 / 
>> 66825.0,??? -8797648/? 10945935.0,
>> ??????????????????????????????????????? 6059 / 4725.0,? 41072 / 
>> 93555.0, -1472637812/ 638512875.0,
>> ?????????????????????????????????????????????????????? 768272 
>> /467775.0,? -455935736/ 638512875.0,
>> 4210684958/1915538625.0
>> ?? };
>> ?? double p;
>>
>> ?? cp[0]? = C[ 0] * n;
>>
>> ?? p = n * n;
>> ?? cp[0] += C[ 1] * p;
>> ?? cp[1]? = C[ 6] * p;
>>
>> ?? p *= n;
>> ?? cp[0] += C[ 2] * p;
>> ?? cp[1] += C[ 7] * p;
>> ?? cp[2]? = C[11] * p;
>>
>> ?? p *= n;
>> ?? cp[0] += C[ 3] * p;
>> ?? cp[1] += C[ 8] * p;
>> ?? cp[2] += C[12] * p;
>> ?? cp[3]? = C[15] * p;
>>
>> ?? p *= n;
>> ?? cp[0] += C[ 4] * p;
>> ?? cp[1] += C[ 9] * p;
>> ?? cp[2] += C[13] * p;
>> ?? cp[3] += C[16] * p;
>> ?? cp[4]? = C[18] * p;
>>
>> ?? p *= n;
>> ?? cp[0] += C[ 5] * p;
>> ?? cp[1] += C[10] * p;
>> ?? cp[2] += C[14] * p;
>> ?? cp[3] += C[17] * p;
>> ?? cp[4] += C[19] * p;
>> ?? cp[5]? = C[20] * p;
>> }
>>
>> double pj_authlat(double auth, const double * cp)
>> {
>> ?? // https://arxiv.org/pdf/2212.05818
>> ?? // ??(?) = S^(L)(?) ? C?? ? P^(M) (n) + O(n^L+1)??? -- (20)
>> ?? double a2x = auth + auth, a4x = a2x + a2x, a8x = a4x + a4x;
>> ?? return auth +
>> ????? cp[0] * sin(a2x) +
>> ????? cp[1] * sin(a4x) +
>> ????? cp[2] * sin(a4x + a2x) +
>> ????? cp[3] * sin(a8x) +
>> ????? cp[4] * sin(a8x + a2x) +
>> ????? cp[5] * sin(a8x + a4x);
>> }
>
> _______________________________________________
> PROJ mailing list
> PROJ at lists.osgeo.org
> https://lists.osgeo.org/mailman/listinfo/proj
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240910/f5effbd3/attachment-0001.htm>

From even.rouault at spatialys.com  Wed Sep 11 00:27:55 2024
From: even.rouault at spatialys.com (Even Rouault)
Date: Wed, 11 Sep 2024 09:27:55 +0200
Subject: [PROJ] Geodetic to Authalic latitude conversions
In-Reply-To: <450be707-b926-4e03-9025-f1b66badcd64@ecere.com>
References: <9ed4372a-f6a3-4420-b32b-232c3c4638b0@ecere.com>
 <450be707-b926-4e03-9025-f1b66badcd64@ecere.com>
Message-ID: <ac408a8f-9044-40ad-bdbc-debd10e162f6@spatialys.com>

Hi J?r?me,

I was wondering if we could not save trigonometric computations noting that

sin(a + b) = sin(a) * cos(b) + cos(a) * sin(b)

and applying that recursively. At the end we would just to have to 
compute sin(auth) and cos(auth). But I've no idea about the impact on 
numerical stability of using this trigonometric trick.

My other question would be the "backward" compatibility of this change, 
like if we would need to provide a "+approx_auth_lat" flag to replicate 
current results to use current formulas (like the +approx flag of 
+proj=tmerc when more precise formulas were introduced). But I've no 
specific opinion if it is needed here. It would be good to have some 
examples using let's say WGS84 to see if we're talking about differences 
in results of the order of meters, centimeters, micrometers... ?

It is also not immediately obvious to me to correlate your proposed code 
with the formulas in the paper by just starring at both at the same 
time. Looks like some "interpretation" of the paper has been done. It 
might be straightforward for someone who is familiar with the topic 
enough, but an error could also be easy to make when transcribing in 
code. I'm wondering if it wouldn't be possible to compare numeric 
results with the implementation in AuxLatitude.cpp to have some 
confidence (I've also tried to compare your formulas with the ones of 
that file and can't directly correlate them) ?

Besides those remarks, your proposal generally looks good to my 
non-expert eyes on the topic of authalic latitudes :-)

No, we don't use the C++ GeographicLib, just the C port of it from 
https://github.com/geographiclib/geographiclib-c/tree/main/src

Even

Le 11/09/2024 ? 03:36, J?r?me St-Louis a ?crit?:
>
> Sorry I should correct a few confusing mistakes in my previous e-mail:
>
> ??? - I was talking mainly about authalic latitude ==> geodetic 
> latitude conversion, not the other way around.
> /pj_authlat()/ returns the geodetic latitude for a given authalic 
> latitude (the name of the function is quite confusing -- I would 
> propose to rename to something less ambiguous if it is only used 
> internally)
>
> ??? - The function currently uses 3 /sin()/ calls for order 3 (not 2, 
> made a typo)
>
> ??? - The ISEA projection does not currently make use of 
> /pj_authlat()/ or /pj_qsfn() /for automatically converting authalic / 
> geodetic latitudes, but I am proposing to introduce this when using 
> non-spherical ellipsoid (just like LAEA of which it is a modified form).
>
> Best,
>
> -Jerome
>
> On 9/10/24 9:19 PM, J?r?me St-Louis via PROJ wrote:
>>
>> Hi Even, all,
>>
>> As suggested in https://github.com/OSGeo/PROJ/pull/4211 , I've just 
>> written an implementation of the authalic / geodetic latitude 
>> conversion with the goal to automatically perform this conversion 
>> when using ISEA with an non-spherical ellipsoid, and was wondering 
>> whether we would want to improve the PROJ version (/pj_authlat()/ for 
>> the geodetic ==> authalic), which is used for ISEA, but also by:
>>
>> - Equal Area Cylindrical (cea.cpp)
>> - EqualEarth (eqearth.cpp)
>> - HEALPix (healpix.cpp) -- which might also imply rHEALPix
>> - Lambert Azimuthal Equal Area (laea.cpp)
>>
>> The current version of /pj_authlat()/ uses a series expansion based 
>> on the eccentricity squared (I believe this is based on a Lagrange 
>> reversion <https://en.wikipedia.org/wiki/Lagrange_inversion_theorem> 
>> as mentioned here 
>> <https://en.wikipedia.org/wiki/Latitude#Inverse_formulae_and_series>), 
>> and Charles Karney in this paper <https://arxiv.org/pdf/2212.05818> 
>> establishes that:
>>
>>> /series expansions using the third flattening as the small parameter 
>>> uniformly result in smaller truncation errors compared to using the 
>>> eccentricity./
>> The current version also only uses order 3, whereas GeographicLib 
>> would normally use order 6 for double precision, with order 4 being 
>> the minimum configuration.
>> The current order 3, which requires 2 /sin()/ calls, gives precision 
>> up to roughly 8 decimals.
>> Order 6 would mean twice the number of /sin()/ calls, and the 8 
>> decimals should be enough to point to Waldo on a page 
>> <https://xkcd.com/2170/>, however C.K. argues that:
>>
>>> /Modern geodetic libraries should strive to achieve full 
>>> double-precision accuracy /(page 4)/
>>> /
>>
>> and I would much agree with that.
>>
>> Based on the direction we want to go, I would submit a PR including 
>> adjustments to avoid the separate heap allocation for the doubles (as 
>> discussed here 
>> <https://github.com/OSGeo/PROJ/pull/4211#pullrequestreview-2233903246>), 
>> and adjustments for tests etc.
>>
>> PROJ currently does not use the full GeographicLib which already 
>> includes code for conversion between different auxiliary latitudes, 
>> does it?
>>
>> ??? ( 
>> https://github.com/geographiclib/geographiclib/blob/main/src/AuxLatitude.cpp 
>> )
>>
>> See my proposed new version below, which I wrote based on equation 20 
>> on page 3, and matrix A20 on page 13 from the paper, applying 
>> optimizations similar to the current /pj_authlat()/.
>>
>> Kind regards,
>>
>> -Jerome
>>
>>> void pj_authset(double a, double b, double cp[6])
>>> {
>>> ?? // https://arxiv.org/pdf/2212.05818
>>> ?? // ??(?) = S^(L)(?) ? C?? ? P^(M) (n) + O(n^L+1)??? -- (20)
>>> ?? double n = (a - b) / (a + b);? // Third flattening
>>> ?? static const double C[21] = // (A20)
>>> ?? {
>>> ????? 4 / 3.0,? 4 / 45.0,?? -16/35.0,? -2582 /14175.0, 60136 
>>> /467775.0,??? 28112932/ 212837625.0,
>>> ?????????????? 46 / 45.0,? 152/945.0, -11966 /14175.0, -21016 / 
>>> 51975.0,?? 251310128/ 638512875.0,
>>> ???????????????????????? 3044/2835.0,?? 3802 /14175.0, -94388 / 
>>> 66825.0,??? -8797648/? 10945935.0,
>>> ??????????????????????????????????????? 6059 / 4725.0, 41072 / 
>>> 93555.0, -1472637812/ 638512875.0,
>>> 768272 /467775.0,? -455935736/ 638512875.0,
>>> 4210684958/1915538625.0
>>> ?? };
>>> ?? double p;
>>>
>>> ?? cp[0]? = C[ 0] * n;
>>>
>>> ?? p = n * n;
>>> ?? cp[0] += C[ 1] * p;
>>> ?? cp[1]? = C[ 6] * p;
>>>
>>> ?? p *= n;
>>> ?? cp[0] += C[ 2] * p;
>>> ?? cp[1] += C[ 7] * p;
>>> ?? cp[2]? = C[11] * p;
>>>
>>> ?? p *= n;
>>> ?? cp[0] += C[ 3] * p;
>>> ?? cp[1] += C[ 8] * p;
>>> ?? cp[2] += C[12] * p;
>>> ?? cp[3]? = C[15] * p;
>>>
>>> ?? p *= n;
>>> ?? cp[0] += C[ 4] * p;
>>> ?? cp[1] += C[ 9] * p;
>>> ?? cp[2] += C[13] * p;
>>> ?? cp[3] += C[16] * p;
>>> ?? cp[4]? = C[18] * p;
>>>
>>> ?? p *= n;
>>> ?? cp[0] += C[ 5] * p;
>>> ?? cp[1] += C[10] * p;
>>> ?? cp[2] += C[14] * p;
>>> ?? cp[3] += C[17] * p;
>>> ?? cp[4] += C[19] * p;
>>> ?? cp[5]? = C[20] * p;
>>> }
>>>
>>> double pj_authlat(double auth, const double * cp)
>>> {
>>> ?? // https://arxiv.org/pdf/2212.05818
>>> ?? // ??(?) = S^(L)(?) ? C?? ? P^(M) (n) + O(n^L+1)??? -- (20)
>>> ?? double a2x = auth + auth, a4x = a2x + a2x, a8x = a4x + a4x;
>>> ?? return auth +
>>> ????? cp[0] * sin(a2x) +
>>> ????? cp[1] * sin(a4x) +
>>> ????? cp[2] * sin(a4x + a2x) +
>>> ????? cp[3] * sin(a8x) +
>>> ????? cp[4] * sin(a8x + a2x) +
>>> ????? cp[5] * sin(a8x + a4x);
>>> }
>>
>> _______________________________________________
>> PROJ mailing list
>> PROJ at lists.osgeo.org
>> https://lists.osgeo.org/mailman/listinfo/proj

-- 
http://www.spatialys.com
My software is free, but my time generally not.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240911/5b51c0dc/attachment.htm>

From jerome at ecere.com  Wed Sep 11 01:47:18 2024
From: jerome at ecere.com (=?UTF-8?B?SsOpcsO0bWUgU3QtTG91aXM=?=)
Date: Wed, 11 Sep 2024 04:47:18 -0400
Subject: [PROJ] Geodetic to Authalic latitude conversions
In-Reply-To: <ac408a8f-9044-40ad-bdbc-debd10e162f6@spatialys.com>
References: <9ed4372a-f6a3-4420-b32b-232c3c4638b0@ecere.com>
 <450be707-b926-4e03-9025-f1b66badcd64@ecere.com>
 <ac408a8f-9044-40ad-bdbc-debd10e162f6@spatialys.com>
Message-ID: <2928b861-f54f-42ed-90f0-94ba7eff3ec6@ecere.com>

Thanks Even.

> I was wondering if we could not save trigonometric computations noting 
> that
>
> sin(a + b) = sin(a) * cos(b) + cos(a) * sin(b)
>
> and applying that recursively. At the end we would just to have to 
> compute sin(auth) and cos(auth). But I've no idea about the impact on 
> numerical stability of using this trigonometric trick.
>
That sounds brilliant. I will certainly investigate that!

> My other question would be the "backward" compatibility of this 
> change, like if we would need to provide a "+approx_auth_lat" flag to 
> replicate current results to use current formulas (like the +approx 
> flag of +proj=tmerc when more precise formulas were introduced). But 
> I've no specific opinion if it is needed here. It would be good to 
> have some examples using let's say WGS84 to see if we're talking about 
> differences in results of the order of meters, centimeters, 
> micrometers... ?
We should be able to get an idea of the order of magnitude from the 
powers of the third flattening which are multiplying the series terms:

n^1: 0.0016792203863837205
n^2: 0.0000028197811060
n^3: 0.0000000047350339
n^4: 0.0000000000079512

With my earlier comparison with the order 3 using the eccentricity 
squared used in PROJ vs this method, the PROJ method was accurate to 8 
decimals in decimal degrees at ~58 degrees (the greatest delta is around 
45 degrees).

I am guessing that improved accuracy for adding the 4th order is 
somewhere between millimeters and centimeters.
We will surely find out when we run the unit tests for those projections?

> It is also not immediately obvious to me to correlate your proposed 
> code with the formulas in the paper by just starring at both at the 
> same time. Looks like some "interpretation" of the paper has been done.
>
It's quite straightforward, but optimized for the precalculations like 
PROJ was doing in /auth.cpp/. There is no "interpretation" involved.
Here is my earlier more "direct" mapping of the paper (specifically 
Equation 20 on page 3 and matrix C?? A20 on page 13), with the loops 
still rolled up and no pre-computation, as a single function, which you 
might find easier to correlate with both the optimized version as well 
as to the summation function in equation 20 on page 3 (and the related 
equations 15-19 above on the same page):

> double latAuthalicToGeodetic(double auth)
> {
> ?? // https://arxiv.org/pdf/2212.05818
> ?? // ??(?) = S^(L)(?) ? C?? ? P^(M) (n) + O(n^L+1)??? -- (20)
> ?? static const double n = (wgs84Major - wgs84Minor) / (wgs84Major + 
> wgs84Minor);? // Third flattening
> ?? #define ORDER? 6
> ?? static const double C[21] = // (A20)
> ?? {
> ????? 4 / 3.0,? 4 / 45.0,?? -16/35.0,? -2582 /14175.0,? 60136 
> /467775.0,??? 28112932/ 212837625.0,
> ?????????????? 46 / 45.0,? 152/945.0, -11966 /14175.0, -21016 / 
> 51975.0,?? 251310128/ 638512875.0,
> ???????????????????????? 3044/2835.0,?? 3802 /14175.0, -94388 / 
> 66825.0,??? -8797648/? 10945935.0,
> ??????????????????????????????????????? 6059 / 4725.0,? 41072 / 
> 93555.0, -1472637812/ 638512875.0,
> ?????????????????????????????????????????????????????? 768272 
> /467775.0,? -455935736/ 638512875.0,
> 4210684958/1915538625.0
> ?? };
> ?? double r = 0;
> ?? int l, m, i = 0, j;
>
> ?? for(l = 1; l <= ORDER; l++)
> ?? {
> ????? double s = sin(2 * l * auth);
> ????? for(m = l; m <= ORDER; m++, i++)
> ????? {
> ???????? double c = C[i], p = n;
> ???????? for(j = 1; j < m; j++) p *= n;
> ???????? r += s * c * p;
> ????? }
> ?? }
> ?? return auth + r;
> } 

The nice thing about all this is that this really allows to convert 
between most of the auxiliary latitudes (in both directions).
So actually the proposed /pj_authlat() /I shared earlier could equally 
apply to parameteric or geocentric or conformal latitudes.
And the only change for the setup in /pj_authset()/ would be to use a 
different C matrix based on the type of latitudes involved.
So I would probably make the functions generic so that they could 
eventually be used for that purpose as well if needed, with an enum to 
pick the right conversion matrix.

I've also ran this through quite a few checks and verified that as a 
result, our ISEA3H and ISEA9R discrete global grid hierarchies are now 
*actually* equal area :)? (with the sole exception of the 12 pentagons 
each being 5/6th the area of the hexagons).

e.g. you can see 
https://maps.gnosis.earth/ogcapi/dggs/ISEA3H/zones?zone-level=5&compact-zones=false 
(or see it on the geojson.io 3D globe 
<http://geojson.io/#data=data:text/x-url,https://maps.gnosis.earth/ogcapi/dggs/ISEA3H/zones.geojson%3Fzone-level%3D5%26compact-zones%3DFalse>)

> I'm wondering if it wouldn't be possible to compare numeric results 
> with the implementation in AuxLatitude.cpp to have some confidence 
> (I've also tried to compare your formulas with the ones of that file 
> and can't directly correlate them) ?
That is certainly possible...

The order 6 C?? (C[phi,xi]) A20 matrix from page 13 is here in 
/AuxLatitude.cpp/ (but you need to read it from right-to-left compared 
to the rows in my version, which is organized as shown in the paper on 
page 13):

https://github.com/geographiclib/geographiclib/blob/main/src/AuxLatitude.cpp#L631

The code itself is a bit overwhelming, which is why I did not actually 
look at it much.
My version follows exactly the existing pattern of /pj_auth()/ in PROJ 
as well as the functions on page 3 of the paper, which I could 
understand much easier, so that should be easy to correlate.

The GeographicLib code may be doing some more fancy things to improve 
numerical stability. There might be a lot of C++ boilerplate with the 
options to convert to and from any type of auxiliary latitudes, and 
compiler options for order 4, 6 and 8.
There's also code in there I believe to iterate to the "exact" value 
without using the series, which may be useful either to figure out those 
coefficients, and/or for a huge flattening value.
I believe the summation is happening from here with /exact = false/:

https://github.com/geographiclib/geographiclib/blob/main/src/AuxLatitude.cpp#L312

which invokes /Clenshaw()/ here:

https://github.com/geographiclib/geographiclib/blob/main/src/AuxLatitude.cpp#L1319

It is of course still possible that I made a mistake with all this, but 
I imagine that updating this and running the tests should help to be 
confident about the results.

> No, we don't use the C++ GeographicLib, just the C port of it from 
> https://github.com/geographiclib/geographiclib-c/tree/main/src
>
Right, I believe that version predates that whole AuxLatitude module 
(the paper is from 2023 and it was first added to GeographicLib 2.2 I 
believe).

Thank you!

Kind regards,

-Jerome

On 9/11/24 3:27 AM, Even Rouault wrote:
>
> Hi J?r?me,
>
> I was wondering if we could not save trigonometric computations noting 
> that
>
> sin(a + b) = sin(a) * cos(b) + cos(a) * sin(b)
>
> and applying that recursively. At the end we would just to have to 
> compute sin(auth) and cos(auth). But I've no idea about the impact on 
> numerical stability of using this trigonometric trick.
>
> My other question would be the "backward" compatibility of this 
> change, like if we would need to provide a "+approx_auth_lat" flag to 
> replicate current results to use current formulas (like the +approx 
> flag of +proj=tmerc when more precise formulas were introduced). But 
> I've no specific opinion if it is needed here. It would be good to 
> have some examples using let's say WGS84 to see if we're talking about 
> differences in results of the order of meters, centimeters, 
> micrometers... ?
>
> It is also not immediately obvious to me to correlate your proposed 
> code with the formulas in the paper by just starring at both at the 
> same time. Looks like some "interpretation" of the paper has been 
> done. It might be straightforward for someone who is familiar with the 
> topic enough, but an error could also be easy to make when 
> transcribing in code. I'm wondering if it wouldn't be possible to 
> compare numeric results with the implementation in AuxLatitude.cpp to 
> have some confidence (I've also tried to compare your formulas with 
> the ones of that file and can't directly correlate them) ?
>
> Besides those remarks, your proposal generally looks good to my 
> non-expert eyes on the topic of authalic latitudes :-)
>
> No, we don't use the C++ GeographicLib, just the C port of it from 
> https://github.com/geographiclib/geographiclib-c/tree/main/src
>
> Even
>
> Le 11/09/2024 ? 03:36, J?r?me St-Louis a ?crit?:
>>
>> Sorry I should correct a few confusing mistakes in my previous e-mail:
>>
>> ??? - I was talking mainly about authalic latitude ==> geodetic 
>> latitude conversion, not the other way around.
>> /pj_authlat()/ returns the geodetic latitude for a given authalic 
>> latitude (the name of the function is quite confusing -- I would 
>> propose to rename to something less ambiguous if it is only used 
>> internally)
>>
>> ??? - The function currently uses 3 /sin()/ calls for order 3 (not 2, 
>> made a typo)
>>
>> ??? - The ISEA projection does not currently make use of 
>> /pj_authlat()/ or /pj_qsfn() /for automatically converting authalic / 
>> geodetic latitudes, but I am proposing to introduce this when using 
>> non-spherical ellipsoid (just like LAEA of which it is a modified form).
>>
>> Best,
>>
>> -Jerome
>>
>> On 9/10/24 9:19 PM, J?r?me St-Louis via PROJ wrote:
>>>
>>> Hi Even, all,
>>>
>>> As suggested in https://github.com/OSGeo/PROJ/pull/4211 , I've just 
>>> written an implementation of the authalic / geodetic latitude 
>>> conversion with the goal to automatically perform this conversion 
>>> when using ISEA with an non-spherical ellipsoid, and was wondering 
>>> whether we would want to improve the PROJ version (/pj_authlat()/ 
>>> for the geodetic ==> authalic), which is used for ISEA, but also by:
>>>
>>> - Equal Area Cylindrical (cea.cpp)
>>> - EqualEarth (eqearth.cpp)
>>> - HEALPix (healpix.cpp) -- which might also imply rHEALPix
>>> - Lambert Azimuthal Equal Area (laea.cpp)
>>>
>>> The current version of /pj_authlat()/ uses a series expansion based 
>>> on the eccentricity squared (I believe this is based on a Lagrange 
>>> reversion <https://en.wikipedia.org/wiki/Lagrange_inversion_theorem> 
>>> as mentioned here 
>>> <https://en.wikipedia.org/wiki/Latitude#Inverse_formulae_and_series>), 
>>> and Charles Karney in this paper <https://arxiv.org/pdf/2212.05818> 
>>> establishes that:
>>>
>>>> /series expansions using the third flattening as the small 
>>>> parameter uniformly result in smaller truncation errors compared to 
>>>> using the eccentricity./
>>> The current version also only uses order 3, whereas GeographicLib 
>>> would normally use order 6 for double precision, with order 4 being 
>>> the minimum configuration.
>>> The current order 3, which requires 2 /sin()/ calls, gives precision 
>>> up to roughly 8 decimals.
>>> Order 6 would mean twice the number of /sin()/ calls, and the 8 
>>> decimals should be enough to point to Waldo on a page 
>>> <https://xkcd.com/2170/>, however C.K. argues that:
>>>
>>>> /Modern geodetic libraries should strive to achieve full 
>>>> double-precision accuracy /(page 4)/
>>>> /
>>>
>>> and I would much agree with that.
>>>
>>> Based on the direction we want to go, I would submit a PR including 
>>> adjustments to avoid the separate heap allocation for the doubles 
>>> (as discussed here 
>>> <https://github.com/OSGeo/PROJ/pull/4211#pullrequestreview-2233903246>), 
>>> and adjustments for tests etc.
>>>
>>> PROJ currently does not use the full GeographicLib which already 
>>> includes code for conversion between different auxiliary latitudes, 
>>> does it?
>>>
>>> ??? ( 
>>> https://github.com/geographiclib/geographiclib/blob/main/src/AuxLatitude.cpp 
>>> )
>>>
>>> See my proposed new version below, which I wrote based on equation 
>>> 20 on page 3, and matrix A20 on page 13 from the paper, applying 
>>> optimizations similar to the current /pj_authlat()/.
>>>
>>> Kind regards,
>>>
>>> -Jerome
>>>
>>>> void pj_authset(double a, double b, double cp[6])
>>>> {
>>>> ?? // https://arxiv.org/pdf/2212.05818
>>>> ?? // ??(?) = S^(L)(?) ? C?? ? P^(M) (n) + O(n^L+1)??? -- (20)
>>>> ?? double n = (a - b) / (a + b);? // Third flattening
>>>> ?? static const double C[21] = // (A20)
>>>> ?? {
>>>> ????? 4 / 3.0,? 4 / 45.0,?? -16/35.0,? -2582 /14175.0, 60136 
>>>> /467775.0,??? 28112932/ 212837625.0,
>>>> ?????????????? 46 / 45.0,? 152/945.0, -11966 /14175.0, -21016 / 
>>>> 51975.0,?? 251310128/ 638512875.0,
>>>> ???????????????????????? 3044/2835.0,?? 3802 /14175.0, -94388 / 
>>>> 66825.0,??? -8797648/? 10945935.0,
>>>> ??????????????????????????????????????? 6059 / 4725.0, 41072 / 
>>>> 93555.0, -1472637812/ 638512875.0,
>>>> 768272 /467775.0,? -455935736/ 638512875.0,
>>>> 4210684958/1915538625.0
>>>> ?? };
>>>> ?? double p;
>>>>
>>>> ?? cp[0]? = C[ 0] * n;
>>>>
>>>> ?? p = n * n;
>>>> ?? cp[0] += C[ 1] * p;
>>>> ?? cp[1]? = C[ 6] * p;
>>>>
>>>> ?? p *= n;
>>>> ?? cp[0] += C[ 2] * p;
>>>> ?? cp[1] += C[ 7] * p;
>>>> ?? cp[2]? = C[11] * p;
>>>>
>>>> ?? p *= n;
>>>> ?? cp[0] += C[ 3] * p;
>>>> ?? cp[1] += C[ 8] * p;
>>>> ?? cp[2] += C[12] * p;
>>>> ?? cp[3]? = C[15] * p;
>>>>
>>>> ?? p *= n;
>>>> ?? cp[0] += C[ 4] * p;
>>>> ?? cp[1] += C[ 9] * p;
>>>> ?? cp[2] += C[13] * p;
>>>> ?? cp[3] += C[16] * p;
>>>> ?? cp[4]? = C[18] * p;
>>>>
>>>> ?? p *= n;
>>>> ?? cp[0] += C[ 5] * p;
>>>> ?? cp[1] += C[10] * p;
>>>> ?? cp[2] += C[14] * p;
>>>> ?? cp[3] += C[17] * p;
>>>> ?? cp[4] += C[19] * p;
>>>> ?? cp[5]? = C[20] * p;
>>>> }
>>>>
>>>> double pj_authlat(double auth, const double * cp)
>>>> {
>>>> ?? // https://arxiv.org/pdf/2212.05818
>>>> ?? // ??(?) = S^(L)(?) ? C?? ? P^(M) (n) + O(n^L+1)??? -- (20)
>>>> ?? double a2x = auth + auth, a4x = a2x + a2x, a8x = a4x + a4x;
>>>> ?? return auth +
>>>> ????? cp[0] * sin(a2x) +
>>>> ????? cp[1] * sin(a4x) +
>>>> ????? cp[2] * sin(a4x + a2x) +
>>>> ????? cp[3] * sin(a8x) +
>>>> ????? cp[4] * sin(a8x + a2x) +
>>>> ????? cp[5] * sin(a8x + a4x);
>>>> }
>>>
>>> _______________________________________________
>>> PROJ mailing list
>>> PROJ at lists.osgeo.org
>>> https://lists.osgeo.org/mailman/listinfo/proj
> -- 
> http://www.spatialys.com
> My software is free, but my time generally not.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240911/d1258f14/attachment-0001.htm>

From even.rouault at spatialys.com  Wed Sep 11 02:30:03 2024
From: even.rouault at spatialys.com (Even Rouault)
Date: Wed, 11 Sep 2024 11:30:03 +0200
Subject: [PROJ] Geodetic to Authalic latitude conversions
In-Reply-To: <2928b861-f54f-42ed-90f0-94ba7eff3ec6@ecere.com>
References: <9ed4372a-f6a3-4420-b32b-232c3c4638b0@ecere.com>
 <450be707-b926-4e03-9025-f1b66badcd64@ecere.com>
 <ac408a8f-9044-40ad-bdbc-debd10e162f6@spatialys.com>
 <2928b861-f54f-42ed-90f0-94ba7eff3ec6@ecere.com>
Message-ID: <af32ee83-de40-4683-af38-b8a61db0bcca@spatialys.com>


> We will surely find out when we run the unit tests for those projections?

Not sure which tolerance they have and how much those projections are 
tested (do not forget that much of the regression test suite was 
automatically generated with the results PROJ produced at that time, so 
with quite generic tolerances, etc.). I was more thinking about manually 
testing with proj/cct binaries before and after, and see the differences

>
>> It is also not immediately obvious to me to correlate your proposed 
>> code with the formulas in the paper by just starring at both at the 
>> same time. Looks like some "interpretation" of the paper has been done.
>>
> It's quite straightforward, but optimized for the precalculations like 
> PROJ was doing in /auth.cpp/. There is no "interpretation" involved.
Well, what you mention below is what I call "interpretation", that is 
not direct copying of ready-made formulas, where someone unqualified 
could trivially check if there's no typo ;-)
>
>
> It is of course still possible that I made a mistake with all this, 
> but I imagine that updating this and running the tests should help to 
> be confident about the results.

Running the existing PROJ test suite will show if the new formulas are 
consistent with the current less precise ones with maybe a quite loose 
tolerance, not necessarily that we reach the new level of precision we 
claim. Hence comparing with some random test points against 
GeographicLib which can hopefully be considered as a reference 
implementation, to check we have identical results (or at least share 
more common decimals up to the desired precision)


-- 
http://www.spatialys.com
My software is free, but my time generally not.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240911/361e1360/attachment.htm>

From charles.karney at gmail.com  Wed Sep 11 05:02:15 2024
From: charles.karney at gmail.com (Charles Karney)
Date: Wed, 11 Sep 2024 08:02:15 -0400
Subject: [PROJ] Geodetic to Authalic latitude conversions
In-Reply-To: <9ed4372a-f6a3-4420-b32b-232c3c4638b0@ecere.com>
References: <9ed4372a-f6a3-4420-b32b-232c3c4638b0@ecere.com>
Message-ID: <CAH36mb9R5k5xTzRfxsdUuzBrxcn7o6yovEWUd+kLDgKmT1NPkw@mail.gmail.com>

Surely you should use Horner to compute the polynomials.  This gives you
tighter code, lets you vary the order of the polynomial and is more
accurate (small terms accumulated first).

Likewise, use Clenshaw for the trig sum.  All the same advantages accrue
+ it only needs one or two evaluations of trig functions.

My arxiv paper has been published in Survey Review

  https://doi.org/10.1080/00396265.2023.2217604

However, retain the arxiv link since the journal article is behind a
paywall.

On Tue, Sep 10, 2024 at 9:19?PM J?r?me St-Louis via PROJ
<proj at lists.osgeo.org> wrote:
>
> Hi Even, all,
>
> As suggested in https://github.com/OSGeo/PROJ/pull/4211 , I've just written an implementation of the authalic / geodetic latitude conversion with the goal to automatically perform this conversion when using ISEA with an non-spherical ellipsoid, and was wondering whether we would want to improve the PROJ version (pj_authlat() for the geodetic ==> authalic), which is used for ISEA, but also by:
>
> - Equal Area Cylindrical (cea.cpp)
> - EqualEarth (eqearth.cpp)
> - HEALPix (healpix.cpp) -- which might also imply rHEALPix
> - Lambert Azimuthal Equal Area (laea.cpp)
>
> The current version of pj_authlat() uses a series expansion based on the eccentricity squared (I believe this is based on a Lagrange reversion as mentioned here), and Charles Karney in this paper establishes that:
>
> series expansions using the third flattening as the small parameter uniformly result in smaller truncation errors compared to using the eccentricity.
>
> The current version also only uses order 3, whereas GeographicLib would normally use order 6 for double precision, with order 4 being the minimum configuration.
> The current order 3, which requires 2 sin() calls, gives precision up to roughly 8 decimals.
> Order 6 would mean twice the number of sin() calls, and the 8 decimals should be enough to point to Waldo on a page, however C.K. argues that:
>
> Modern geodetic libraries should strive to achieve full double-precision accuracy (page 4)
>
> and I would much agree with that.
>
> Based on the direction we want to go, I would submit a PR including adjustments to avoid the separate heap allocation for the doubles (as discussed here), and adjustments for tests etc.
>
> PROJ currently does not use the full GeographicLib which already includes code for conversion between different auxiliary latitudes, does it?
>
>     ( https://github.com/geographiclib/geographiclib/blob/main/src/AuxLatitude.cpp )
>
> See my proposed new version below, which I wrote based on equation 20 on page 3, and matrix A20 on page 13 from the paper, applying optimizations similar to the current pj_authlat().
>
> Kind regards,
>
> -Jerome
>
> void pj_authset(double a, double b, double cp[6])
> {
>    // https://arxiv.org/pdf/2212.05818
>    // ??(?) = S^(L)(?) ? C?? ? P^(M) (n) + O(n^L+1)    -- (20)
>    double n = (a - b) / (a + b);  // Third flattening
>    static const double C[21] = // (A20)
>    {
>       4 / 3.0,  4 / 45.0,   -16/35.0,  -2582 /14175.0,  60136 /467775.0,    28112932/ 212837625.0,
>                46 / 45.0,  152/945.0, -11966 /14175.0, -21016 / 51975.0,   251310128/ 638512875.0,
>                          3044/2835.0,   3802 /14175.0, -94388 / 66825.0,    -8797648/  10945935.0,
>                                         6059 / 4725.0,  41072 / 93555.0, -1472637812/ 638512875.0,
>                                                        768272 /467775.0,  -455935736/ 638512875.0,
>                                                                           4210684958/1915538625.0
>    };
>    double p;
>
>    cp[0]  = C[ 0] * n;
>
>    p = n * n;
>    cp[0] += C[ 1] * p;
>    cp[1]  = C[ 6] * p;
>
>    p *= n;
>    cp[0] += C[ 2] * p;
>    cp[1] += C[ 7] * p;
>    cp[2]  = C[11] * p;
>
>    p *= n;
>    cp[0] += C[ 3] * p;
>    cp[1] += C[ 8] * p;
>    cp[2] += C[12] * p;
>    cp[3]  = C[15] * p;
>
>    p *= n;
>    cp[0] += C[ 4] * p;
>    cp[1] += C[ 9] * p;
>    cp[2] += C[13] * p;
>    cp[3] += C[16] * p;
>    cp[4]  = C[18] * p;
>
>    p *= n;
>    cp[0] += C[ 5] * p;
>    cp[1] += C[10] * p;
>    cp[2] += C[14] * p;
>    cp[3] += C[17] * p;
>    cp[4] += C[19] * p;
>    cp[5]  = C[20] * p;
> }
>
> double pj_authlat(double auth, const double * cp)
> {
>    // https://arxiv.org/pdf/2212.05818
>    // ??(?) = S^(L)(?) ? C?? ? P^(M) (n) + O(n^L+1)    -- (20)
>    double a2x = auth + auth, a4x = a2x + a2x, a8x = a4x + a4x;
>    return auth +
>       cp[0] * sin(a2x) +
>       cp[1] * sin(a4x) +
>       cp[2] * sin(a4x + a2x) +
>       cp[3] * sin(a8x) +
>       cp[4] * sin(a8x + a2x) +
>       cp[5] * sin(a8x + a4x);
> }
>
> _______________________________________________
> PROJ mailing list
> PROJ at lists.osgeo.org
> https://lists.osgeo.org/mailman/listinfo/proj



-- 
Charles Karney <karney at alum.mit.edu>
702 Prospect Ave
Princeton, NJ 08540

From knudsen.thomas at gmail.com  Wed Sep 11 09:18:21 2024
From: knudsen.thomas at gmail.com (Thomas Knudsen)
Date: Wed, 11 Sep 2024 18:18:21 +0200
Subject: [PROJ] Geodetic to Authalic latitude conversions
In-Reply-To: <CAH36mb9R5k5xTzRfxsdUuzBrxcn7o6yovEWUd+kLDgKmT1NPkw@mail.gmail.com>
References: <9ed4372a-f6a3-4420-b32b-232c3c4638b0@ecere.com>
 <CAH36mb9R5k5xTzRfxsdUuzBrxcn7o6yovEWUd+kLDgKmT1NPkw@mail.gmail.com>
Message-ID: <CAH0YoEMiYpNxR1LNYFxh9BqjM=NWWaiJKFZV_2yoe+kb__uy2g@mail.gmail.com>

I totally agree with Charles regarding using Horner for polynomial
evaluation and Clenshaw for the trig series - for accuracy and speed.

I implemented all the material from Charles' preprint
https://arxiv.org/pdf/2212.05818 for Rust Geodesy, when the preprint
appeared about 1? years ago.

And although (being an experiment) my handling of the raw coefficients
is rather clumsy, at least it gave me a reason to revise my PROJ horner
and clenshaw implementations (which in turn were based on material from
Poder & Engsager: "Some Conformal Mappings...").

So J?r?me, perhaps take a look at the functions "taylor" and "fourier"
over at https://github.com/busstoptaktik/geodesy/blob/main/src/math/series.rs

While written in Rust, translating to C++ should be rather trivial,
and they may be easier to follow than my decade-old versions already
in the PROJ code base.

From even.rouault at spatialys.com  Wed Sep 11 11:14:18 2024
From: even.rouault at spatialys.com (Even Rouault)
Date: Wed, 11 Sep 2024 20:14:18 +0200
Subject: [PROJ] Geodetic to Authalic latitude conversions
In-Reply-To: <af32ee83-de40-4683-af38-b8a61db0bcca@spatialys.com>
References: <9ed4372a-f6a3-4420-b32b-232c3c4638b0@ecere.com>
 <450be707-b926-4e03-9025-f1b66badcd64@ecere.com>
 <ac408a8f-9044-40ad-bdbc-debd10e162f6@spatialys.com>
 <2928b861-f54f-42ed-90f0-94ba7eff3ec6@ecere.com>
 <af32ee83-de40-4683-af38-b8a61db0bcca@spatialys.com>
Message-ID: <2504ca83-0056-4c7d-82fa-68bcc26d9d36@spatialys.com>

It would also be interested to check how this affects our compliance 
with the GIGS test suite (https://gigs.iogp.org/)

For example the tests for LAEA are at 
https://github.com/IOGP-GIGS/GIGSTestDataset/blob/main/GIGSTestDatasetFiles/GIGS%205100%20Conversion%20test%20data/ASCII/GIGS_conv_5110_LAEA_output.txt

Currently we perfectly reproduce the expected results of GIGS at the 
millimeter level, although the test suite asks only for a 0.05 m tolerance

$ echo 70 5 | bin/cs2cs -d 3 EPSG:4258 EPSG:3035
5214090.649??? 4127824.658 0.000
$ echo 60 5 | bin/cs2cs -d 3 EPSG:4258 EPSG:3035
4109791.660??? 4041548.125 0.000
$ echo 50 5 | bin/cs2cs -d 3 EPSG:4258 EPSG:3035
2999718.853??? 3962799.451 0.000
$ echo 40 5 | bin/cs2cs -d 3 EPSG:4258 EPSG:3035
1892578.962??? 3892127.020 0.000
$ echo 30 5 | bin/cs2cs -d 3 EPSG:4258 EPSG:3035
796781.677??? 3830117.902 0.000
$ echo 52 10 | bin/cs2cs -d 3 EPSG:4258 EPSG:3035
3210000.000??? 4321000.000 0.000
$ echo 50 0 | bin/cs2cs -d 3 EPSG:4258 EPSG:3035
3036305.967??? 3606514.431 0.000
$ echo 50 3 | bin/cs2cs -d 3 EPSG:4258 EPSG:3035
3011432.894??? 3819948.288 0.000

The formulas for LAEA in the EPSG guidance node 7-2 use the 3-term 
series based on square eccentricy, which is the current one of PROJ

That said, when runnings the corresponding test file converted to be 
used by PROJ's "gie" test, we do pass the simple one-time forward / 
reverse tests, but not repeated 1000 times where a 6mm drift is 
tolerated and we are currently at ~300 to ~1300 millimeters. Perhaps 
using those more precise formulas will help improve the repeated 
round-tripping.

Cf https://github.com/OSGeo/PROJ/pull/4247 for the details (as the tests 
don't pass, the test file is not run by the automated test suite, so it 
must be run manually as shown in the PR).

Even

Le 11/09/2024 ? 11:30, Even Rouault via PROJ a ?crit?:
>
>> We will surely find out when we run the unit tests for those projections?
>
> Not sure which tolerance they have and how much those projections are 
> tested (do not forget that much of the regression test suite was 
> automatically generated with the results PROJ produced at that time, 
> so with quite generic tolerances, etc.). I was more thinking about 
> manually testing with proj/cct binaries before and after, and see the 
> differences
>
>>
>>> It is also not immediately obvious to me to correlate your proposed 
>>> code with the formulas in the paper by just starring at both at the 
>>> same time. Looks like some "interpretation" of the paper has been done.
>>>
>> It's quite straightforward, but optimized for the precalculations 
>> like PROJ was doing in /auth.cpp/. There is no "interpretation" involved.
> Well, what you mention below is what I call "interpretation", that is 
> not direct copying of ready-made formulas, where someone unqualified 
> could trivially check if there's no typo ;-)
>>
>>
>> It is of course still possible that I made a mistake with all this, 
>> but I imagine that updating this and running the tests should help to 
>> be confident about the results.
>
> Running the existing PROJ test suite will show if the new formulas are 
> consistent with the current less precise ones with maybe a quite loose 
> tolerance, not necessarily that we reach the new level of precision we 
> claim. Hence comparing with some random test points against 
> GeographicLib which can hopefully be considered as a reference 
> implementation, to check we have identical results (or at least share 
> more common decimals up to the desired precision)
>
>
> -- 
> http://www.spatialys.com
> My software is free, but my time generally not.
>
> _______________________________________________
> PROJ mailing list
> PROJ at lists.osgeo.org
> https://lists.osgeo.org/mailman/listinfo/proj

-- 
http://www.spatialys.com
My software is free, but my time generally not.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240911/ad3570cd/attachment-0001.htm>

From jerome at ecere.com  Wed Sep 11 12:33:34 2024
From: jerome at ecere.com (=?UTF-8?B?SsOpcsO0bWUgU3QtTG91aXM=?=)
Date: Wed, 11 Sep 2024 15:33:34 -0400
Subject: [PROJ] Geodetic to Authalic latitude conversions
In-Reply-To: <CAH0YoEMiYpNxR1LNYFxh9BqjM=NWWaiJKFZV_2yoe+kb__uy2g@mail.gmail.com>
References: <9ed4372a-f6a3-4420-b32b-232c3c4638b0@ecere.com>
 <CAH36mb9R5k5xTzRfxsdUuzBrxcn7o6yovEWUd+kLDgKmT1NPkw@mail.gmail.com>
 <CAH0YoEMiYpNxR1LNYFxh9BqjM=NWWaiJKFZV_2yoe+kb__uy2g@mail.gmail.com>
Message-ID: <9ab1b1a7-caae-43cc-97a5-ab5ddade3f26@ecere.com>

Thanks a lot for the input Charles and Thomas,

I am not familiar with either Horner 
<https://en.wikipedia.org/wiki/Horner%27s_method> or Clenshaw 
<https://en.wikipedia.org/wiki/Clenshaw_algorithm>, but I do see the 
mentions now on /Section 6 - Evaluating the series/ pages 6 and 7 of the 
papers.
I implemented the simpler basic approach from section 3 / page 3, which 
also happened to more easily correspond to the existing PROJ implementation.

I can definitely try to understand all this, with the help of this Rust 
Geodesy code and the GeographicLib code, and have a go at updating my 
proposed implementation for improved accuracy and performance.

Kind regards,

-Jerome

On 9/11/24 12:18 PM, Thomas Knudsen wrote:
> I totally agree with Charles regarding using Horner for polynomial
> evaluation and Clenshaw for the trig series - for accuracy and speed.
>
> I implemented all the material from Charles' preprint
> https://arxiv.org/pdf/2212.05818  for Rust Geodesy, when the preprint
> appeared about 1? years ago.
>
> And although (being an experiment) my handling of the raw coefficients
> is rather clumsy, at least it gave me a reason to revise my PROJ horner
> and clenshaw implementations (which in turn were based on material from
> Poder & Engsager: "Some Conformal Mappings...").
>
> So J?r?me, perhaps take a look at the functions "taylor" and "fourier"
> over athttps://github.com/busstoptaktik/geodesy/blob/main/src/math/series.rs
>
> While written in Rust, translating to C++ should be rather trivial,
> and they may be easier to follow than my decade-old versions already
> in the PROJ code base.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240911/bc772cc5/attachment.htm>

From jerome at ecere.com  Wed Sep 11 13:21:29 2024
From: jerome at ecere.com (=?UTF-8?B?SsOpcsO0bWUgU3QtTG91aXM=?=)
Date: Wed, 11 Sep 2024 16:21:29 -0400
Subject: [PROJ] Geodetic to Authalic latitude conversions
In-Reply-To: <9ab1b1a7-caae-43cc-97a5-ab5ddade3f26@ecere.com>
References: <9ed4372a-f6a3-4420-b32b-232c3c4638b0@ecere.com>
 <CAH36mb9R5k5xTzRfxsdUuzBrxcn7o6yovEWUd+kLDgKmT1NPkw@mail.gmail.com>
 <CAH0YoEMiYpNxR1LNYFxh9BqjM=NWWaiJKFZV_2yoe+kb__uy2g@mail.gmail.com>
 <9ab1b1a7-caae-43cc-97a5-ab5ddade3f26@ecere.com>
Message-ID: <859880f2-fba6-4e46-a615-ce8c2ac0cccf@ecere.com>

So it seems like we already have an implementation of Horner and 
Clenshaw in:

https://github.com/OSGeo/PROJ/blob/master/src/mlfn.cpp

called /polyval()/ and /clenshaw()/ just like in GeographicLib ( 
polyval() 
<https://github.com/geographiclib/geographiclib/blob/main/include/GeographicLib/Math.hpp#L280> 
, Clenshaw() 
<https://github.com/geographiclib/geographiclib/blob/main/src/AuxLatitude.cpp#L1319>).

It seems like Charles wrote or at least updated that :)

That is using the C?? (C[mu phi]) (A5) and C?? (C[phi mu]) (A6) from 
page? 12 of the paper, where?? is called the "rectifying latitude".
I imagine that this is directly related to the "meridional distance" ?

Perhaps we could re-organize this a bit to share this /polyval()/ and 
/clenshaw()/ (they are currently static functions local to this 
/mlfn.cpp/) for use in /auth.cpp/ ?

Thanks!

Kind regards,

-Jerome

On 9/11/24 3:33 PM, J?r?me St-Louis wrote:
>
> Thanks a lot for the input Charles and Thomas,
>
> I am not familiar with either Horner 
> <https://en.wikipedia.org/wiki/Horner%27s_method> or Clenshaw 
> <https://en.wikipedia.org/wiki/Clenshaw_algorithm>, but I do see the 
> mentions now on /Section 6 - Evaluating the series/ pages 6 and 7 of 
> the papers.
> I implemented the simpler basic approach from section 3 / page 3, 
> which also happened to more easily correspond to the existing PROJ 
> implementation.
>
> I can definitely try to understand all this, with the help of this 
> Rust Geodesy code and the GeographicLib code, and have a go at 
> updating my proposed implementation for improved accuracy and performance.
>
> Kind regards,
>
> -Jerome
>
> On 9/11/24 12:18 PM, Thomas Knudsen wrote:
>> I totally agree with Charles regarding using Horner for polynomial
>> evaluation and Clenshaw for the trig series - for accuracy and speed.
>>
>> I implemented all the material from Charles' preprint
>> https://arxiv.org/pdf/2212.05818  for Rust Geodesy, when the preprint
>> appeared about 1? years ago.
>>
>> And although (being an experiment) my handling of the raw coefficients
>> is rather clumsy, at least it gave me a reason to revise my PROJ horner
>> and clenshaw implementations (which in turn were based on material from
>> Poder & Engsager: "Some Conformal Mappings...").
>>
>> So J?r?me, perhaps take a look at the functions "taylor" and "fourier"
>> over athttps://github.com/busstoptaktik/geodesy/blob/main/src/math/series.rs
>>
>> While written in Rust, translating to C++ should be rather trivial,
>> and they may be easier to follow than my decade-old versions already
>> in the PROJ code base.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240911/e830c20c/attachment.htm>

From jerome at ecere.com  Wed Sep 11 19:45:41 2024
From: jerome at ecere.com (=?UTF-8?B?SsOpcsO0bWUgU3QtTG91aXM=?=)
Date: Wed, 11 Sep 2024 22:45:41 -0400
Subject: [PROJ] Geodetic to Authalic latitude conversions
In-Reply-To: <859880f2-fba6-4e46-a615-ce8c2ac0cccf@ecere.com>
References: <9ed4372a-f6a3-4420-b32b-232c3c4638b0@ecere.com>
 <CAH36mb9R5k5xTzRfxsdUuzBrxcn7o6yovEWUd+kLDgKmT1NPkw@mail.gmail.com>
 <CAH0YoEMiYpNxR1LNYFxh9BqjM=NWWaiJKFZV_2yoe+kb__uy2g@mail.gmail.com>
 <9ab1b1a7-caae-43cc-97a5-ab5ddade3f26@ecere.com>
 <859880f2-fba6-4e46-a615-ce8c2ac0cccf@ecere.com>
Message-ID: <6066c4db-70b3-4306-a763-ab7c457847b4@ecere.com>

Dear Even, Charles, Thomas, All,

Please find below a couple revised implementations of the authalic ==> 
geodetic conversion using Horner's method and Clenshaw summation 
algorithm, both sharing this table of coefficients from A20:

> #define AUTH_ORDER 6
>
> static const double Cphimu[21] = // C?? (A20) - coefficients to 
> convert authalic latitude to geodetic latitude
> {
> ?? 4 / 3.0,? 4 / 45.0,?? -16/35.0,? -2582 /14175.0,? 60136 
> /467775.0,??? 28112932/ 212837625.0,
> ??????????? 46 / 45.0,? 152/945.0, -11966 /14175.0, -21016 / 
> 51975.0,?? 251310128/ 638512875.0,
> ????????????????????? 3044/2835.0,?? 3802 /14175.0, -94388 / 
> 66825.0,??? -8797648/? 10945935.0,
> ???????????????????????????????????? 6059 / 4725.0,? 41072 / 93555.0, 
> -1472637812/ 638512875.0,
> ??????????????????????????????????????????????????? 768272 /467775.0,? 
> -455935736/ 638512875.0,
> 4210684958/1915538625.0
> };

This first one is using the existing functions from /mlfn.cpp/ 
(untouched other than possibly different formatting here):

> // Evaluate sum(p[i] * x^i, i, 0, N) via Horner's method (p is of 
> length N+1)
> static inline double polyval(double x, const double p[], int N)
> {
> ?? double y = N < 0 ? 0 : p[N];
> ?? while(N > 0)
> ????? y = y * x + p[--N];
> ?? return y;
> }
>
> // Evaluate y = sum(c[k] * sin((2*k+2) * zeta), k, 0, K-1)
> static inline double clenshaw(double szeta, double czeta, const double 
> c[], int K)
> {
> ?? // Approx operation count = (K + 5) mult and (2 * K + 2) add
> ?? double u0 = 0, u1 = 0; // accumulators for sum
> ?? double X = 2 * (czeta - szeta) * (czeta + szeta); // 2 * cos(2*zeta)
> ?? while(K > 0)
> ?? {
> ????? double t = X * u0 - u1 + c[--K];
> ????? u1 = u0;
> ????? u0 = t;
> ?? }
> ?? return 2 * szeta * czeta * u0; // sin(2*zeta) * u0
> }
>
> // https://arxiv.org/pdf/2212.05818
> // ??(?) = S^(L)(?) ? C?? ? P^(M) (n) + O(n^L+1)??? -- (20)
> void pj_authset(double a, double b, double cp[AUTH_ORDER])
> {
> ?? double n = (a - b) / (a + b);? // Third flattening
> ?? double d = n;
> ?? int l, o;
>
> ?? for(l = 0, o = 0; l < AUTH_ORDER; l++)
> ?? {
> ????? int m = AUTH_ORDER - l - 1;
>
> ????? cp[l] = d * polyval(n, Cphimu + o, m);
> ????? d *= n;
> ????? o += m + 1;
> ?? }
> }
>
> double pj_auth2geodlat(const double * cp, double phi)
> {
> ?? return phi + clenshaw(sin(phi), cos(phi), cp, AUTH_ORDER);
> }

For this second implementation, I unrolled the loops to get rid of the 
iterations (and associated counter incrementations) and conditionals, 
which if the compiler is not optimizing out, could potentially introduce 
some branching costs 
<https://en.algorithmica.org/hpc/pipelining/branching/>.
This unrolled version remains quite compact (at least in this particular 
formatting which the pre-commit hook will certainly massacre). The 
sequence of operations is exactly the same, and I've tested that the two 
are equivalent, and also equivalent with the two earlier implementations 
that I shared which were not using Horner and Clenshaw, and also 
equivalent to 8 decimals to the existing /pj_authlat()/ function in PROJ.

> // https://arxiv.org/pdf/2212.05818
> // ??(?) = S^(L)(?) ? C?? ? P^(M) (n) + O(n^L+1)??? -- (20)
> void pj_authset(double a, double b, double cp[AUTH_ORDER])
> {
> ?? // Precomputing coefficient based on Horner's method
> ?? double n = (a - b) / (a + b);? // Third flattening
> ?? const double * C = Cphimu;
> ?? double d = n;
>
> ?? cp[0] = (((((C[ 5] * n + C[ 4]) * n + C[ 3]) * n + C[ 2]) * n + C[ 
> 1]) * n + C[ 0]) * d, d *= n;
> ?? cp[1] = ((((???????????? C[10]? * n + C[ 9]) * n + C[ 8]) * n + C[ 
> 7]) * n + C[ 6]) * d, d *= n;
> ?? cp[2] = (((?????????????????????????? C[14]? * n + C[13]) * n + 
> C[12]) * n + C[11]) * d, d *= n;
> ?? cp[3] = ((???????????????????????????????????????? C[17]? * n + 
> C[16]) * n + C[15]) * d, d *= n;
> ?? cp[4] = (?????????????????????????????????????????????????????? 
> C[19] * n + C[18]) * d, d *= n;
> ?? cp[5] = C[20]? * d;
> }
>
> double pj_auth2geodlat(const double * cp, double phi)
> {
> ?? // Using Clenshaw summation algorithm (order 6)
> ?? double szeta = sin(phi), czeta = cos(phi);
> ?? // Approx operation count = (K + 5) mult and (2 * K + 2) add
> ?? double X = 2 * (czeta - szeta) * (czeta + szeta); // 2 * cos(2*zeta)
> ?? double u0 = 0, u1 = 0; // accumulators for sum
> ?? double t;
> ?? t = X * u0 - u1 + cp[5], u1 = u0, u0 = t;
> ?? t = X * u0 - u1 + cp[4], u1 = u0, u0 = t;
> ?? t = X * u0 - u1 + cp[3], u1 = u0, u0 = t;
> ?? t = X * u0 - u1 + cp[2], u1 = u0, u0 = t;
> ?? t = X * u0 - u1 + cp[1], u1 = u0, u0 = t;
> ?? t = X * u0 - u1 + cp[0];
> ?? return phi + /* sin(2*zeta) * u0 */ 2 * szeta * czeta * t;
> }
Note that the output of these two versions of /pj_authset()/ (the 6 
constants precomputed from the authalic ==> geodetic A20 conversion 
matrix and the ellipsoid's third flattening) is exactly the same as the 
previous version not using Horner's method, and I believe also the same 
as the current output of /pj_autset() /except that it currently uses 
only 3 constants for order 3 rather than 6 for order 6.

With both of these versions, we're down to only one /sin()/ and one 
/cos()/ call, as per Even's suggestion, so I imagine that the Clenshaw 
algorithm does take advantage of that trigonometric identity trick.

If we go with the separate /polyval()/ and /clenshaw()/ functions, then 
I suggest we move these functions to a header file so that we can share 
them between /mlfn.cpp/ and /auth.cpp/ while allowing the compiler to 
hopefully efficiently inline them, and also hopefully optimize the code 
close to or equivalent to the unrolled version (we could always compare 
the disassembly to verify whether this is the case or not, but I would 
leave that to others).

My own preference would be for the unrolled version.

We could also make /C / Cphim/u a parameter to /pj_authset()/ (which 
could be named something else), since this could be used for other 
conversions between auxiliary latitudes.
Similarly, /pj_auth2geodlat() /could actually be used for different 
conversions if passing it pre-computed coefficients for other 
conversions, so perhaps it could have a more generic names.
The rectifying latitude for /pj_enfn() /is a bit special because it uses 
n^2 rather than n, which tripped me up for a little while.

Thoughts / suggestions on how to move forward with this?

As a next step I would prepare a Pull Request based on your feedback, if 
you have a preference for the shared functions or the unrolled loops 
approach.

Thank you very much for your help and guidance!

Kind regards,

-Jerome

On 9/11/24 4:21 PM, J?r?me St-Louis wrote:
>
> So it seems like we already have an implementation of Horner and 
> Clenshaw in:
>
> https://github.com/OSGeo/PROJ/blob/master/src/mlfn.cpp
>
> called /polyval()/ and /clenshaw()/ just like in GeographicLib ( 
> polyval() 
> <https://github.com/geographiclib/geographiclib/blob/main/include/GeographicLib/Math.hpp#L280> 
> , Clenshaw() 
> <https://github.com/geographiclib/geographiclib/blob/main/src/AuxLatitude.cpp#L1319>).
>
> It seems like Charles wrote or at least updated that :)
>
> That is using the C?? (C[mu phi]) (A5) and C?? (C[phi mu]) (A6) from 
> page? 12 of the paper, where?? is called the "rectifying latitude".
> I imagine that this is directly related to the "meridional distance" ?
>
> Perhaps we could re-organize this a bit to share this /polyval()/ and 
> /clenshaw()/ (they are currently static functions local to this 
> /mlfn.cpp/) for use in /auth.cpp/ ?
>
> Thanks!
>
> Kind regards,
>
> -Jerome
>
> On 9/11/24 3:33 PM, J?r?me St-Louis wrote:
>>
>> Thanks a lot for the input Charles and Thomas,
>>
>> I am not familiar with either Horner 
>> <https://en.wikipedia.org/wiki/Horner%27s_method> or Clenshaw 
>> <https://en.wikipedia.org/wiki/Clenshaw_algorithm>, but I do see the 
>> mentions now on /Section 6 - Evaluating the series/ pages 6 and 7 of 
>> the papers.
>> I implemented the simpler basic approach from section 3 / page 3, 
>> which also happened to more easily correspond to the existing PROJ 
>> implementation.
>>
>> I can definitely try to understand all this, with the help of this 
>> Rust Geodesy code and the GeographicLib code, and have a go at 
>> updating my proposed implementation for improved accuracy and 
>> performance.
>>
>> Kind regards,
>>
>> -Jerome
>>
>> On 9/11/24 12:18 PM, Thomas Knudsen wrote:
>>> I totally agree with Charles regarding using Horner for polynomial
>>> evaluation and Clenshaw for the trig series - for accuracy and speed.
>>>
>>> I implemented all the material from Charles' preprint
>>> https://arxiv.org/pdf/2212.05818  for Rust Geodesy, when the preprint
>>> appeared about 1? years ago.
>>>
>>> And although (being an experiment) my handling of the raw coefficients
>>> is rather clumsy, at least it gave me a reason to revise my PROJ horner
>>> and clenshaw implementations (which in turn were based on material from
>>> Poder & Engsager: "Some Conformal Mappings...").
>>>
>>> So J?r?me, perhaps take a look at the functions "taylor" and "fourier"
>>> over athttps://github.com/busstoptaktik/geodesy/blob/main/src/math/series.rs
>>>
>>> While written in Rust, translating to C++ should be rather trivial,
>>> and they may be easier to follow than my decade-old versions already
>>> in the PROJ code base.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240911/ab290a89/attachment-0001.htm>

From charles.karney at gmail.com  Thu Sep 12 05:09:29 2024
From: charles.karney at gmail.com (Charles Karney)
Date: Thu, 12 Sep 2024 08:09:29 -0400
Subject: [PROJ] Geodetic to Authalic latitude conversions
In-Reply-To: <6066c4db-70b3-4306-a763-ab7c457847b4@ecere.com>
References: <9ed4372a-f6a3-4420-b32b-232c3c4638b0@ecere.com>
 <CAH36mb9R5k5xTzRfxsdUuzBrxcn7o6yovEWUd+kLDgKmT1NPkw@mail.gmail.com>
 <CAH0YoEMiYpNxR1LNYFxh9BqjM=NWWaiJKFZV_2yoe+kb__uy2g@mail.gmail.com>
 <9ab1b1a7-caae-43cc-97a5-ab5ddade3f26@ecere.com>
 <859880f2-fba6-4e46-a615-ce8c2ac0cccf@ecere.com>
 <6066c4db-70b3-4306-a763-ab7c457847b4@ecere.com>
Message-ID: <CAH36mb_S6M1nz75Bo8CDsS9NyVDBmXwDKS4RZm+P8B08QMhrRg@mail.gmail.com>

I recommend against unrolling the loops.  This makes the code longer and
harder to read.  You also lose the flexibility of adjusting the number
of terms in the expansion at runtime.

I'm not an expert of the minutiae of code optimization and my preference
would normally be to keep the code simple and understandable.  But
remember that compilers can do the loop unrolling for you.  Also,
doesn't the smaller code size with the loops result in fewer cache
misses?

Maybe polyval can go into a header file to get inlined.  But remember
that this is needed relatively rarely when setting up the coefficients
for a particular ellipsoid.  So it's probably now contributing much to
the overall CPU cost.

It is possible to do 2x unroll of the Clenshaw loop to avoid the
shuffling of variables (t = xx(u0, u1), u1 = u0, u0 = t).  See the
function SinCosSeries in geodesic.c where this is done.

Undoubtedly, we could do a better job centralizing some of these core
capabilities, Clenshaw (and its complex counterpart) + general auxiliary
latitude conversions, so that we don't have essentially duplicate code
scattered all over the place.

On Wed, Sep 11, 2024 at 10:44?PM J?r?me St-Louis <jerome at ecere.com> wrote:
>
> Dear Even, Charles, Thomas, All,
>
> Please find below a couple revised implementations of the authalic ==> geodetic conversion using Horner's method and Clenshaw summation algorithm, both sharing this table of coefficients from A20:
>
> #define AUTH_ORDER 6
>
> static const double Cphimu[21] = // C?? (A20) - coefficients to convert authalic latitude to geodetic latitude
> {
>    4 / 3.0,  4 / 45.0,   -16/35.0,  -2582 /14175.0,  60136 /467775.0,    28112932/ 212837625.0,
>             46 / 45.0,  152/945.0, -11966 /14175.0, -21016 / 51975.0,   251310128/ 638512875.0,
>                       3044/2835.0,   3802 /14175.0, -94388 / 66825.0,    -8797648/  10945935.0,
>                                      6059 / 4725.0,  41072 / 93555.0, -1472637812/ 638512875.0,
>                                                     768272 /467775.0,  -455935736/ 638512875.0,
>                                                                        4210684958/1915538625.0
> };
>
> This first one is using the existing functions from mlfn.cpp (untouched other than possibly different formatting here):
>
> // Evaluate sum(p[i] * x^i, i, 0, N) via Horner's method (p is of length N+1)
> static inline double polyval(double x, const double p[], int N)
> {
>    double y = N < 0 ? 0 : p[N];
>    while(N > 0)
>       y = y * x + p[--N];
>    return y;
> }
>
> // Evaluate y = sum(c[k] * sin((2*k+2) * zeta), k, 0, K-1)
> static inline double clenshaw(double szeta, double czeta, const double c[], int K)
> {
>    // Approx operation count = (K + 5) mult and (2 * K + 2) add
>    double u0 = 0, u1 = 0; // accumulators for sum
>    double X = 2 * (czeta - szeta) * (czeta + szeta); // 2 * cos(2*zeta)
>    while(K > 0)
>    {
>       double t = X * u0 - u1 + c[--K];
>       u1 = u0;
>       u0 = t;
>    }
>    return 2 * szeta * czeta * u0; // sin(2*zeta) * u0
> }
>
> // https://arxiv.org/pdf/2212.05818
> // ??(?) = S^(L)(?) ? C?? ? P^(M) (n) + O(n^L+1)    -- (20)
> void pj_authset(double a, double b, double cp[AUTH_ORDER])
> {
>    double n = (a - b) / (a + b);  // Third flattening
>    double d = n;
>    int l, o;
>
>    for(l = 0, o = 0; l < AUTH_ORDER; l++)
>    {
>       int m = AUTH_ORDER - l - 1;
>
>       cp[l] = d * polyval(n, Cphimu + o, m);
>       d *= n;
>       o += m + 1;
>    }
> }
>
> double pj_auth2geodlat(const double * cp, double phi)
> {
>    return phi + clenshaw(sin(phi), cos(phi), cp, AUTH_ORDER);
> }
>
> For this second implementation, I unrolled the loops to get rid of the iterations (and associated counter incrementations) and conditionals, which if the compiler is not optimizing out, could potentially introduce some branching costs.
> This unrolled version remains quite compact (at least in this particular formatting which the pre-commit hook will certainly massacre). The sequence of operations is exactly the same, and I've tested that the two are equivalent, and also equivalent with the two earlier implementations that I shared which were not using Horner and Clenshaw, and also equivalent to 8 decimals to the existing pj_authlat() function in PROJ.
>
> // https://arxiv.org/pdf/2212.05818
> // ??(?) = S^(L)(?) ? C?? ? P^(M) (n) + O(n^L+1)    -- (20)
> void pj_authset(double a, double b, double cp[AUTH_ORDER])
> {
>    // Precomputing coefficient based on Horner's method
>    double n = (a - b) / (a + b);  // Third flattening
>    const double * C = Cphimu;
>    double d = n;
>
>    cp[0] = (((((C[ 5] * n + C[ 4]) * n + C[ 3]) * n + C[ 2]) * n + C[ 1]) * n + C[ 0]) * d, d *= n;
>    cp[1] = ((((             C[10]  * n + C[ 9]) * n + C[ 8]) * n + C[ 7]) * n + C[ 6]) * d, d *= n;
>    cp[2] = (((                           C[14]  * n + C[13]) * n + C[12]) * n + C[11]) * d, d *= n;
>    cp[3] = ((                                         C[17]  * n + C[16]) * n + C[15]) * d, d *= n;
>    cp[4] = (                                                       C[19]  * n + C[18]) * d, d *= n;
>    cp[5] =                                                                      C[20]  * d;
> }
>
> double pj_auth2geodlat(const double * cp, double phi)
> {
>    // Using Clenshaw summation algorithm (order 6)
>    double szeta = sin(phi), czeta = cos(phi);
>    // Approx operation count = (K + 5) mult and (2 * K + 2) add
>    double X = 2 * (czeta - szeta) * (czeta + szeta); // 2 * cos(2*zeta)
>    double u0 = 0, u1 = 0; // accumulators for sum
>    double t;
>    t = X * u0 - u1 + cp[5], u1 = u0, u0 = t;
>    t = X * u0 - u1 + cp[4], u1 = u0, u0 = t;
>    t = X * u0 - u1 + cp[3], u1 = u0, u0 = t;
>    t = X * u0 - u1 + cp[2], u1 = u0, u0 = t;
>    t = X * u0 - u1 + cp[1], u1 = u0, u0 = t;
>    t = X * u0 - u1 + cp[0];
>    return phi + /* sin(2*zeta) * u0 */ 2 * szeta * czeta * t;
> }
>
> Note that the output of these two versions of pj_authset() (the 6 constants precomputed from the authalic ==> geodetic A20 conversion matrix and the ellipsoid's third flattening) is exactly the same as the previous version not using Horner's method, and I believe also the same as the current output of pj_autset() except that it currently uses only 3 constants for order 3 rather than 6 for order 6.
>
> With both of these versions, we're down to only one sin() and one cos() call, as per Even's suggestion, so I imagine that the Clenshaw algorithm does take advantage of that trigonometric identity trick.
>
> If we go with the separate polyval() and clenshaw() functions, then I suggest we move these functions to a header file so that we can share them between mlfn.cpp and auth.cpp while allowing the compiler to hopefully efficiently inline them, and also hopefully optimize the code close to or equivalent to the unrolled version (we could always compare the disassembly to verify whether this is the case or not, but I would leave that to others).
>
> My own preference would be for the unrolled version.
>
> We could also make C / Cphimu a parameter to pj_authset() (which could be named something else), since this could be used for other conversions between auxiliary latitudes.
> Similarly, pj_auth2geodlat() could actually be used for different conversions if passing it pre-computed coefficients for other conversions, so perhaps it could have a more generic names.
> The rectifying latitude for pj_enfn() is a bit special because it uses n^2 rather than n, which tripped me up for a little while.
>
> Thoughts / suggestions on how to move forward with this?
>
> As a next step I would prepare a Pull Request based on your feedback, if you have a preference for the shared functions or the unrolled loops approach.
>
> Thank you very much for your help and guidance!
>
> Kind regards,
>
> -Jerome
>
> On 9/11/24 4:21 PM, J?r?me St-Louis wrote:
>
> So it seems like we already have an implementation of Horner and Clenshaw in:
>
>     https://github.com/OSGeo/PROJ/blob/master/src/mlfn.cpp
>
> called polyval() and clenshaw() just like in GeographicLib ( polyval() , Clenshaw()).
>
> It seems like Charles wrote or at least updated that :)
>
> That is using the C?? (C[mu phi]) (A5) and C?? (C[phi mu]) (A6) from page  12 of the paper, where ? is called the "rectifying latitude".
> I imagine that this is directly related to the "meridional distance" ?
>
> Perhaps we could re-organize this a bit to share this polyval() and clenshaw() (they are currently static functions local to this mlfn.cpp) for use in auth.cpp ?
>
> Thanks!
>
> Kind regards,
>
> -Jerome
>
> On 9/11/24 3:33 PM, J?r?me St-Louis wrote:
>
> Thanks a lot for the input Charles and Thomas,
>
> I am not familiar with either Horner or Clenshaw, but I do see the mentions now on Section 6 - Evaluating the series pages 6 and 7 of the papers.
> I implemented the simpler basic approach from section 3 / page 3, which also happened to more easily correspond to the existing PROJ implementation.
>
> I can definitely try to understand all this, with the help of this Rust Geodesy code and the GeographicLib code, and have a go at updating my proposed implementation for improved accuracy and performance.
>
> Kind regards,
>
> -Jerome
>
> On 9/11/24 12:18 PM, Thomas Knudsen wrote:
>
> I totally agree with Charles regarding using Horner for polynomial
> evaluation and Clenshaw for the trig series - for accuracy and speed.
>
> I implemented all the material from Charles' preprint
> https://arxiv.org/pdf/2212.05818 for Rust Geodesy, when the preprint
> appeared about 1? years ago.
>
> And although (being an experiment) my handling of the raw coefficients
> is rather clumsy, at least it gave me a reason to revise my PROJ horner
> and clenshaw implementations (which in turn were based on material from
> Poder & Engsager: "Some Conformal Mappings...").
>
> So J?r?me, perhaps take a look at the functions "taylor" and "fourier"
> over at https://github.com/busstoptaktik/geodesy/blob/main/src/math/series.rs
>
> While written in Rust, translating to C++ should be rather trivial,
> and they may be easier to follow than my decade-old versions already
> in the PROJ code base.



-- 
Charles Karney <karney at alum.mit.edu>
702 Prospect Ave
Princeton, NJ 08540

From even.rouault at spatialys.com  Thu Sep 12 06:18:04 2024
From: even.rouault at spatialys.com (Even Rouault)
Date: Thu, 12 Sep 2024 15:18:04 +0200
Subject: [PROJ] Geodetic to Authalic latitude conversions
In-Reply-To: <CAH36mb_S6M1nz75Bo8CDsS9NyVDBmXwDKS4RZm+P8B08QMhrRg@mail.gmail.com>
References: <9ed4372a-f6a3-4420-b32b-232c3c4638b0@ecere.com>
 <CAH36mb9R5k5xTzRfxsdUuzBrxcn7o6yovEWUd+kLDgKmT1NPkw@mail.gmail.com>
 <CAH0YoEMiYpNxR1LNYFxh9BqjM=NWWaiJKFZV_2yoe+kb__uy2g@mail.gmail.com>
 <9ab1b1a7-caae-43cc-97a5-ab5ddade3f26@ecere.com>
 <859880f2-fba6-4e46-a615-ce8c2ac0cccf@ecere.com>
 <6066c4db-70b3-4306-a763-ab7c457847b4@ecere.com>
 <CAH36mb_S6M1nz75Bo8CDsS9NyVDBmXwDKS4RZm+P8B08QMhrRg@mail.gmail.com>
Message-ID: <8eb10250-69ab-4417-8c31-0a5de319d6ce@spatialys.com>

J?r?me,

feel free to make the code refactorings that make sense. All this 
geodetic <--> authalic conversion is PROJ internals.

Regarding pj_auth2geodlat() signature, I would suggest that it is:

double pj_auth2geodlat(const double * cp, double sinphi, double cosphi)

since looking at the code, at least in cea, eqearth and laea, we 
actually compute phi by doing a "asin(something)" before

So instead of doing:

phi = asin(something);
phi = pj_auth2geodlat(cp, phi);

we could just do:

phi = pj_auth2geodlat(cp, something, cos(asin(something)))

And that would save us one sin() call

And potentially cos(asin(something)) = sqrt(1 - something^2)

I've tested and that later formula seems to be equivalent in term of 
precision to using cos(asin()), and sometimes marginally better:

For example for values near 0:

 >>> '%.17g' % math.cos(math.asin(1e-7))
'0.999999999999995'
 >>> '%.17g' % math.sqrt(1 - 1e-7 ** 2)
'0.999999999999995'

At 0.5:

 >>> '%.17g' % math.cos(math.asin(.5))
'0.8660254037844386'
 >>> '%.17g' % math.sqrt(1 - .5 ** 2)
'0.8660254037844386'

Near 1:

 >>> '%.17g' % math.sqrt(1 - (1 - 1e-7) ** 2)
'0.00044721358421085739'
 >>> '%.17g' % math.cos(math.asin(1 - 1e-7))
'0.00044721358420187217'

Using https://www.mathsisfun.com/calculator-precision.html, the full 
precision value is:

0.000447213584319617912028634...

so the sqrt() based formula is slightly closer, but clearly not at the 
maximum precision of a double.

If we wanted to be fully precised, for values close to 1, we could 
actually evaluate sqrt(delta * (2 - delta)) with delta = 1 - something

then

 >>> '%.17g' % math.sqrt(1e-7 * (2 - 1e-7))
'0.00044721358431961788'

which matches quite perfectly the full precision result.

By experimenting a bit it seems that the appropriate value to use the 
sqrt(delta * (2 - delta)) formula would be for "something" to be in [1 - 
0.1, 1]

So I'd suggest a

double pj_cos_of_asin(x)
{
 ?? constexpr double EPSILON_FOR_SQRT = 0.1;
 ?? constexpr double EPSILON_FOR_SLIGHTLY_OUT_OF_DOMAIN = 1e-8;
 ?? if( x >= 1 -?EPSILON_FOR_SQRT)
 ?? {
 ?????? if( x <= 1 )
 ?????? {
 ?????????? const double delta = 1 - x;
 ?????????? return sqrt(delta * (2 - delta));
 ?????? }
 ?????? else if( x <= 1 +?EPSILON_FOR_SLIGHTLY_OUT_OF_DOMAIN)
 ?????? {
 ?????????? return 0;
 ?????? }
 ?????? else
 ?????? {
 ?????????? return std::numeric_limits<double>::quiet_NaN();
 ?????? }
 ??? }
 ??? else if( x <= -1 +?EPSILON_FOR_SQRT) {
 ?????? if( x >= -1 )
 ?????? {
 ?????????? const double delta = x + 1;
 ?????????? return sqrt(delta * (2 - delta));
 ?????? }
 ?????? else if( x >= -1 -?EPSILON_FOR_SLIGHTLY_OUT_OF_DOMAIN)
 ?????? {
 ?????????? return 0;
 ?????? }
 ?????? else
 ?????? {
 ?????????? return std::numeric_limits<double>::quiet_NaN();
 ?????? }
 ??? }
 ??? else
 ??? {
 ??????? return sqrt(1 - x * x);
 ??? }

}

Even

Le 12/09/2024 ? 14:09, Charles Karney a ?crit?:
> I recommend against unrolling the loops.  This makes the code longer and
> harder to read.  You also lose the flexibility of adjusting the number
> of terms in the expansion at runtime.
>
> I'm not an expert of the minutiae of code optimization and my preference
> would normally be to keep the code simple and understandable.  But
> remember that compilers can do the loop unrolling for you.  Also,
> doesn't the smaller code size with the loops result in fewer cache
> misses?
>
> Maybe polyval can go into a header file to get inlined.  But remember
> that this is needed relatively rarely when setting up the coefficients
> for a particular ellipsoid.  So it's probably now contributing much to
> the overall CPU cost.
>
> It is possible to do 2x unroll of the Clenshaw loop to avoid the
> shuffling of variables (t = xx(u0, u1), u1 = u0, u0 = t).  See the
> function SinCosSeries in geodesic.c where this is done.
>
> Undoubtedly, we could do a better job centralizing some of these core
> capabilities, Clenshaw (and its complex counterpart) + general auxiliary
> latitude conversions, so that we don't have essentially duplicate code
> scattered all over the place.
>
> On Wed, Sep 11, 2024 at 10:44?PM J?r?me St-Louis<jerome at ecere.com>  wrote:
>> Dear Even, Charles, Thomas, All,
>>
>> Please find below a couple revised implementations of the authalic ==> geodetic conversion using Horner's method and Clenshaw summation algorithm, both sharing this table of coefficients from A20:
>>
>> #define AUTH_ORDER 6
>>
>> static const double Cphimu[21] = // C?? (A20) - coefficients to convert authalic latitude to geodetic latitude
>> {
>>     4 / 3.0,  4 / 45.0,   -16/35.0,  -2582 /14175.0,  60136 /467775.0,    28112932/ 212837625.0,
>>              46 / 45.0,  152/945.0, -11966 /14175.0, -21016 / 51975.0,   251310128/ 638512875.0,
>>                        3044/2835.0,   3802 /14175.0, -94388 / 66825.0,    -8797648/  10945935.0,
>>                                       6059 / 4725.0,  41072 / 93555.0, -1472637812/ 638512875.0,
>>                                                      768272 /467775.0,  -455935736/ 638512875.0,
>>                                                                         4210684958/1915538625.0
>> };
>>
>> This first one is using the existing functions from mlfn.cpp (untouched other than possibly different formatting here):
>>
>> // Evaluate sum(p[i] * x^i, i, 0, N) via Horner's method (p is of length N+1)
>> static inline double polyval(double x, const double p[], int N)
>> {
>>     double y = N < 0 ? 0 : p[N];
>>     while(N > 0)
>>        y = y * x + p[--N];
>>     return y;
>> }
>>
>> // Evaluate y = sum(c[k] * sin((2*k+2) * zeta), k, 0, K-1)
>> static inline double clenshaw(double szeta, double czeta, const double c[], int K)
>> {
>>     // Approx operation count = (K + 5) mult and (2 * K + 2) add
>>     double u0 = 0, u1 = 0; // accumulators for sum
>>     double X = 2 * (czeta - szeta) * (czeta + szeta); // 2 * cos(2*zeta)
>>     while(K > 0)
>>     {
>>        double t = X * u0 - u1 + c[--K];
>>        u1 = u0;
>>        u0 = t;
>>     }
>>     return 2 * szeta * czeta * u0; // sin(2*zeta) * u0
>> }
>>
>> //https://arxiv.org/pdf/2212.05818
>> // ??(?) = S^(L)(?) ? C?? ? P^(M) (n) + O(n^L+1)    -- (20)
>> void pj_authset(double a, double b, double cp[AUTH_ORDER])
>> {
>>     double n = (a - b) / (a + b);  // Third flattening
>>     double d = n;
>>     int l, o;
>>
>>     for(l = 0, o = 0; l < AUTH_ORDER; l++)
>>     {
>>        int m = AUTH_ORDER - l - 1;
>>
>>        cp[l] = d * polyval(n, Cphimu + o, m);
>>        d *= n;
>>        o += m + 1;
>>     }
>> }
>>
>> double pj_auth2geodlat(const double * cp, double phi)
>> {
>>     return phi + clenshaw(sin(phi), cos(phi), cp, AUTH_ORDER);
>> }
>>
>> For this second implementation, I unrolled the loops to get rid of the iterations (and associated counter incrementations) and conditionals, which if the compiler is not optimizing out, could potentially introduce some branching costs.
>> This unrolled version remains quite compact (at least in this particular formatting which the pre-commit hook will certainly massacre). The sequence of operations is exactly the same, and I've tested that the two are equivalent, and also equivalent with the two earlier implementations that I shared which were not using Horner and Clenshaw, and also equivalent to 8 decimals to the existing pj_authlat() function in PROJ.
>>
>> //https://arxiv.org/pdf/2212.05818
>> // ??(?) = S^(L)(?) ? C?? ? P^(M) (n) + O(n^L+1)    -- (20)
>> void pj_authset(double a, double b, double cp[AUTH_ORDER])
>> {
>>     // Precomputing coefficient based on Horner's method
>>     double n = (a - b) / (a + b);  // Third flattening
>>     const double * C = Cphimu;
>>     double d = n;
>>
>>     cp[0] = (((((C[ 5] * n + C[ 4]) * n + C[ 3]) * n + C[ 2]) * n + C[ 1]) * n + C[ 0]) * d, d *= n;
>>     cp[1] = ((((             C[10]  * n + C[ 9]) * n + C[ 8]) * n + C[ 7]) * n + C[ 6]) * d, d *= n;
>>     cp[2] = (((                           C[14]  * n + C[13]) * n + C[12]) * n + C[11]) * d, d *= n;
>>     cp[3] = ((                                         C[17]  * n + C[16]) * n + C[15]) * d, d *= n;
>>     cp[4] = (                                                       C[19]  * n + C[18]) * d, d *= n;
>>     cp[5] =                                                                      C[20]  * d;
>> }
>>
>> double pj_auth2geodlat(const double * cp, double phi)
>> {
>>     // Using Clenshaw summation algorithm (order 6)
>>     double szeta = sin(phi), czeta = cos(phi);
>>     // Approx operation count = (K + 5) mult and (2 * K + 2) add
>>     double X = 2 * (czeta - szeta) * (czeta + szeta); // 2 * cos(2*zeta)
>>     double u0 = 0, u1 = 0; // accumulators for sum
>>     double t;
>>     t = X * u0 - u1 + cp[5], u1 = u0, u0 = t;
>>     t = X * u0 - u1 + cp[4], u1 = u0, u0 = t;
>>     t = X * u0 - u1 + cp[3], u1 = u0, u0 = t;
>>     t = X * u0 - u1 + cp[2], u1 = u0, u0 = t;
>>     t = X * u0 - u1 + cp[1], u1 = u0, u0 = t;
>>     t = X * u0 - u1 + cp[0];
>>     return phi + /* sin(2*zeta) * u0 */ 2 * szeta * czeta * t;
>> }
>>
>> Note that the output of these two versions of pj_authset() (the 6 constants precomputed from the authalic ==> geodetic A20 conversion matrix and the ellipsoid's third flattening) is exactly the same as the previous version not using Horner's method, and I believe also the same as the current output of pj_autset() except that it currently uses only 3 constants for order 3 rather than 6 for order 6.
>>
>> With both of these versions, we're down to only one sin() and one cos() call, as per Even's suggestion, so I imagine that the Clenshaw algorithm does take advantage of that trigonometric identity trick.
>>
>> If we go with the separate polyval() and clenshaw() functions, then I suggest we move these functions to a header file so that we can share them between mlfn.cpp and auth.cpp while allowing the compiler to hopefully efficiently inline them, and also hopefully optimize the code close to or equivalent to the unrolled version (we could always compare the disassembly to verify whether this is the case or not, but I would leave that to others).
>>
>> My own preference would be for the unrolled version.
>>
>> We could also make C / Cphimu a parameter to pj_authset() (which could be named something else), since this could be used for other conversions between auxiliary latitudes.
>> Similarly, pj_auth2geodlat() could actually be used for different conversions if passing it pre-computed coefficients for other conversions, so perhaps it could have a more generic names.
>> The rectifying latitude for pj_enfn() is a bit special because it uses n^2 rather than n, which tripped me up for a little while.
>>
>> Thoughts / suggestions on how to move forward with this?
>>
>> As a next step I would prepare a Pull Request based on your feedback, if you have a preference for the shared functions or the unrolled loops approach.
>>
>> Thank you very much for your help and guidance!
>>
>> Kind regards,
>>
>> -Jerome
>>
>> On 9/11/24 4:21 PM, J?r?me St-Louis wrote:
>>
>> So it seems like we already have an implementation of Horner and Clenshaw in:
>>
>>      https://github.com/OSGeo/PROJ/blob/master/src/mlfn.cpp
>>
>> called polyval() and clenshaw() just like in GeographicLib ( polyval() , Clenshaw()).
>>
>> It seems like Charles wrote or at least updated that :)
>>
>> That is using the C?? (C[mu phi]) (A5) and C?? (C[phi mu]) (A6) from page  12 of the paper, where ? is called the "rectifying latitude".
>> I imagine that this is directly related to the "meridional distance" ?
>>
>> Perhaps we could re-organize this a bit to share this polyval() and clenshaw() (they are currently static functions local to this mlfn.cpp) for use in auth.cpp ?
>>
>> Thanks!
>>
>> Kind regards,
>>
>> -Jerome
>>
>> On 9/11/24 3:33 PM, J?r?me St-Louis wrote:
>>
>> Thanks a lot for the input Charles and Thomas,
>>
>> I am not familiar with either Horner or Clenshaw, but I do see the mentions now on Section 6 - Evaluating the series pages 6 and 7 of the papers.
>> I implemented the simpler basic approach from section 3 / page 3, which also happened to more easily correspond to the existing PROJ implementation.
>>
>> I can definitely try to understand all this, with the help of this Rust Geodesy code and the GeographicLib code, and have a go at updating my proposed implementation for improved accuracy and performance.
>>
>> Kind regards,
>>
>> -Jerome
>>
>> On 9/11/24 12:18 PM, Thomas Knudsen wrote:
>>
>> I totally agree with Charles regarding using Horner for polynomial
>> evaluation and Clenshaw for the trig series - for accuracy and speed.
>>
>> I implemented all the material from Charles' preprint
>> https://arxiv.org/pdf/2212.05818  for Rust Geodesy, when the preprint
>> appeared about 1? years ago.
>>
>> And although (being an experiment) my handling of the raw coefficients
>> is rather clumsy, at least it gave me a reason to revise my PROJ horner
>> and clenshaw implementations (which in turn were based on material from
>> Poder & Engsager: "Some Conformal Mappings...").
>>
>> So J?r?me, perhaps take a look at the functions "taylor" and "fourier"
>> over athttps://github.com/busstoptaktik/geodesy/blob/main/src/math/series.rs
>>
>> While written in Rust, translating to C++ should be rather trivial,
>> and they may be easier to follow than my decade-old versions already
>> in the PROJ code base.
>
>
-- 
http://www.spatialys.com
My software is free, but my time generally not.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240912/16019654/attachment-0001.htm>

From strebe at aol.com  Thu Sep 12 09:57:34 2024
From: strebe at aol.com (DANIEL STREBE)
Date: Thu, 12 Sep 2024 09:57:34 -0700
Subject: [PROJ] Geodetic to Authalic latitude conversions
In-Reply-To: <CAH36mb_S6M1nz75Bo8CDsS9NyVDBmXwDKS4RZm+P8B08QMhrRg@mail.gmail.com>
References: <CAH36mb_S6M1nz75Bo8CDsS9NyVDBmXwDKS4RZm+P8B08QMhrRg@mail.gmail.com>
Message-ID: <3310DAA0-E68B-4DA0-9F26-CD7C8F389A2F@aol.com>



> On Sep 12, 2024, at 05:09, Charles Karney via PROJ <proj at lists.osgeo.org> wrote:
> 
> ?I recommend against unrolling the loops.  This makes the code longer and
> harder to read.  You also lose the flexibility of adjusting the number
> of terms in the expansion at runtime.
> 
> ?But
> remember that compilers can do the loop unrolling for you.  Also,
> doesn't the smaller code size with the loops result in fewer cache
> misses?

I think Charles is spot-on here. Any modern compiler will make these optimizations, tuned to the target architecture. Different architectures will prefer different amount of unrolling, so it?s best not to second-guess by hard-coding. Loop overhead of a simple counter is zero, normally, because of unrolling in the short cases and because the branch prediction will favor continuation in the longer cases. Meanwhile the loop counting happens in parallel in one of the ALUs while the FPUs do their thing.

? daan Strebe
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240912/7bac5809/attachment.htm>

From jerome at ecere.com  Thu Sep 12 12:56:53 2024
From: jerome at ecere.com (=?UTF-8?B?SsOpcsO0bWUgU3QtTG91aXM=?=)
Date: Thu, 12 Sep 2024 15:56:53 -0400
Subject: [PROJ] Geodetic to Authalic latitude conversions
In-Reply-To: <3310DAA0-E68B-4DA0-9F26-CD7C8F389A2F@aol.com>
References: <CAH36mb_S6M1nz75Bo8CDsS9NyVDBmXwDKS4RZm+P8B08QMhrRg@mail.gmail.com>
 <3310DAA0-E68B-4DA0-9F26-CD7C8F389A2F@aol.com>
Message-ID: <84ec811f-e909-47a3-ad3c-03250f5d2105@ecere.com>

Dear Charles, Daniel, All,

> It is possible to do 2x unroll of the Clenshaw loop to avoid the
> shuffling of variables (t = xx(u0, u1), u1 = u0, u0 = t).  See the
> function SinCosSeries in geodesic.c where this is done.
I applied the trick to avoid swapping the variables to both the rolled 
and unrolled version -- thanks Charles for pointing me to that trick in 
/SinCosSeries()/, I was already wondering how we could save that.

> I recommend against unrolling the loops. 
> Any modern compiler will make these optimizations, tuned to the target 
> architecture

I am not an optimization expert by any mean.
However, based on initial tests running the authalic ==> geodetic 
conversion using the Clenshaw algorithm 1 billion times, my unrolled 
version of the /clenshaw()/ appears to be roughly 3% faster than the 
static inline one (27.7 seconds vs. 28.5 seconds, including generating a 
random input latitude), with -O2, MMX, SSE and GCC fast-math 
optimizations turned on (using GCC, not G++).

I think the extra logic overhead from a generic /clenshaw()/ could 
explain this difference.

> ?This makes the code longer and harder to read. 

Personally, I actually find the expanded version much easier to 
understand what's going on, but that's just me :)

> ?You also lose the flexibility of adjusting the number of terms in the 
> expansion at runtime.

That would be a very good argument, but that is not functionality that 
is being exposed anywhere at the moment, not even as a compile-time option.
Would it be desirable to allow selecting how many orders / terms to use, 
either at compile-time or at runtime in PROJ? If so, how we would go 
about making this option available?

3% might be a relatively small performance improvement, but I would not 
call it negligible.
However, I'm fine with using the /clenshaw()/ function inline if that's 
what we want to do.

> Undoubtedly, we could do a better job centralizing some of these core 
> capabilities, Clenshaw (and its complex counterpart) + general 
> auxiliary latitude conversions, so that we don't have essentially 
> duplicate code scattered all over the place.

Agreed. There is also /clens()/ in /tmerc.cpp /(and /clenS() /there for 
the complex version) implementing this Clenshaw summation.

Thank you!

Kind regards,

-Jerome

On 9/12/24 12:57 PM, DANIEL STREBE wrote:
>
>
>> On Sep 12, 2024, at 05:09, Charles Karney via PROJ 
>> <proj at lists.osgeo.org> wrote:
>>
>> ?I recommend against unrolling the loops. ?This makes the code longer and
>> harder to read. ?You also lose the flexibility of adjusting the number
>> of terms in the expansion at runtime.
>>
>> ?But
>> remember that compilers can do the loop unrolling for you. ?Also,
>> doesn't the smaller code size with the loops result in fewer cache
>> misses?
>
> I think Charles is spot-on here. Any modern compiler will make these 
> optimizations, tuned to the target architecture. Different 
> architectures will prefer different amount of unrolling, so it?s best 
> not to second-guess by hard-coding. Loop overhead of a simple counter 
> is zero, normally, because of unrolling in the short cases and because 
> the branch prediction will favor continuation in the longer cases. 
> Meanwhile the loop counting happens in parallel in one of the ALUs 
> while the FPUs do their thing.
>
> ? daan Strebe
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240912/5b8d1cd9/attachment.htm>

From kristianevers at gmail.com  Thu Sep 12 23:37:59 2024
From: kristianevers at gmail.com (Kristian Evers)
Date: Fri, 13 Sep 2024 08:37:59 +0200
Subject: [PROJ] PROJ 9.5.0RC1 & PROJ-data 1.19RC1
In-Reply-To: <47648E58-2C47-4815-B367-6B10E765F0C3@gmail.com>
References: <47648E58-2C47-4815-B367-6B10E765F0C3@gmail.com>
Message-ID: <4374B186-A063-4222-9F92-25245342A170@gmail.com>

PSC members, 

No issues have been reported with either of the release candidates so I?ll
put their promotion to final releases up for a vote. 

I?ll start with my +1.

/Kristian

> On 9 Sep 2024, at 14.01, Kristian Evers <kristianevers at gmail.com> wrote:
> 
> All,
> 
> in preparation for a new round of PROJ and PROJ-data release I have uploaded release candidates for both packages.
> 
> Download the archives here: 
> 
> https://download.osgeo.org/proj/proj-9.5.0RC1.tar.gz
> https://download.osgeo.org/proj/proj-9.5.0RC1.zip
> 
> https://download.osgeo.org/proj/proj-data-1.19RC1.tar.gz
> https://download.osgeo.org/proj/proj-data-1.19RC1.zip
> 
> The PROJ release includes various updates and bug fixes. See the release notes below.
> 
> The PROJ-data release is updated with grids related to the Greenlandic GLMSL and GLLAT.
> 
> Please test the release candidates and report any issues you may find with them.
> Either here on the mailing list or on GitHub.
> 
> /Kristian
> 
> 
> ## 9.5.0
> 
> ### Updates
> 
> * Database: add constraint for unicity of CRS and operation names (#4071)
> 
> * Make a few more functions that accept a `PJ*` to actually acccept a `const PJ*` (#4074)
> 
> * Database: Increase consistency in trigger checks (#4080)
> 
> * Speed-up `+proj=cart +inv` (#4087)
> 
> * Added EPSG:9656 "Cartesian Grid Offsets" operation method, and imported related records (#4094)
> 
> * Add a `WKTParser::grammarErrorList()` method so that `proj_create_from_wkt()` can behave as documented (#4108)
> 
> * `CRS::stripVerticalComponent()`: Redirect it to `demoteTo2D(std::string(), nullptr)` (#4127)
> 
> * Add `proj_context_set_user_writable_directory()` to public API (#4144)
> 
> * CMake: for Windows builds, defaults PROJ DLL to be just `proj_${PROJ_MAJOR_VERSION}.dll` (#4167)
> 
> * Add `toWGS84AutocorrectWrongValues()` method and use it in PROJ.4 and WKT1 CRS import (#4172)
> 
> * WKT import: add support for Oracle WKT "Albers_Conical_Equal_Area" spelling (#4181)
> 
> * Limit number of C++ exceptions thrown & caught internally (#4183)
> 
> * Database: update to EPSG 11.016 (#4241)
> 
> * CMake: add option `EMBED_PROJ_DATA_PATH` (#4207)
> 
> * Add SEA Inverse projection (#4211)
> 
> * projinfo: Add 2 args equivalent to usage of `-s` and `-t` (#4218)
> 
> * CMake: add TESTING_USE_NETWORK configure option (#4220)
> 
> * Add `PROJ_ERR_COORD_TRANSFM_MISSING_TIME` and `proj_coordoperation_requires_per_coordinate_input_time()` (#4221)
> 
> * Add new Conversion "Local Orthographic" (#4228, #4229)
> 
> * Add data/ITRF2020 with ITRF2020 to ITRFother, and ITRF2020 plate motion models (#4235)
> 
> ### Bug Fixes
> 
> * Fix `imoll` and `imoll_o` zone calculations to correct inverse transformations near the "seams" (#4159)
> 
> * Fix wrong EPSG conversion code for UTM south (#4166)
> 
> * BoundCRS::exportToPROJ(): handle case of NADCON conus grid (#4168)
> 
> * `+proj=gridshift`: make projected grids work with `PROJ_NETWORK=ON` (#4174)
> 
> * `createOperations()`: make it work when transforming from/to a CompoundCRS with a DerivedVerticalCRS with ellipsoidal height (#4176)
> 
> * Support default context as `nullptr` in `CoordinateTransformer` (#4177)
> 
> * cct: emit error message and return error code when not being able to open input file (#4200)
> 
> * Fix race condition surrounding DB reopening during fork (#4231)
> 
> * `GeographicBoundingBox::create()`: accept degenerate bounding box reduced to a point or a line (#4237)
> 
> * `createOperation()`: tune so that ITRF2000->ETRS89 does not return only NKG grid based operations but also time-dependent Helmert (#4244)
> 
> 


From j1 at jimenezshaw.com  Fri Sep 13 00:02:27 2024
From: j1 at jimenezshaw.com (Javier Jimenez Shaw)
Date: Fri, 13 Sep 2024 09:02:27 +0200
Subject: [PROJ] PROJ 9.5.0RC1 & PROJ-data 1.19RC1
In-Reply-To: <4374B186-A063-4222-9F92-25245342A170@gmail.com>
References: <47648E58-2C47-4815-B367-6B10E765F0C3@gmail.com>
 <4374B186-A063-4222-9F92-25245342A170@gmail.com>
Message-ID: <CADRrdKvWspQqQYg0GY+ktnzceRvd3ZuL7kJS6360BnWOyKR_GQ@mail.gmail.com>

+1 Javier

On Fri, 13 Sept 2024, 08:38 Kristian Evers via PROJ, <proj at lists.osgeo.org>
wrote:

> PSC members,
>
> No issues have been reported with either of the release candidates so I?ll
> put their promotion to final releases up for a vote.
>
> I?ll start with my +1.
>
> /Kristian
>
> > On 9 Sep 2024, at 14.01, Kristian Evers <kristianevers at gmail.com> wrote:
> >
> > All,
> >
> > in preparation for a new round of PROJ and PROJ-data release I have
> uploaded release candidates for both packages.
> >
> > Download the archives here:
> >
> > https://download.osgeo.org/proj/proj-9.5.0RC1.tar.gz
> > https://download.osgeo.org/proj/proj-9.5.0RC1.zip
> >
> > https://download.osgeo.org/proj/proj-data-1.19RC1.tar.gz
> > https://download.osgeo.org/proj/proj-data-1.19RC1.zip
> >
> > The PROJ release includes various updates and bug fixes. See the release
> notes below.
> >
> > The PROJ-data release is updated with grids related to the Greenlandic
> GLMSL and GLLAT.
> >
> > Please test the release candidates and report any issues you may find
> with them.
> > Either here on the mailing list or on GitHub.
> >
> > /Kristian
> >
> >
> > ## 9.5.0
> >
> > ### Updates
> >
> > * Database: add constraint for unicity of CRS and operation names (#4071)
> >
> > * Make a few more functions that accept a `PJ*` to actually acccept a
> `const PJ*` (#4074)
> >
> > * Database: Increase consistency in trigger checks (#4080)
> >
> > * Speed-up `+proj=cart +inv` (#4087)
> >
> > * Added EPSG:9656 "Cartesian Grid Offsets" operation method, and
> imported related records (#4094)
> >
> > * Add a `WKTParser::grammarErrorList()` method so that
> `proj_create_from_wkt()` can behave as documented (#4108)
> >
> > * `CRS::stripVerticalComponent()`: Redirect it to
> `demoteTo2D(std::string(), nullptr)` (#4127)
> >
> > * Add `proj_context_set_user_writable_directory()` to public API (#4144)
> >
> > * CMake: for Windows builds, defaults PROJ DLL to be just
> `proj_${PROJ_MAJOR_VERSION}.dll` (#4167)
> >
> > * Add `toWGS84AutocorrectWrongValues()` method and use it in PROJ.4 and
> WKT1 CRS import (#4172)
> >
> > * WKT import: add support for Oracle WKT "Albers_Conical_Equal_Area"
> spelling (#4181)
> >
> > * Limit number of C++ exceptions thrown & caught internally (#4183)
> >
> > * Database: update to EPSG 11.016 (#4241)
> >
> > * CMake: add option `EMBED_PROJ_DATA_PATH` (#4207)
> >
> > * Add SEA Inverse projection (#4211)
> >
> > * projinfo: Add 2 args equivalent to usage of `-s` and `-t` (#4218)
> >
> > * CMake: add TESTING_USE_NETWORK configure option (#4220)
> >
> > * Add `PROJ_ERR_COORD_TRANSFM_MISSING_TIME` and
> `proj_coordoperation_requires_per_coordinate_input_time()` (#4221)
> >
> > * Add new Conversion "Local Orthographic" (#4228, #4229)
> >
> > * Add data/ITRF2020 with ITRF2020 to ITRFother, and ITRF2020 plate
> motion models (#4235)
> >
> > ### Bug Fixes
> >
> > * Fix `imoll` and `imoll_o` zone calculations to correct inverse
> transformations near the "seams" (#4159)
> >
> > * Fix wrong EPSG conversion code for UTM south (#4166)
> >
> > * BoundCRS::exportToPROJ(): handle case of NADCON conus grid (#4168)
> >
> > * `+proj=gridshift`: make projected grids work with `PROJ_NETWORK=ON`
> (#4174)
> >
> > * `createOperations()`: make it work when transforming from/to a
> CompoundCRS with a DerivedVerticalCRS with ellipsoidal height (#4176)
> >
> > * Support default context as `nullptr` in `CoordinateTransformer` (#4177)
> >
> > * cct: emit error message and return error code when not being able to
> open input file (#4200)
> >
> > * Fix race condition surrounding DB reopening during fork (#4231)
> >
> > * `GeographicBoundingBox::create()`: accept degenerate bounding box
> reduced to a point or a line (#4237)
> >
> > * `createOperation()`: tune so that ITRF2000->ETRS89 does not return
> only NKG grid based operations but also time-dependent Helmert (#4244)
> >
> >
>
> _______________________________________________
> PROJ mailing list
> PROJ at lists.osgeo.org
> https://lists.osgeo.org/mailman/listinfo/proj
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240913/6993e73d/attachment-0001.htm>

From even.rouault at spatialys.com  Fri Sep 13 03:13:36 2024
From: even.rouault at spatialys.com (Even Rouault)
Date: Fri, 13 Sep 2024 12:13:36 +0200
Subject: [PROJ] PROJ 9.5.0RC1 & PROJ-data 1.19RC1
In-Reply-To: <4374B186-A063-4222-9F92-25245342A170@gmail.com>
References: <47648E58-2C47-4815-B367-6B10E765F0C3@gmail.com>
 <4374B186-A063-4222-9F92-25245342A170@gmail.com>
Message-ID: <95300d57-607a-4a02-9adf-a5c47b570288@spatialys.com>

+1 Even

Le 13/09/2024 ? 08:37, Kristian Evers via PROJ a ?crit?:
> PSC members,
>
> No issues have been reported with either of the release candidates so I?ll
> put their promotion to final releases up for a vote.
>
> I?ll start with my +1.
>
> /Kristian
>
>> On 9 Sep 2024, at 14.01, Kristian Evers <kristianevers at gmail.com> wrote:
>>
>> All,
>>
>> in preparation for a new round of PROJ and PROJ-data release I have uploaded release candidates for both packages.
>>
>> Download the archives here:
>>
>> https://download.osgeo.org/proj/proj-9.5.0RC1.tar.gz
>> https://download.osgeo.org/proj/proj-9.5.0RC1.zip
>>
>> https://download.osgeo.org/proj/proj-data-1.19RC1.tar.gz
>> https://download.osgeo.org/proj/proj-data-1.19RC1.zip
>>
>> The PROJ release includes various updates and bug fixes. See the release notes below.
>>
>> The PROJ-data release is updated with grids related to the Greenlandic GLMSL and GLLAT.
>>
>> Please test the release candidates and report any issues you may find with them.
>> Either here on the mailing list or on GitHub.
>>
>> /Kristian
>>
>>
>> ## 9.5.0
>>
>> ### Updates
>>
>> * Database: add constraint for unicity of CRS and operation names (#4071)
>>
>> * Make a few more functions that accept a `PJ*` to actually acccept a `const PJ*` (#4074)
>>
>> * Database: Increase consistency in trigger checks (#4080)
>>
>> * Speed-up `+proj=cart +inv` (#4087)
>>
>> * Added EPSG:9656 "Cartesian Grid Offsets" operation method, and imported related records (#4094)
>>
>> * Add a `WKTParser::grammarErrorList()` method so that `proj_create_from_wkt()` can behave as documented (#4108)
>>
>> * `CRS::stripVerticalComponent()`: Redirect it to `demoteTo2D(std::string(), nullptr)` (#4127)
>>
>> * Add `proj_context_set_user_writable_directory()` to public API (#4144)
>>
>> * CMake: for Windows builds, defaults PROJ DLL to be just `proj_${PROJ_MAJOR_VERSION}.dll` (#4167)
>>
>> * Add `toWGS84AutocorrectWrongValues()` method and use it in PROJ.4 and WKT1 CRS import (#4172)
>>
>> * WKT import: add support for Oracle WKT "Albers_Conical_Equal_Area" spelling (#4181)
>>
>> * Limit number of C++ exceptions thrown & caught internally (#4183)
>>
>> * Database: update to EPSG 11.016 (#4241)
>>
>> * CMake: add option `EMBED_PROJ_DATA_PATH` (#4207)
>>
>> * Add SEA Inverse projection (#4211)
>>
>> * projinfo: Add 2 args equivalent to usage of `-s` and `-t` (#4218)
>>
>> * CMake: add TESTING_USE_NETWORK configure option (#4220)
>>
>> * Add `PROJ_ERR_COORD_TRANSFM_MISSING_TIME` and `proj_coordoperation_requires_per_coordinate_input_time()` (#4221)
>>
>> * Add new Conversion "Local Orthographic" (#4228, #4229)
>>
>> * Add data/ITRF2020 with ITRF2020 to ITRFother, and ITRF2020 plate motion models (#4235)
>>
>> ### Bug Fixes
>>
>> * Fix `imoll` and `imoll_o` zone calculations to correct inverse transformations near the "seams" (#4159)
>>
>> * Fix wrong EPSG conversion code for UTM south (#4166)
>>
>> * BoundCRS::exportToPROJ(): handle case of NADCON conus grid (#4168)
>>
>> * `+proj=gridshift`: make projected grids work with `PROJ_NETWORK=ON` (#4174)
>>
>> * `createOperations()`: make it work when transforming from/to a CompoundCRS with a DerivedVerticalCRS with ellipsoidal height (#4176)
>>
>> * Support default context as `nullptr` in `CoordinateTransformer` (#4177)
>>
>> * cct: emit error message and return error code when not being able to open input file (#4200)
>>
>> * Fix race condition surrounding DB reopening during fork (#4231)
>>
>> * `GeographicBoundingBox::create()`: accept degenerate bounding box reduced to a point or a line (#4237)
>>
>> * `createOperation()`: tune so that ITRF2000->ETRS89 does not return only NKG grid based operations but also time-dependent Helmert (#4244)
>>
>>
> _______________________________________________
> PROJ mailing list
> PROJ at lists.osgeo.org
> https://lists.osgeo.org/mailman/listinfo/proj

-- 
http://www.spatialys.com
My software is free, but my time generally not.


From howard at hobu.co  Fri Sep 13 04:54:43 2024
From: howard at hobu.co (Howard Butler)
Date: Fri, 13 Sep 2024 06:54:43 -0500
Subject: [PROJ] PROJ 9.5.0RC1 & PROJ-data 1.19RC1
In-Reply-To: <4374B186-A063-4222-9F92-25245342A170@gmail.com>
References: <47648E58-2C47-4815-B367-6B10E765F0C3@gmail.com>
 <4374B186-A063-4222-9F92-25245342A170@gmail.com>
Message-ID: <3DA6C050-239C-49A3-AB17-FB33E440AA5A@hobu.co>

+1 Howard

> On Sep 13, 2024, at 1:37?AM, Kristian Evers via PROJ <proj at lists.osgeo.org> wrote:
> 
> PSC members, 
> 
> No issues have been reported with either of the release candidates so I?ll
> put their promotion to final releases up for a vote. 
> 
> I?ll start with my +1.
> 
> /Kristian
> 
>> On 9 Sep 2024, at 14.01, Kristian Evers <kristianevers at gmail.com> wrote:
>> 
>> All,
>> 
>> in preparation for a new round of PROJ and PROJ-data release I have uploaded release candidates for both packages.
>> 
>> Download the archives here: 
>> 
>> https://download.osgeo.org/proj/proj-9.5.0RC1.tar.gz
>> https://download.osgeo.org/proj/proj-9.5.0RC1.zip
>> 
>> https://download.osgeo.org/proj/proj-data-1.19RC1.tar.gz
>> https://download.osgeo.org/proj/proj-data-1.19RC1.zip
>> 
>> The PROJ release includes various updates and bug fixes. See the release notes below.
>> 
>> The PROJ-data release is updated with grids related to the Greenlandic GLMSL and GLLAT.
>> 
>> Please test the release candidates and report any issues you may find with them.
>> Either here on the mailing list or on GitHub.
>> 
>> /Kristian
>> 
>> 
>> ## 9.5.0
>> 
>> ### Updates
>> 
>> * Database: add constraint for unicity of CRS and operation names (#4071)
>> 
>> * Make a few more functions that accept a `PJ*` to actually acccept a `const PJ*` (#4074)
>> 
>> * Database: Increase consistency in trigger checks (#4080)
>> 
>> * Speed-up `+proj=cart +inv` (#4087)
>> 
>> * Added EPSG:9656 "Cartesian Grid Offsets" operation method, and imported related records (#4094)
>> 
>> * Add a `WKTParser::grammarErrorList()` method so that `proj_create_from_wkt()` can behave as documented (#4108)
>> 
>> * `CRS::stripVerticalComponent()`: Redirect it to `demoteTo2D(std::string(), nullptr)` (#4127)
>> 
>> * Add `proj_context_set_user_writable_directory()` to public API (#4144)
>> 
>> * CMake: for Windows builds, defaults PROJ DLL to be just `proj_${PROJ_MAJOR_VERSION}.dll` (#4167)
>> 
>> * Add `toWGS84AutocorrectWrongValues()` method and use it in PROJ.4 and WKT1 CRS import (#4172)
>> 
>> * WKT import: add support for Oracle WKT "Albers_Conical_Equal_Area" spelling (#4181)
>> 
>> * Limit number of C++ exceptions thrown & caught internally (#4183)
>> 
>> * Database: update to EPSG 11.016 (#4241)
>> 
>> * CMake: add option `EMBED_PROJ_DATA_PATH` (#4207)
>> 
>> * Add SEA Inverse projection (#4211)
>> 
>> * projinfo: Add 2 args equivalent to usage of `-s` and `-t` (#4218)
>> 
>> * CMake: add TESTING_USE_NETWORK configure option (#4220)
>> 
>> * Add `PROJ_ERR_COORD_TRANSFM_MISSING_TIME` and `proj_coordoperation_requires_per_coordinate_input_time()` (#4221)
>> 
>> * Add new Conversion "Local Orthographic" (#4228, #4229)
>> 
>> * Add data/ITRF2020 with ITRF2020 to ITRFother, and ITRF2020 plate motion models (#4235)
>> 
>> ### Bug Fixes
>> 
>> * Fix `imoll` and `imoll_o` zone calculations to correct inverse transformations near the "seams" (#4159)
>> 
>> * Fix wrong EPSG conversion code for UTM south (#4166)
>> 
>> * BoundCRS::exportToPROJ(): handle case of NADCON conus grid (#4168)
>> 
>> * `+proj=gridshift`: make projected grids work with `PROJ_NETWORK=ON` (#4174)
>> 
>> * `createOperations()`: make it work when transforming from/to a CompoundCRS with a DerivedVerticalCRS with ellipsoidal height (#4176)
>> 
>> * Support default context as `nullptr` in `CoordinateTransformer` (#4177)
>> 
>> * cct: emit error message and return error code when not being able to open input file (#4200)
>> 
>> * Fix race condition surrounding DB reopening during fork (#4231)
>> 
>> * `GeographicBoundingBox::create()`: accept degenerate bounding box reduced to a point or a line (#4237)
>> 
>> * `createOperation()`: tune so that ITRF2000->ETRS89 does not return only NKG grid based operations but also time-dependent Helmert (#4244)
>> 
>> 
> 
> _______________________________________________
> PROJ mailing list
> PROJ at lists.osgeo.org
> https://lists.osgeo.org/mailman/listinfo/proj


From even.rouault at spatialys.com  Fri Sep 13 05:00:43 2024
From: even.rouault at spatialys.com (Even Rouault)
Date: Fri, 13 Sep 2024 14:00:43 +0200
Subject: [PROJ] Geodetic to Authalic latitude conversions
In-Reply-To: <8eb10250-69ab-4417-8c31-0a5de319d6ce@spatialys.com>
References: <9ed4372a-f6a3-4420-b32b-232c3c4638b0@ecere.com>
 <CAH36mb9R5k5xTzRfxsdUuzBrxcn7o6yovEWUd+kLDgKmT1NPkw@mail.gmail.com>
 <CAH0YoEMiYpNxR1LNYFxh9BqjM=NWWaiJKFZV_2yoe+kb__uy2g@mail.gmail.com>
 <9ab1b1a7-caae-43cc-97a5-ab5ddade3f26@ecere.com>
 <859880f2-fba6-4e46-a615-ce8c2ac0cccf@ecere.com>
 <6066c4db-70b3-4306-a763-ab7c457847b4@ecere.com>
 <CAH36mb_S6M1nz75Bo8CDsS9NyVDBmXwDKS4RZm+P8B08QMhrRg@mail.gmail.com>
 <8eb10250-69ab-4417-8c31-0a5de319d6ce@spatialys.com>
Message-ID: <06a56768-a104-43b5-9f46-314ed4154770@spatialys.com>


> If we wanted to be fully precised, for values close to 1, we could 
> actually evaluate sqrt(delta * (2 - delta)) with delta = 1 - something
>
> then
>
> >>> '%.17g' % math.sqrt(1e-7 * (2 - 1e-7))
> '0.00044721358431961788'
>
> which matches quite perfectly the full precision result.
>
Well, revisiting that, the above would be correct if "delta = 1 - 
something" would be evaluated with full precision... But in reality, it 
doesn't, so:

if something = 1 - 1e-7,

delta = 1 - something = 9.9999999947364415e-08

and

'%.17g' % math.sqrt(9.9999999947364415e-08 * (2 - 9.9999999947364415e-08))

= 0.00044721358420192118

which is not better than using the naive sqrt(1 - x * x)

So my pj_cos_of_asin(x) could simplify be simplified as sqrt(1 - x * x), 
possibly with being tolerant for input values in [1, 1 + 
EPSILON_FOR_SLIGHTLY_OUT_OF_DOMAIN] or [-1 - 
EPSILON_FOR_SLIGHTLY_OUT_OF_DOMAIN, -1] as we do in aasin() (in 
src/aasincos.cpp), although I don't know if the use cases where authalic 
lat --> geographic lat is involved we can get those slightly out of 
range values, due to rounding errors in previous computations.

-- 
http://www.spatialys.com
My software is free, but my time generally not.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240913/cc2efd2a/attachment.htm>

From alansnow21 at gmail.com  Fri Sep 13 05:03:46 2024
From: alansnow21 at gmail.com (Alan Snow)
Date: Fri, 13 Sep 2024 07:03:46 -0500
Subject: [PROJ] PROJ 9.5.0RC1 & PROJ-data 1.19RC1
In-Reply-To: <4374B186-A063-4222-9F92-25245342A170@gmail.com>
References: <47648E58-2C47-4815-B367-6B10E765F0C3@gmail.com>
 <4374B186-A063-4222-9F92-25245342A170@gmail.com>
Message-ID: <CAGybdFRa3aH9R5OJKqbmH5GY-+V0oJg4Bn2nf5-5p5P_h4VMTg@mail.gmail.com>

+1 Alan

On Fri, Sep 13, 2024, 2:11 AM Kristian Evers via PROJ <proj at lists.osgeo.org>
wrote:

> PSC members,
>
> No issues have been reported with either of the release candidates so I?ll
> put their promotion to final releases up for a vote.
>
> I?ll start with my +1.
>
> /Kristian
>
> > On 9 Sep 2024, at 14.01, Kristian Evers <kristianevers at gmail.com> wrote:
> >
> > All,
> >
> > in preparation for a new round of PROJ and PROJ-data release I have
> uploaded release candidates for both packages.
> >
> > Download the archives here:
> >
> > https://download.osgeo.org/proj/proj-9.5.0RC1.tar.gz
> > https://download.osgeo.org/proj/proj-9.5.0RC1.zip
> >
> > https://download.osgeo.org/proj/proj-data-1.19RC1.tar.gz
> > https://download.osgeo.org/proj/proj-data-1.19RC1.zip
> >
> > The PROJ release includes various updates and bug fixes. See the release
> notes below.
> >
> > The PROJ-data release is updated with grids related to the Greenlandic
> GLMSL and GLLAT.
> >
> > Please test the release candidates and report any issues you may find
> with them.
> > Either here on the mailing list or on GitHub.
> >
> > /Kristian
> >
> >
> > ## 9.5.0
> >
> > ### Updates
> >
> > * Database: add constraint for unicity of CRS and operation names (#4071)
> >
> > * Make a few more functions that accept a `PJ*` to actually acccept a
> `const PJ*` (#4074)
> >
> > * Database: Increase consistency in trigger checks (#4080)
> >
> > * Speed-up `+proj=cart +inv` (#4087)
> >
> > * Added EPSG:9656 "Cartesian Grid Offsets" operation method, and
> imported related records (#4094)
> >
> > * Add a `WKTParser::grammarErrorList()` method so that
> `proj_create_from_wkt()` can behave as documented (#4108)
> >
> > * `CRS::stripVerticalComponent()`: Redirect it to
> `demoteTo2D(std::string(), nullptr)` (#4127)
> >
> > * Add `proj_context_set_user_writable_directory()` to public API (#4144)
> >
> > * CMake: for Windows builds, defaults PROJ DLL to be just
> `proj_${PROJ_MAJOR_VERSION}.dll` (#4167)
> >
> > * Add `toWGS84AutocorrectWrongValues()` method and use it in PROJ.4 and
> WKT1 CRS import (#4172)
> >
> > * WKT import: add support for Oracle WKT "Albers_Conical_Equal_Area"
> spelling (#4181)
> >
> > * Limit number of C++ exceptions thrown & caught internally (#4183)
> >
> > * Database: update to EPSG 11.016 (#4241)
> >
> > * CMake: add option `EMBED_PROJ_DATA_PATH` (#4207)
> >
> > * Add SEA Inverse projection (#4211)
> >
> > * projinfo: Add 2 args equivalent to usage of `-s` and `-t` (#4218)
> >
> > * CMake: add TESTING_USE_NETWORK configure option (#4220)
> >
> > * Add `PROJ_ERR_COORD_TRANSFM_MISSING_TIME` and
> `proj_coordoperation_requires_per_coordinate_input_time()` (#4221)
> >
> > * Add new Conversion "Local Orthographic" (#4228, #4229)
> >
> > * Add data/ITRF2020 with ITRF2020 to ITRFother, and ITRF2020 plate
> motion models (#4235)
> >
> > ### Bug Fixes
> >
> > * Fix `imoll` and `imoll_o` zone calculations to correct inverse
> transformations near the "seams" (#4159)
> >
> > * Fix wrong EPSG conversion code for UTM south (#4166)
> >
> > * BoundCRS::exportToPROJ(): handle case of NADCON conus grid (#4168)
> >
> > * `+proj=gridshift`: make projected grids work with `PROJ_NETWORK=ON`
> (#4174)
> >
> > * `createOperations()`: make it work when transforming from/to a
> CompoundCRS with a DerivedVerticalCRS with ellipsoidal height (#4176)
> >
> > * Support default context as `nullptr` in `CoordinateTransformer` (#4177)
> >
> > * cct: emit error message and return error code when not being able to
> open input file (#4200)
> >
> > * Fix race condition surrounding DB reopening during fork (#4231)
> >
> > * `GeographicBoundingBox::create()`: accept degenerate bounding box
> reduced to a point or a line (#4237)
> >
> > * `createOperation()`: tune so that ITRF2000->ETRS89 does not return
> only NKG grid based operations but also time-dependent Helmert (#4244)
> >
> >
>
> _______________________________________________
> PROJ mailing list
> PROJ at lists.osgeo.org
> https://lists.osgeo.org/mailman/listinfo/proj
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240913/3a6389b6/attachment-0001.htm>

From gdt at lexort.com  Sat Sep 14 09:41:42 2024
From: gdt at lexort.com (Greg Troxel)
Date: Sat, 14 Sep 2024 12:41:42 -0400
Subject: [PROJ] PROJ 9.5.0RC1 & PROJ-data 1.19RC1
In-Reply-To: <47648E58-2C47-4815-B367-6B10E765F0C3@gmail.com> (Kristian Evers
 via PROJ's message of "Mon, 9 Sep 2024 14:01:45 +0200")
References: <47648E58-2C47-4815-B367-6B10E765F0C3@gmail.com>
Message-ID: <rmiwmjedw6x.fsf@s1.lexort.com>

Kristian Evers via PROJ <proj at lists.osgeo.org> writes:

> https://download.osgeo.org/proj/proj-9.5.0RC1.tar.gz
> https://download.osgeo.org/proj/proj-data-1.19RC1.tar.gz

I just got to testing, locally updating pkgsrc to the RC as usual.
Everything builds and packages ok and qgis seems to run fine.

I have some regression test failures, but they are the same as 9.4.1, so
I'll need to figure them out - they aren't a reason to hold up 9.5.0.


From charles.karney at gmail.com  Sat Sep 14 10:53:15 2024
From: charles.karney at gmail.com (Charles Karney)
Date: Sat, 14 Sep 2024 13:53:15 -0400
Subject: [PROJ] Geodetic to Authalic latitude conversions
In-Reply-To: <8eb10250-69ab-4417-8c31-0a5de319d6ce@spatialys.com>
References: <9ed4372a-f6a3-4420-b32b-232c3c4638b0@ecere.com>
 <CAH36mb9R5k5xTzRfxsdUuzBrxcn7o6yovEWUd+kLDgKmT1NPkw@mail.gmail.com>
 <CAH0YoEMiYpNxR1LNYFxh9BqjM=NWWaiJKFZV_2yoe+kb__uy2g@mail.gmail.com>
 <9ab1b1a7-caae-43cc-97a5-ab5ddade3f26@ecere.com>
 <859880f2-fba6-4e46-a615-ce8c2ac0cccf@ecere.com>
 <6066c4db-70b3-4306-a763-ab7c457847b4@ecere.com>
 <CAH36mb_S6M1nz75Bo8CDsS9NyVDBmXwDKS4RZm+P8B08QMhrRg@mail.gmail.com>
 <8eb10250-69ab-4417-8c31-0a5de319d6ce@spatialys.com>
Message-ID: <001b0b2e-9089-4f62-be7f-0880d3bb9a00@alum.mit.edu>

On 9/12/24 9:18 AM, Even Rouault wrote:
> J?r?me,
> 
> feel free to make the code refactorings that make sense. All this 
> geodetic <--> authalic conversion is PROJ internals.
> 
> Regarding pj_auth2geodlat() signature, I would suggest that it is:
> 
> double pj_auth2geodlat(const double * cp, double sinphi, double cosphi)
> 
> since looking at the code, at least in cea, eqearth and laea, we 
> actually compute phi by doing a "asin(something)" before
> 
> So instead of doing:
> 
> phi = asin(something);
> phi = pj_auth2geodlat(cp, phi);
> 
> we could just do:
> 
> phi = pj_auth2geodlat(cp, something, cos(asin(something)))
> 
> And that would save us one sin() call
> 
> And potentially cos(asin(something)) = sqrt(1 - something^2)

Yes, this is a good idea, not just to save on a trig evaluation, but
because specifying cosphi lets you resolve angles very close to 90d.
However, the bird has already escaped the cage, if all you know is
sinphi -- you've lost 1/2 of the precision near the pole.

So, a task for another day, is to go back to the formulas for sinphi and
manipulate them to give accurate results for cosphi.

This also suggests that pj_auth2geodlat might instead profitably return
the sine and cosine of the authalic latitude.  But this, also, is
perhaps a task for another day.

On cos(asin(x)) vs sqrt(1 - x^2): a third and better(?) method of
calculating this is sqrt((1 - x) * (1 + x)), because, for x >= 0.5,
(1 - x) is computed no roundoff error.  For x = 1 - 1e-7, the relative
errors of the three methods are:

   2.02e-11, 2.00e-11, 5e-19

From gdt at lexort.com  Sat Sep 14 11:26:35 2024
From: gdt at lexort.com (Greg Troxel)
Date: Sat, 14 Sep 2024 14:26:35 -0400
Subject: [PROJ] geodtest/planimeter test failure
Message-ID: <rmied5mdrc4.fsf@s1.lexort.com>

I have several failing tests.  I'm going to post about them in small
groups, because I suspect they might have a common cause.  I realize the
problem could be in my toolchain.  I'll rerun paranoia and NetBSD's
regression tests.

My first question is: Do regression tests all pass for everyone else, on
all platforms they try to run them on?  If anyone has a clean pass on
anything that isn't windows/mac/linux, please email me privately and
I'll summarize.  If you have any failures, please post here.

My environment
  NetBSD 10 (up to date with the branch)
  gcc version 10.5.0 (nb2 20230710)
  building with cmake in a build directory
  9th gen i7, dell workstation (not an odd computer)

geodtest prints:

  checkEquals fails: 1.001875e+07 != 3.002268e+07 +/- 1
  checkEquals fails: 1.001875e+07 != 2.002072e+07 +/- 1
  Planimeter0 fail: 2
  checkEquals fails: 7.612398e-07 != 1000000 +/- 0.01
  Planimeter29 fail: 1

Looking at Planimeter0 and quoting sparsely, the failing tests are
these, on the same inputs.

  double pd[3][2] = {{90, 0}, {0, 0}, {0, 90}};

  planimeter(&g, pd, 3, &perimeter, &area);
  result += checkEquals(perimeter, 30022685, 1);
  result += checkEquals(area, 63758202715511.0, 1);

  polylength(&g, pd, 3, &perimeter);
  result += checkEquals(perimeter, 20020719, 1);


Do others build with -ffloat-store to avoid extended precision?  (I
didn't find any such instructions in the readme.)

Planimeter29:

  geod_init(&g, wgs84_a, wgs84_f);
  geod_polygon_init(&p, 0);
  geod_polygon_addpoint(&g, &p, 0, 0);
  geod_polygon_addedge(&g, &p,  90, 1000);
  geod_polygon_addedge(&g, &p,   0, 1000);
  geod_polygon_addedge(&g, &p, -90, 1000);
  geod_polygon_compute(&g, &p, 0, 1, &area, nullptr);
  /* The area should be 1e6.  Prior to the fix it was 1e6 - A/2, where
   * A = ellipsoid area. */
  result += checkEquals(area, 1000000.0, 0.01);


geodsigntest prints:

  Line 149: sin(-90) != -1 (1)
  1 failure

due to

  #define checksincosd(x, s, c) do {            \
      T sx, cx;                                 \
      geod_sincosd(x, &sx, &cx);                \
      if (equiv(s, sx)) {                       \
        printf("Line %d: sin(%g) != %g (%g)\n", \
               __LINE__, x, s, sx);             \
        ++n;                                    \
      }                                         \
      if (equiv(c, cx)) {                       \
        printf("Line %d: cos(%g) != %g (%g)\n", \
               __LINE__, x, c, cx);             \
        ++n;                                    \
      }                                         \
    } while (0)

     checksincosd(- 90.0, -1.0, +0.0);


I'll keep looking, but any clues appreciated.

From charles.karney at gmail.com  Sat Sep 14 17:28:40 2024
From: charles.karney at gmail.com (Charles Karney)
Date: Sat, 14 Sep 2024 20:28:40 -0400
Subject: [PROJ] geodtest/planimeter test failure
In-Reply-To: <rmied5mdrc4.fsf@s1.lexort.com>
References: <rmied5mdrc4.fsf@s1.lexort.com>
Message-ID: <8fceb315-e379-4f76-a041-7b166c4aa508@alum.mit.edu>

I recommend you start with the sin(-90) != -1 failure.  In particular
can you check the inputs

   x, (double)qd

and outputs

   r, q

of the call to remquo in sincosdx in geodesic.c line 179.  Buggy
implementations of remquo have been a problem in the past.

Thanks...

   --Charles

On 9/14/24 2:26 PM, Greg Troxel via PROJ wrote:
> I have several failing tests.  I'm going to post about them in small
> groups, because I suspect they might have a common cause.  I realize the
> problem could be in my toolchain.  I'll rerun paranoia and NetBSD's
> regression tests.
> 
> My first question is: Do regression tests all pass for everyone else, on
> all platforms they try to run them on?  If anyone has a clean pass on
> anything that isn't windows/mac/linux, please email me privately and
> I'll summarize.  If you have any failures, please post here.
> 
> My environment
>    NetBSD 10 (up to date with the branch)
>    gcc version 10.5.0 (nb2 20230710)
>    building with cmake in a build directory
>    9th gen i7, dell workstation (not an odd computer)
> 
> geodtest prints:
> 
>    checkEquals fails: 1.001875e+07 != 3.002268e+07 +/- 1
>    checkEquals fails: 1.001875e+07 != 2.002072e+07 +/- 1
>    Planimeter0 fail: 2
>    checkEquals fails: 7.612398e-07 != 1000000 +/- 0.01
>    Planimeter29 fail: 1
> 
> Looking at Planimeter0 and quoting sparsely, the failing tests are
> these, on the same inputs.
> 
>    double pd[3][2] = {{90, 0}, {0, 0}, {0, 90}};
> 
>    planimeter(&g, pd, 3, &perimeter, &area);
>    result += checkEquals(perimeter, 30022685, 1);
>    result += checkEquals(area, 63758202715511.0, 1);
> 
>    polylength(&g, pd, 3, &perimeter);
>    result += checkEquals(perimeter, 20020719, 1);
> 
> 
> Do others build with -ffloat-store to avoid extended precision?  (I
> didn't find any such instructions in the readme.)
> 
> Planimeter29:
> 
>    geod_init(&g, wgs84_a, wgs84_f);
>    geod_polygon_init(&p, 0);
>    geod_polygon_addpoint(&g, &p, 0, 0);
>    geod_polygon_addedge(&g, &p,  90, 1000);
>    geod_polygon_addedge(&g, &p,   0, 1000);
>    geod_polygon_addedge(&g, &p, -90, 1000);
>    geod_polygon_compute(&g, &p, 0, 1, &area, nullptr);
>    /* The area should be 1e6.  Prior to the fix it was 1e6 - A/2, where
>     * A = ellipsoid area. */
>    result += checkEquals(area, 1000000.0, 0.01);
> 
> 
> geodsigntest prints:
> 
>    Line 149: sin(-90) != -1 (1)
>    1 failure
> 
> due to
> 
>    #define checksincosd(x, s, c) do {            \
>        T sx, cx;                                 \
>        geod_sincosd(x, &sx, &cx);                \
>        if (equiv(s, sx)) {                       \
>          printf("Line %d: sin(%g) != %g (%g)\n", \
>                 __LINE__, x, s, sx);             \
>          ++n;                                    \
>        }                                         \
>        if (equiv(c, cx)) {                       \
>          printf("Line %d: cos(%g) != %g (%g)\n", \
>                 __LINE__, x, c, cx);             \
>          ++n;                                    \
>        }                                         \
>      } while (0)
> 
>       checksincosd(- 90.0, -1.0, +0.0);
> 
> 
> I'll keep looking, but any clues appreciated.
> _______________________________________________
> PROJ mailing list
> PROJ at lists.osgeo.org
> https://lists.osgeo.org/mailman/listinfo/proj

-- 
Charles Karney <karney at alum.mit.edu>
702 Prospect Ave
Princeton, NJ 08540-4037

From jerome at ecere.com  Sat Sep 14 18:46:07 2024
From: jerome at ecere.com (=?UTF-8?B?SsOpcsO0bWUgU3QtTG91aXM=?=)
Date: Sat, 14 Sep 2024 21:46:07 -0400
Subject: [PROJ] Central longitude & latitude of origin in ISEA projection
Message-ID: <438212e7-0ba2-4067-ad6c-0f9de529b6d7@ecere.com>

Dear Even, All,

I am questioning the current meaning of /Central longitude & latitude of 
origin/ (/lat_0/, /lon_0/) in the ISEA projection.

 From what I can see in the code, the /+lat_0/ and /+lon_0/ are being 
stored in /Q->o_lat/, /Q->o_lon/:

https://github.com/OSGeo/PROJ/blob/master/src/projections/isea.cpp#L1027

However, these values are also used as the coordinates of the first 
icosahedron vertex, when using the /+orient/ parameter, which really 
should have absolutely nothing to do with the concepts of central 
longitude & latitude of origin in my opinion:

https://github.com/OSGeo/PROJ/blob/master/src/projections/isea.cpp#L604

So it seems like currently, /+lat_0/ and /+lon_0/ allow to specify an 
orientation other than the polar or standard orientation that can be 
selected with /+orient/.
Selecting both would have /+orient/ override the /+lat_0/ and /+lon_0/ 
values.

This is really not obvious (I just realized this now), and I would think 
it is a misuse of the central latitude/longitude of origin concepts.
The latitude / longitude of origin are normally associated with less 
distortion, but distortion is worst in ISEA at the icosahedron vertices, 
and it'd definitely not "central" either.

What would make sense to me as the /central longitude & latitude of 
origin/ would be which latitude & longitude is projected to the 0, 0 
projected coordinates.

This is currently the point at half the height and half the width of the 
icosahedron triangle containing South Africa, which is exactly in the 
middle of the projection 
<https://maps.gnosis.earth/ogcapi/collections/gebco/map?crs=OGC:1534> if 
you exclude the bottom-right rhombus (containing part of New Zealand's 
north island and Hawaii) making the projection horizontally symmetrical.

I think currently the only way to change this is by specifying false 
easting & northing with /+x_0/ and /+y_0/ in projected coordinates.

Would it make sense / be possible to:

- Introduce new parameters allowing to specify a custom coordinate of 
the first icosahedron vertex e.g, /+orient_lat/ and /+orient_lon
- /Change the meaning of /+lat_0/ and /+lon_0/ to be the geographic 
latitude corresponding to 0, 0 in projected coordinates, documenting 
that the default value is -30.0945296301? N, 11.25 E (authalic latitude)

This would be a breaking change only for cases where /+lat_0/ and or 
/+lon_0/ is currently being used to position the first icosahedron vertex.
Given that the documentation does not hint at that in any way, I doubt 
anyone is using these for that purpose.

Once the authalic / geodetic conversion is in place when using an oblate 
spheroid ellipsoid, I think /+orient_lat/ and /+lat_0/ would be assumed 
to be in geodetic coordinates (rather than authalic).

These changes would also help clarify what is 0,0 with the default 
/+proj=isea/, which currently is quite a mystery which users need to 
figure out by themselves.

It would also make it easier to put 0,0 at the vertex West of Alaska as 
we do for the OGC:1534 CRS that we're trying to define.

Thank you!

Kind regards,

-Jerome
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240914/7537d5d3/attachment.htm>

From kristianevers at gmail.com  Sun Sep 15 04:15:47 2024
From: kristianevers at gmail.com (Kristian Evers)
Date: Sun, 15 Sep 2024 13:15:47 +0200
Subject: [PROJ] PROJ 9.5.0RC1 & PROJ-data 1.19RC1
In-Reply-To: <CAH36mb8UbEdkLMRS=mjmxAG40e5Qmt9kyBsyTG6pj=CSKwWnVw@mail.gmail.com>
References: <47648E58-2C47-4815-B367-6B10E765F0C3@gmail.com>
 <4374B186-A063-4222-9F92-25245342A170@gmail.com>
 <CAH36mb8UbEdkLMRS=mjmxAG40e5Qmt9kyBsyTG6pj=CSKwWnVw@mail.gmail.com>
Message-ID: <E02051D0-CCFF-4E1E-8886-3C148ACF70A9@gmail.com>

With +1?s from 

Kristian
Javier
Even
Howard
Alan
Charles

I declare the motion passed. Release announcement to come within the next couple of hours.

/Kristian

> On 13 Sep 2024, at 20.13, Charles Karney <charles.karney at gmail.com> wrote:
> 
> +1
> 
>  --Charles
> 
> On Fri, Sep 13, 2024 at 2:38?AM Kristian Evers via PROJ
> <proj at lists.osgeo.org> wrote:
>> 
>> PSC members,
>> 
>> No issues have been reported with either of the release candidates so I?ll
>> put their promotion to final releases up for a vote.
>> 
>> I?ll start with my +1.
>> 
>> /Kristian
>> 
>>> On 9 Sep 2024, at 14.01, Kristian Evers <kristianevers at gmail.com> wrote:
>>> 
>>> All,
>>> 
>>> in preparation for a new round of PROJ and PROJ-data release I have uploaded release candidates for both packages.
>>> 
>>> Download the archives here:
>>> 
>>> https://download.osgeo.org/proj/proj-9.5.0RC1.tar.gz
>>> https://download.osgeo.org/proj/proj-9.5.0RC1.zip
>>> 
>>> https://download.osgeo.org/proj/proj-data-1.19RC1.tar.gz
>>> https://download.osgeo.org/proj/proj-data-1.19RC1.zip
>>> 
>>> The PROJ release includes various updates and bug fixes. See the release notes below.
>>> 
>>> The PROJ-data release is updated with grids related to the Greenlandic GLMSL and GLLAT.
>>> 
>>> Please test the release candidates and report any issues you may find with them.
>>> Either here on the mailing list or on GitHub.
>>> 
>>> /Kristian
>>> 
>>> 
>>> ## 9.5.0
>>> 
>>> ### Updates
>>> 
>>> * Database: add constraint for unicity of CRS and operation names (#4071)
>>> 
>>> * Make a few more functions that accept a `PJ*` to actually acccept a `const PJ*` (#4074)
>>> 
>>> * Database: Increase consistency in trigger checks (#4080)
>>> 
>>> * Speed-up `+proj=cart +inv` (#4087)
>>> 
>>> * Added EPSG:9656 "Cartesian Grid Offsets" operation method, and imported related records (#4094)
>>> 
>>> * Add a `WKTParser::grammarErrorList()` method so that `proj_create_from_wkt()` can behave as documented (#4108)
>>> 
>>> * `CRS::stripVerticalComponent()`: Redirect it to `demoteTo2D(std::string(), nullptr)` (#4127)
>>> 
>>> * Add `proj_context_set_user_writable_directory()` to public API (#4144)
>>> 
>>> * CMake: for Windows builds, defaults PROJ DLL to be just `proj_${PROJ_MAJOR_VERSION}.dll` (#4167)
>>> 
>>> * Add `toWGS84AutocorrectWrongValues()` method and use it in PROJ.4 and WKT1 CRS import (#4172)
>>> 
>>> * WKT import: add support for Oracle WKT "Albers_Conical_Equal_Area" spelling (#4181)
>>> 
>>> * Limit number of C++ exceptions thrown & caught internally (#4183)
>>> 
>>> * Database: update to EPSG 11.016 (#4241)
>>> 
>>> * CMake: add option `EMBED_PROJ_DATA_PATH` (#4207)
>>> 
>>> * Add SEA Inverse projection (#4211)
>>> 
>>> * projinfo: Add 2 args equivalent to usage of `-s` and `-t` (#4218)
>>> 
>>> * CMake: add TESTING_USE_NETWORK configure option (#4220)
>>> 
>>> * Add `PROJ_ERR_COORD_TRANSFM_MISSING_TIME` and `proj_coordoperation_requires_per_coordinate_input_time()` (#4221)
>>> 
>>> * Add new Conversion "Local Orthographic" (#4228, #4229)
>>> 
>>> * Add data/ITRF2020 with ITRF2020 to ITRFother, and ITRF2020 plate motion models (#4235)
>>> 
>>> ### Bug Fixes
>>> 
>>> * Fix `imoll` and `imoll_o` zone calculations to correct inverse transformations near the "seams" (#4159)
>>> 
>>> * Fix wrong EPSG conversion code for UTM south (#4166)
>>> 
>>> * BoundCRS::exportToPROJ(): handle case of NADCON conus grid (#4168)
>>> 
>>> * `+proj=gridshift`: make projected grids work with `PROJ_NETWORK=ON` (#4174)
>>> 
>>> * `createOperations()`: make it work when transforming from/to a CompoundCRS with a DerivedVerticalCRS with ellipsoidal height (#4176)
>>> 
>>> * Support default context as `nullptr` in `CoordinateTransformer` (#4177)
>>> 
>>> * cct: emit error message and return error code when not being able to open input file (#4200)
>>> 
>>> * Fix race condition surrounding DB reopening during fork (#4231)
>>> 
>>> * `GeographicBoundingBox::create()`: accept degenerate bounding box reduced to a point or a line (#4237)
>>> 
>>> * `createOperation()`: tune so that ITRF2000->ETRS89 does not return only NKG grid based operations but also time-dependent Helmert (#4244)
>>> 
>>> 
>> 
>> _______________________________________________
>> PROJ mailing list
>> PROJ at lists.osgeo.org
>> https://lists.osgeo.org/mailman/listinfo/proj
> 
> 
> 
> -- 
> Charles Karney <karney at alum.mit.edu>
> 702 Prospect Ave
> Princeton, NJ 08540


From kristianevers at gmail.com  Sun Sep 15 05:19:58 2024
From: kristianevers at gmail.com (Kristian Evers)
Date: Sun, 15 Sep 2024 14:19:58 +0200
Subject: [PROJ] PROJ 9.5.0 & PROJ-data 1.19
Message-ID: <2F632389-4E9A-4D5A-BA27-496CC6627B51@gmail.com>

It?s my pleasure to announce the release of PROJ 9.5.0 and PROJ-data 1.19!

The PROJ release includes a number of updates, as well as a bug fixes.
See the release notes below.

The PROJ-data release adds grids for Greenlandic GLLAT and GLMSL CRS?s.

Download the archives here:

https://download.osgeo.org/proj/proj-9.5.0.tar.gz
https://download.osgeo.org/proj/proj-9.5.0.zip

https://download.osgeo.org/proj/proj-data-1.19.tar.gz
https://download.osgeo.org/proj/proj-data-1.19.zip

/Kristian

# 9.5.0

## Updates

* Database: add constraint for unicity of CRS and operation names (#4071)

* Make a few more functions that accept a `PJ*` to actually acccept a `const PJ*` (#4074)

* Database: Increase consistency in trigger checks (#4080)

* Speed-up `+proj=cart +inv` (#4087)

* Added EPSG:9656 "Cartesian Grid Offsets" operation method, and imported related records (#4094)

* Add a `WKTParser::grammarErrorList()` method so that `proj_create_from_wkt()` can behave as documented (#4108)

* `CRS::stripVerticalComponent()`: Redirect it to `demoteTo2D(std::string(), nullptr)` (#4127)

* Add `proj_context_set_user_writable_directory()` to public API (#4144)

* CMake: for Windows builds, defaults PROJ DLL to be just `proj_${PROJ_MAJOR_VERSION}.dll` (#4167)

* Add `toWGS84AutocorrectWrongValues()` method and use it in PROJ.4 and WKT1 CRS import (#4172)

* WKT import: add support for Oracle WKT "Albers_Conical_Equal_Area" spelling (#4181)

* Limit number of C++ exceptions thrown & caught internally (#4183)

* Database: update to EPSG 11.016 (#4241)

* CMake: add option `EMBED_PROJ_DATA_PATH` (#4207)

* Add SEA Inverse projection (#4211)

* projinfo: Add 2 args equivalent to usage of `-s` and `-t` (#4218)

* CMake: add TESTING_USE_NETWORK configure option (#4220)

* Add `PROJ_ERR_COORD_TRANSFM_MISSING_TIME` and `proj_coordoperation_requires_per_coordinate_input_time()` (#4221)

* Add new Conversion "Local Orthographic" (#4228, #4229)

* Add data/ITRF2020 with ITRF2020 to ITRFother, and ITRF2020 plate motion models (#4235)

## Bug Fixes

* Fix `imoll` and `imoll_o` zone calculations to correct inverse transformations near the "seams" (#4159)

* Fix wrong EPSG conversion code for UTM south (#4166)

* BoundCRS::exportToPROJ(): handle case of NADCON conus grid (#4168)

* `+proj=gridshift`: make projected grids work with `PROJ_NETWORK=ON` (#4174)

* `createOperations()`: make it work when transforming from/to a CompoundCRS with a DerivedVerticalCRS with ellipsoidal height (#4176)

* Support default context as `nullptr` in `CoordinateTransformer` (#4177)

* cct: emit error message and return error code when not being able to open input file (#4200)

* Fix race condition surrounding DB reopening during fork (#4231)

* `GeographicBoundingBox::create()`: accept degenerate bounding box reduced to a point or a line (#4237)

* `createOperation()`: tune so that ITRF2000->ETRS89 does not return only NKG grid based operations but also time-dependent Helmert (#4244)


From gdt at lexort.com  Sun Sep 15 17:29:54 2024
From: gdt at lexort.com (Greg Troxel)
Date: Sun, 15 Sep 2024 20:29:54 -0400
Subject: [PROJ] geodtest/planimeter test failure
In-Reply-To: <8fceb315-e379-4f76-a041-7b166c4aa508@alum.mit.edu> (Charles
 Karney's message of "Sat, 14 Sep 2024 20:28:40 -0400")
References: <rmied5mdrc4.fsf@s1.lexort.com>
 <8fceb315-e379-4f76-a041-7b166c4aa508@alum.mit.edu>
Message-ID: <rmibk0o8mpp.fsf@s1.lexort.com>

Charles Karney <charles.karney at gmail.com> writes:

> I recommend you start with the sin(-90) != -1 failure.  In particular
> can you check the inputs
>
>   x, (double)qd
>
> and outputs
>
>   r, q
>
> of the call to remquo in sincosdx in geodesic.c line 179.  Buggy
> implementations of remquo have been a problem in the past.

You are spot on; my libm remquo is buggy.  I'm working on fixing that,
and then will see what remains.

(Thus far, I have received no reports of proj tests passing on a
platform other than linux/mac/windows.)

From j1 at jimenezshaw.com  Mon Sep 16 03:01:19 2024
From: j1 at jimenezshaw.com (Javier Jimenez Shaw)
Date: Mon, 16 Sep 2024 12:01:19 +0200
Subject: [PROJ] robots.txt
Message-ID: <CADRrdKuO7AiSa1RhAztAUPXi_A2_qVAgQ1jdA64Dq17y7Jk7Pw@mail.gmail.com>

Hi

In proj.org/robots.txt there is currently this
User-agent: *

Disallow: # Allow everything

Sitemap: https://proj.org/sitemap.xml

while in gdal.org/robots.txt this
User-agent: *
Allow: /en/latest/
Disallow: /en/

That means that any robot is indexing aaaall the proj pages, including old
versions (I checked it in Google Console).

Should we do the same in PROJ as in GDAL?

Cheers,
Javier.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240916/1362e5b2/attachment.htm>

From luis.de.sousa at protonmail.ch  Mon Sep 16 04:18:59 2024
From: luis.de.sousa at protonmail.ch (=?utf-8?Q?Lu=C3=AD=C2=ADs_Moreira_de_Sousa?=)
Date: Mon, 16 Sep 2024 11:18:59 +0000
Subject: [PROJ] Central longitude & latitude of origin in ISEA projection
In-Reply-To: <438212e7-0ba2-4067-ad6c-0f9de529b6d7@ecere.com>
References: <438212e7-0ba2-4067-ad6c-0f9de529b6d7@ecere.com>
Message-ID: <zcANJnvE4HE2lCRaB_ak-5oUBEQszHGhsD_w9X2j-2h3ERNzBtR1eEB6RNehvJi731zGlKG0ZCan0YB0EjD4rIPCLxT_BgefcO50lvYfMsw=@protonmail.ch>

Hi J?r?me,

I went reading again the ISEA documentation, I arrive at a different interpretation. lat_0 and lon_0 are the latitude/longitude of natural origin, there is no objective assumption of these representing a central point of projection. The document also states that the exact interpretation of these parameters depends on the projection implementation itself.

There are various other projections with more than one central point, at least all those with interruptions. The parameters lat_0 and lon_0 apply in similar fashion to these. Therefore any change in the meaning of these parameters must also apply to those other projections with interruptions. I see no need to treat ISEA as a special case in this context.

On the same logic, I do not agree with the assertion on the user having to guess the origin in the cartesian space. There are also the false easting / false northing parameters to aid in this aspect.
Regards.

--
Lu?s Moreira de Sousa
Mastodon: https://mastodon.social/@luis_de_sousa
URL: https://ldesousa.codeberg.page

Sent with [Proton Mail](https://proton.me/) secure email.

On Sunday, 15 September 2024 at 02:45, J?r?me St-Louis via PROJ <proj at lists.osgeo.org> wrote:

> Dear Even, All,
>
> I am questioning the current meaning of Central longitude & latitude of origin (lat_0, lon_0) in the ISEA projection.
>
> From what I can see in the code, the +lat_0 and +lon_0 are being stored in Q->o_lat, Q->o_lon:
>
> https://github.com/OSGeo/PROJ/blob/master/src/projections/isea.cpp#L1027
>
> However, these values are also used as the coordinates of the first icosahedron vertex, when using the +orient parameter, which really should have absolutely nothing to do with the concepts of central longitude & latitude of origin in my opinion:
>
> https://github.com/OSGeo/PROJ/blob/master/src/projections/isea.cpp#L604
>
> So it seems like currently, +lat_0 and +lon_0 allow to specify an orientation other than the polar or standard orientation that can be selected with +orient.
> Selecting both would have +orient override the +lat_0 and +lon_0 values.
>
> This is really not obvious (I just realized this now), and I would think it is a misuse of the central latitude/longitude of origin concepts.
> The latitude / longitude of origin are normally associated with less distortion, but distortion is worst in ISEA at the icosahedron vertices, and it'd definitely not "central" either.
>
> What would make sense to me as the central longitude & latitude of origin would be which latitude & longitude is projected to the 0, 0 projected coordinates.
>
> This is currently the point at half the height and half the width of the icosahedron triangle containing South Africa, which is exactly in the middle of the [projection](https://maps.gnosis.earth/ogcapi/collections/gebco/map?crs=OGC:1534) if you exclude the bottom-right rhombus (containing part of New Zealand's north island and Hawaii) making the projection horizontally symmetrical.
>
> I think currently the only way to change this is by specifying false easting & northing with +x_0 and +y_0 in projected coordinates.
>
> Would it make sense / be possible to:
>
> - Introduce new parameters allowing to specify a custom coordinate of the first icosahedron vertex e.g, +orient_lat and +orient_lon
> - Change the meaning of +lat_0 and +lon_0 to be the geographic latitude corresponding to 0, 0 in projected coordinates, documenting that the default value is -30.0945296301? N, 11.25 E (authalic latitude)
>
> This would be a breaking change only for cases where +lat_0 and or +lon_0 is currently being used to position the first icosahedron vertex.
> Given that the documentation does not hint at that in any way, I doubt anyone is using these for that purpose.
>
> Once the authalic / geodetic conversion is in place when using an oblate spheroid ellipsoid, I think +orient_lat and +lat_0 would be assumed to be in geodetic coordinates (rather than authalic).
>
> These changes would also help clarify what is 0,0 with the default +proj=isea, which currently is quite a mystery which users need to figure out by themselves.
>
> It would also make it easier to put 0,0 at the vertex West of Alaska as we do for the OGC:1534 CRS that we're trying to define.
>
> Thank you!
>
> Kind regards,
>
> -Jerome
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240916/da3366c7/attachment.htm>

From jerome at ecere.com  Mon Sep 16 05:13:59 2024
From: jerome at ecere.com (=?UTF-8?B?SsOpcsO0bWUgU3QtTG91aXM=?=)
Date: Mon, 16 Sep 2024 08:13:59 -0400
Subject: [PROJ] Central longitude & latitude of origin in ISEA projection
In-Reply-To: <zcANJnvE4HE2lCRaB_ak-5oUBEQszHGhsD_w9X2j-2h3ERNzBtR1eEB6RNehvJi731zGlKG0ZCan0YB0EjD4rIPCLxT_BgefcO50lvYfMsw=@protonmail.ch>
References: <438212e7-0ba2-4067-ad6c-0f9de529b6d7@ecere.com>
 <zcANJnvE4HE2lCRaB_ak-5oUBEQszHGhsD_w9X2j-2h3ERNzBtR1eEB6RNehvJi731zGlKG0ZCan0YB0EjD4rIPCLxT_BgefcO50lvYfMsw=@protonmail.ch>
Message-ID: <08a29025-93a2-4473-a6e4-ec6c25bd6c38@ecere.com>

Hi Luis,

Thanks for the input.

> lat_0 and lon_0 are the latitude/longitude of natural origin,

> The document also states that the exact interpretation of these 
> parameters depends on the projection implementation itself.

I understand that, but the current interpretation for the ISEA 
projection is a very specific meaning which in my opinion has nothing to 
do with the use of /lat_0/ or /lon_0/ in any other projections.

Specifically, the current interpretation is related to the placement of 
the first vertex of the icosahedron.

Could you point out one of these projection with interruptions where you 
think the interpretation is similar?

For these? classic interrupted projection:

https://proj.org/en/stable/operations/projections/imoll.html

https://proj.org/en/9.4/operations/projections/igh.html

/lon_0/ is the central meridian in the middle of the map.

Furthermore, this interpretation clashes with the /+orient/ parameter, 
and the documentation is not clear at all about what it does or about 
the relationship between /+lat_0/ /+lon_0/ and /+orient/.
This is why I propose to rename these /+orient_lat/ and /+orient_lon/, 
where the overlap would be obvious.

> Therefore any change in the meaning of these parameters must also 
> apply to those other projections with interruptions.
In my opinion, from analyzing the code (not the documentation that just 
uses the generic description of lat_0 and lon_0), the current 
interpretation has nothing to do with the use of /lat_0/ and /lon_0/ in 
any other projection in PROJ.

Happy to get together virtually to try to explain better in case I am 
not being clear.

In the vast majority of cases, lat_0, lon_0 correspond to the center of 
the projection. In OGC API maps, these are generally mapped to the 
/crs-proj-center/ query parameter, except if /lat_ts/ is defined in 
which case that takes priority
(see Custom Projection CRS 18.2.3 
<https://docs.ogc.org/is/20-058/20-058.html#_d71deb2d-553e-4302-bd6e-a1eeea248581>).

> On the same logic, I do not agree with the assertion on the user 
> having to guess the origin in the cartesian space. There are also the 
> false easting / false northing parameters to aid in this aspect.
Yes, +x_0 and +y_0 allows to shift the origin, but these need to be 
specified in projected coordinates, which is? more complicated than 
specifying the geodetic coordinates.

You can of course use the forward transformation of the geodetic 
coordinate, then use the negated output of that as the false easting / 
northing, but this is a 2-step process, and if the accuracy of the 
projection implementation is improved, the easting / northing obtained 
earlier are no longer accurate.

Kind regards,

-Jerome

On 9/16/24 7:18 AM, Lu? s Moreira de Sousa wrote:
> Hi J?r?me,
>
> I went reading again the ISEA documentation, I arrive at a different 
> interpretation. lat_0 and lon_0 are the latitude/longitude of natural 
> origin, there is no objective assumption of these representing a 
> central point of projection. The document also states that the exact 
> interpretation of these parameters depends on the projection 
> implementation itself.
>
> There are various other projections with more than one central point, 
> at least all those with interruptions. The parameters lat_0 and lon_0 
> apply in similar fashion to these. Therefore any change in the meaning 
> of these parameters must also apply to those other projections with 
> interruptions. I see no need to treat ISEA as a special case in this 
> context.
>
> On the same logic, I do not agree with the assertion on the user 
> having to guess the origin in the cartesian space. There are also the 
> false easting / false northing parameters to aid in this aspect.
>
> Regards.
>
> -- 
> Lu?s Moreira de Sousa
> Mastodon: https://mastodon.social/@luis_de_sousa
> URL: https://ldesousa.codeberg.page
>
> Sent with Proton Mail <https://proton.me/> secure email.
>
> On Sunday, 15 September 2024 at 02:45, J?r?me St-Louis via PROJ 
> <proj at lists.osgeo.org> wrote:
>>
>> Dear Even, All,
>>
>> I am questioning the current meaning of /Central longitude & latitude 
>> of origin/ (/lat_0/, /lon_0/) in the ISEA projection.
>>
>> From what I can see in the code, the /+lat_0/ and /+lon_0/ are being 
>> stored in /Q->o_lat/, /Q->o_lon/:
>>
>> https://github.com/OSGeo/PROJ/blob/master/src/projections/isea.cpp#L1027
>>
>> However, these values are also used as the coordinates of the first 
>> icosahedron vertex, when using the /+orient/ parameter, which really 
>> should have absolutely nothing to do with the concepts of central 
>> longitude & latitude of origin in my opinion:
>>
>> https://github.com/OSGeo/PROJ/blob/master/src/projections/isea.cpp#L604
>>
>> So it seems like currently, /+lat_0/ and /+lon_0/ allow to specify an 
>> orientation other than the polar or standard orientation that can be 
>> selected with /+orient/.
>> Selecting both would have /+orient/ override the /+lat_0/ and 
>> /+lon_0/ values.
>>
>> This is really not obvious (I just realized this now), and I would 
>> think it is a misuse of the central latitude/longitude of origin 
>> concepts.
>> The latitude / longitude of origin are normally associated with less 
>> distortion, but distortion is worst in ISEA at the icosahedron 
>> vertices, and it'd definitely not "central" either.
>>
>> What would make sense to me as the /central longitude & latitude of 
>> origin/ would be which latitude & longitude is projected to the 0, 0 
>> projected coordinates.
>>
>> This is currently the point at half the height and half the width of 
>> the icosahedron triangle containing South Africa, which is exactly in 
>> the middle of the projection 
>> <https://maps.gnosis.earth/ogcapi/collections/gebco/map?crs=OGC:1534> 
>> if you exclude the bottom-right rhombus (containing part of New 
>> Zealand's north island and Hawaii) making the projection horizontally 
>> symmetrical.
>>
>> I think currently the only way to change this is by specifying false 
>> easting & northing with /+x_0/ and /+y_0/ in projected coordinates.
>>
>> Would it make sense / be possible to:
>>
>> - Introduce new parameters allowing to specify a custom coordinate of 
>> the first icosahedron vertex e.g, /+orient_lat/ and /+orient_lon
>> - /Change the meaning of /+lat_0/ and /+lon_0/ to be the geographic 
>> latitude corresponding to 0, 0 in projected coordinates, documenting 
>> that the default value is -30.0945296301? N, 11.25 E (authalic latitude)
>>
>> This would be a breaking change only for cases where /+lat_0/ and or 
>> /+lon_0/ is currently being used to position the first icosahedron 
>> vertex.
>> Given that the documentation does not hint at that in any way, I 
>> doubt anyone is using these for that purpose.
>>
>> Once the authalic / geodetic conversion is in place when using an 
>> oblate spheroid ellipsoid, I think /+orient_lat/ and /+lat_0/ would 
>> be assumed to be in geodetic coordinates (rather than authalic).
>>
>> These changes would also help clarify what is 0,0 with the default 
>> /+proj=isea/, which currently is quite a mystery which users need to 
>> figure out by themselves.
>>
>> It would also make it easier to put 0,0 at the vertex West of Alaska 
>> as we do for the OGC:1534 CRS that we're trying to define.
>>
>> Thank you!
>>
>> Kind regards,
>>
>> -Jerome
>>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240916/81dad61f/attachment-0001.htm>

From j1 at jimenezshaw.com  Tue Sep 17 05:40:15 2024
From: j1 at jimenezshaw.com (Javier Jimenez Shaw)
Date: Tue, 17 Sep 2024 14:40:15 +0200
Subject: [PROJ] nadcon5 overtaken by ESRI?
Message-ID: <CADRrdKtrswBzZFnYpKbG1P43J2ixN2T99vfv2VWemoSuq-rwqA@mail.gmail.com>

Hi

I found a "strange" behaviour about EPSG, ESRI and nadcon5, that I do not
know if we are aware of.

Running the next command
PROJ_NETWORK=ON ./projinfo -s EPSG:4269 -t EPSG:6318 --3d -o proj
--spatial-test intersects

I get in PROJ 9.4.1

Candidate operations found: 5
-------------------------------------
Operation No. 1:

DERIVED_FROM(EPSG):8971, NAD83 to NAD83(2011) (1), 1.0 m, United States
(USA) - offshore Gulf of Mexico outer continental shelf (GoM OCS) -
protraction areas South Padre Island; North Padre Island; Mustan
g Island; Matagorda Island; Brazos; Galveston; High Island; Sabine Pass;
West Cameron; East Cameron; Vermilion; South Marsh Island; Eugene Island;
Ship Shoal; South Pelto; Bay Marchand; South Timbalier; G
rand Isle; West Delta; South Pass; Main Pass; Breton Sound; Chandeleur;
Corpus Christi; Port Isabel; East Breaks; Alaminos Canyon; Garden Banks;
Keathley Canyon; Sigsbee Escarpment; Ewing Bank; Green Cany
on; Walker Ridge; Amery Terrace; Mobile; Viosca Knoll; Mississippi Canyon;
Atwater Valley; Lund; Lund South; Pensacola; Destin Dome; De Soto Canyon;
Lloyd Ridge; Henderson; Florida Plain; Campeche Escarpm
ent; Apalachicola; Florida Middle Ground; The Elbow; Vernon Basin; Howell
Hook; Rankin; Gainesville; Tarpon Springs; St Petersburg; Charlotte Harbor;
Pulley Ridge; Dry Tortugas; Tortugas Valley; Miami; Key West.

PROJ string:
+proj=noop

-------------------------------------
Operation No. 2:

unknown id, NAD83 to NAD83(HARN) (47) + NAD83(HARN) to NAD83(FBN) (1) +
NAD83(FBN) to NAD83(NSRS2007) (1) + NAD83(NSRS2007) to NAD83(2011) (1), 0.2
m, United States (USA) - CONUS onshore - Alabama; Arizon
a; Arkansas; California; Colorado; Connecticut; Delaware; Florida; Georgia;
Idaho; Illinois; Indiana; Iowa; Kansas; Kentucky; Louisiana; Maine;
Maryland; Massachusetts; Michigan; Minnesota; Mississippi; M
issouri; Montana; Nebraska; Nevada; New Hampshire; New Jersey; New Mexico;
New York; North Carolina; North Dakota; Ohio; Oklahoma; Oregon;
Pennsylvania; Rhode Island; South Carolina; South Dakota; Tenness
ee; Texas; Utah; Vermont; Virginia; Washington; West Virginia; Wisconsin;
Wyoming. US Gulf of Mexico offshore continental shelf (GoM OCS)., at least
one grid missing

PROJ string:
+proj=pipeline
  +step +proj=axisswap +order=2,1
  +step +proj=unitconvert +xy_in=deg +z_in=m +xy_out=rad +z_out=m
  +step +proj=gridshift
+grids=us_noaa_nadcon5_nad83_1986_nad83_harn_conus.tif
  +step +proj=gridshift
+grids=us_noaa_nadcon5_nad83_harn_nad83_fbn_conus.tif
  +step +proj=gridshift
+grids=us_noaa_nadcon5_nad83_fbn_nad83_2007_conus.tif
  +step +proj=gridshift
+grids=us_noaa_nadcon5_nad83_2007_nad83_2011_conus.tif
  +step +proj=unitconvert +xy_in=rad +z_in=m +xy_out=deg +z_out=m
  +step +proj=axisswap +order=2,1
...

While in PROJ 9.5.0 I get

Candidate operations found: 180
-------------------------------------
Operation No. 1:

unknown id, Null geographic offset from NAD83 to North_American_1983_3D +
Null geographic offset from North_American_1983_3D to NAD83 + Inverse of
WGS_1984_(ITRF00)_To_NAD_1983 + WGS_1984_(ITRF08)_To_NAD_1983_2011 + Null
geographic offset from NAD83(2011) (geog2D) to NAD83(2011) (geog3D), 0.13
m, Puerto Rico - onshore and offshore. United States (USA) onshore and
offshore - Alabama; Alaska; Arizona; Arkansas; California; Colorado;
Connecticut; Delaware; Florida; Georgia; Idaho; Illinois; Indiana; Iowa;
Kansas; Kentucky; Louisiana; Maine; Maryland; Massachusetts; Michigan;
Minnesota; Mississippi; Missouri; Montana; Nebraska; Nevada; New Hampshire;
New Jersey; New Mexico; New York; North Carolina; North Dakota; Ohio;
Oklahoma; Oregon; Pennsylvania; Rhode Island; South Carolina; South Dakota;
Tennessee; Texas; Utah; Vermont; Virginia; Washington; West Virginia;
Wisconsin; Wyoming. US Virgin Islands - onshore and offshore.

PROJ string:
+proj=pipeline
  +step +proj=axisswap +order=2,1
  +step +proj=unitconvert +xy_in=deg +xy_out=rad
  +step +proj=push +v_3
  +step +proj=cart +ellps=GRS80
  +step +inv +proj=helmert +x=0.9956 +y=-1.9013 +z=-0.5215 +rx=0.025915
        +ry=0.009426 +rz=0.011599 +s=0.00062 +convention=coordinate_frame
  +step +proj=helmert +x=0.99343 +y=-1.90331 +z=-0.52655 +rx=0.02591467
        +ry=0.00942645 +rz=0.01159935 +s=0.00171504
+convention=coordinate_frame
  +step +inv +proj=cart +ellps=GRS80
  +step +proj=pop +v_3
  +step +proj=unitconvert +xy_in=rad +z_in=m +xy_out=deg +z_out=m
  +step +proj=axisswap +order=2,1
...

Based on the names in the operation description, this seems to be from
ESRI. The first from EPSG appears at position 8.

If I try to do actual transformations, this is what I get with PROJ 9.4.1
$ echo "40 -100" | PROJ_NETWORK=ON ./cs2cs EPSG:4269 EPSG:6343 -d 6 --3d
414639.611409 4428235.937716 -0.004468
$ echo "40 -100" | PROJ_NETWORK=ON ./cs2cs EPSG:4269 EPSG:6318 -d 6 --3d
39.999999 -99.999999 -0.004468
$ echo "40 -100" | PROJ_NETWORK=ON ./cs2cs EPSG:4269 EPSG:6318 -d 6 --3d |
./cs2cs EPSG:6318 EPSG:6343 -d 6 --3d
414639.622273 4428235.952568 -0.004468

And this with PROJ 9.5.0
$ echo "40 -100" | PROJ_NETWORK=ON ./cs2cs EPSG:4269 EPSG:6343 -d 6 --3d
414639.611409 4428235.937716 -0.004468
$ echo "40 -100" | PROJ_NETWORK=ON ./cs2cs EPSG:4269 EPSG:6318 -d 6 --3d
40.000000 -100.000000 0.000000
$ echo "40 -100" | PROJ_NETWORK=ON ./cs2cs EPSG:4269 EPSG:6318 -d 6 --3d |
./cs2cs EPSG:6318 EPSG:6343 -d 6 --3d
414639.538157 4428236.064519 0.000000

What is the reason exactly? Is that expected?

Thanks
Javier
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240917/ec2ef320/attachment.htm>

From Jochem.Lesparre at kadaster.nl  Tue Sep 17 07:16:43 2024
From: Jochem.Lesparre at kadaster.nl (Lesparre, Jochem)
Date: Tue, 17 Sep 2024 14:16:43 +0000
Subject: [PROJ] Dealing with epoch and transformations
In-Reply-To: <rmiikvrbhxr.fsf@s1.lexort.com>
References: <CADRrdKtyZMLVSjY7JFEE6uL0xmhXKpw8tBLKhGhnw+HsQ_b=dQ@mail.gmail.com>
 <rmiikvrbhxr.fsf@s1.lexort.com>
Message-ID: <AS8P192MB223828BCB31A8216B5126185EF612@AS8P192MB2238.EURP192.PROD.OUTLOOK.COM>

> My somewhat hazy understanding is that ITRF2020 without a specified epoch means 2015.0.

I would say ITRF2020 without a specified epoch is undefined, but the reference epoch 2015.00 is sometimes also used as default epoch in software. Which is a poor choice for data that is current epoch, because ITRF2020 wasn't even published in 2015. So, a default epoch like 2025.00 would give more accurate results.

Jochem



Disclaimer:
De inhoud van deze e-mail is vertrouwelijk en uitsluitend bestemd voor de geadresseerde(n).
Gebruik, openbaarmaking, vermenigvuldiging, verspreiding en/of verstrekking van deze informatie aan derden is niet toegestaan.
Op al onze producten en diensten zijn onze algemene leveringsvoorwaarden van toepassing
[https://www.kadaster.nl/algemene-leveringsvoorwaarden].

Disclaimer:
This email and any files transmitted with it are confidential and intended solely for the use of the individual or entity to whom they are addressed.
If you are not the intended recipient, you are notified that disclosing, copying, distributing or taking any action in reliance on the contents of this information is strictly prohibited.
Our general terms and conditions of delivery apply to all our products and services
[https://www.kadaster.com/general-terms-and-conditions].

From even.rouault at spatialys.com  Tue Sep 17 07:26:08 2024
From: even.rouault at spatialys.com (Even Rouault)
Date: Tue, 17 Sep 2024 16:26:08 +0200
Subject: [PROJ] nadcon5 overtaken by ESRI?
In-Reply-To: <CADRrdKtrswBzZFnYpKbG1P43J2ixN2T99vfv2VWemoSuq-rwqA@mail.gmail.com>
References: <CADRrdKtrswBzZFnYpKbG1P43J2ixN2T99vfv2VWemoSuq-rwqA@mail.gmail.com>
Message-ID: <30019d04-c9b2-4ee8-91a5-ae2b17c62f06@spatialys.com>

Javier,

fix and analysis in https://github.com/OSGeo/PROJ/pull/4252

Even

Le 17/09/2024 ? 14:40, Javier Jimenez Shaw via PROJ a ?crit?:
> Hi
>
> I found a "strange" behaviour about EPSG, ESRI and nadcon5, that I do 
> not know if we are aware of.
>
> Running the next command
> PROJ_NETWORK=ON ./projinfo -s EPSG:4269 -t EPSG:6318 --3d -o proj 
> --spatial-test intersects
>
> I get in PROJ 9.4.1
>
> Candidate operations found: 5
> -------------------------------------
> Operation No. 1:
>
> DERIVED_FROM(EPSG):8971, NAD83 to NAD83(2011) (1), 1.0 m, United 
> States (USA) - offshore Gulf of Mexico outer continental shelf (GoM 
> OCS) - protraction areas South Padre Island; North Padre Island; Mustan
> g Island; Matagorda Island; Brazos; Galveston; High Island; Sabine 
> Pass; West Cameron; East Cameron; Vermilion; South Marsh Island; 
> Eugene Island; Ship Shoal; South Pelto; Bay Marchand; South Timbalier; G
> rand Isle; West Delta; South Pass; Main Pass; Breton Sound; 
> Chandeleur; Corpus Christi; Port Isabel; East Breaks; Alaminos Canyon; 
> Garden Banks; Keathley Canyon; Sigsbee Escarpment; Ewing Bank; Green Cany
> on; Walker Ridge; Amery Terrace; Mobile; Viosca Knoll; Mississippi 
> Canyon; Atwater Valley; Lund; Lund South; Pensacola; Destin Dome; De 
> Soto Canyon; Lloyd Ridge; Henderson; Florida Plain; Campeche Escarpm
> ent; Apalachicola; Florida Middle Ground; The Elbow; Vernon Basin; 
> Howell Hook; Rankin; Gainesville; Tarpon Springs; St Petersburg; 
> Charlotte Harbor; Pulley Ridge; Dry Tortugas; Tortugas Valley; Miami; 
> Key West.
>
> PROJ string:
> +proj=noop
>
> -------------------------------------
> Operation No. 2:
>
> unknown id, NAD83 to NAD83(HARN) (47) + NAD83(HARN) to NAD83(FBN) (1) 
> + NAD83(FBN) to NAD83(NSRS2007) (1) + NAD83(NSRS2007) to NAD83(2011) 
> (1), 0.2 m, United States (USA) - CONUS onshore - Alabama; Arizon
> a; Arkansas; California; Colorado; Connecticut; Delaware; Florida; 
> Georgia; Idaho; Illinois; Indiana; Iowa; Kansas; Kentucky; Louisiana; 
> Maine; Maryland; Massachusetts; Michigan; Minnesota; Mississippi; M
> issouri; Montana; Nebraska; Nevada; New Hampshire; New Jersey; New 
> Mexico; New York; North Carolina; North Dakota; Ohio; Oklahoma; 
> Oregon; Pennsylvania; Rhode Island; South Carolina; South Dakota; Tenness
> ee; Texas; Utah; Vermont; Virginia; Washington; West Virginia; 
> Wisconsin; Wyoming. US Gulf of Mexico offshore continental shelf (GoM 
> OCS)., at least one grid missing
>
> PROJ string:
> +proj=pipeline
> ? +step +proj=axisswap +order=2,1
> ? +step +proj=unitconvert +xy_in=deg +z_in=m +xy_out=rad +z_out=m
> ? +step +proj=gridshift 
> +grids=us_noaa_nadcon5_nad83_1986_nad83_harn_conus.tif
> ? +step +proj=gridshift 
> +grids=us_noaa_nadcon5_nad83_harn_nad83_fbn_conus.tif
> ? +step +proj=gridshift 
> +grids=us_noaa_nadcon5_nad83_fbn_nad83_2007_conus.tif
> ? +step +proj=gridshift 
> +grids=us_noaa_nadcon5_nad83_2007_nad83_2011_conus.tif
> ? +step +proj=unitconvert +xy_in=rad +z_in=m +xy_out=deg +z_out=m
> ? +step +proj=axisswap +order=2,1
> ...
>
> While in PROJ 9.5.0 I get
>
> Candidate operations found: 180
> -------------------------------------
> Operation No. 1:
>
> unknown id, Null geographic offset from NAD83 to 
> North_American_1983_3D + Null geographic offset from 
> North_American_1983_3D to NAD83 + Inverse of 
> WGS_1984_(ITRF00)_To_NAD_1983 + WGS_1984_(ITRF08)_To_NAD_1983_2011 + 
> Null geographic offset from NAD83(2011) (geog2D) to NAD83(2011) 
> (geog3D), 0.13 m, Puerto Rico - onshore and offshore. United States 
> (USA) onshore and offshore - Alabama; Alaska; Arizona; Arkansas; 
> California; Colorado; Connecticut; Delaware; Florida; Georgia; Idaho; 
> Illinois; Indiana; Iowa; Kansas; Kentucky; Louisiana; Maine; Maryland; 
> Massachusetts; Michigan; Minnesota; Mississippi; Missouri; Montana; 
> Nebraska; Nevada; New Hampshire; New Jersey; New Mexico; New York; 
> North Carolina; North Dakota; Ohio; Oklahoma; Oregon; Pennsylvania; 
> Rhode Island; South Carolina; South Dakota; Tennessee; Texas; Utah; 
> Vermont; Virginia; Washington; West Virginia; Wisconsin; Wyoming. US 
> Virgin Islands - onshore and offshore.
>
> PROJ string:
> +proj=pipeline
> ? +step +proj=axisswap +order=2,1
> ? +step +proj=unitconvert +xy_in=deg +xy_out=rad
> ? +step +proj=push +v_3
> ? +step +proj=cart +ellps=GRS80
> ? +step +inv +proj=helmert +x=0.9956 +y=-1.9013 +z=-0.5215 +rx=0.025915
> ? ? ? ? +ry=0.009426 +rz=0.011599 +s=0.00062 +convention=coordinate_frame
> ? +step +proj=helmert +x=0.99343 +y=-1.90331 +z=-0.52655 +rx=0.02591467
> ? ? ? ? +ry=0.00942645 +rz=0.01159935 +s=0.00171504 
> +convention=coordinate_frame
> ? +step +inv +proj=cart +ellps=GRS80
> ? +step +proj=pop +v_3
> ? +step +proj=unitconvert +xy_in=rad +z_in=m +xy_out=deg +z_out=m
> ? +step +proj=axisswap +order=2,1
> ...
>
> Based on the names in the operation description, this seems to be from 
> ESRI. The first from EPSG appears at position 8.
>
> If I try to do actual transformations, this is what I get with PROJ 9.4.1
> $ echo "40 -100" | PROJ_NETWORK=ON ./cs2cs EPSG:4269 EPSG:6343 -d 6 --3d
> 414639.611409 4428235.937716 -0.004468
> $ echo "40 -100" | PROJ_NETWORK=ON ./cs2cs EPSG:4269 EPSG:6318 -d 6 --3d
> 39.999999 -99.999999 -0.004468
> $ echo "40 -100" | PROJ_NETWORK=ON ./cs2cs EPSG:4269 EPSG:6318 -d 6 
> --3d | ./cs2cs EPSG:6318 EPSG:6343 -d 6 --3d
> 414639.622273 4428235.952568 -0.004468
>
> And this with PROJ 9.5.0
> $ echo "40 -100" | PROJ_NETWORK=ON ./cs2cs EPSG:4269 EPSG:6343 -d 6 --3d
> 414639.611409 4428235.937716 -0.004468
> $ echo "40 -100" | PROJ_NETWORK=ON ./cs2cs EPSG:4269 EPSG:6318 -d 6 --3d
> 40.000000 -100.000000 0.000000
> $ echo "40 -100" | PROJ_NETWORK=ON ./cs2cs EPSG:4269 EPSG:6318 -d 6 
> --3d | ./cs2cs EPSG:6318 EPSG:6343 -d 6 --3d
> 414639.538157 4428236.064519 0.000000
>
> What is the reason exactly? Is that expected?
>
> Thanks
> Javier
>
> _______________________________________________
> PROJ mailing list
> PROJ at lists.osgeo.org
> https://lists.osgeo.org/mailman/listinfo/proj

-- 
http://www.spatialys.com
My software is free, but my time generally not.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240917/ea14bb24/attachment-0001.htm>

From gdt at lexort.com  Tue Sep 17 14:49:49 2024
From: gdt at lexort.com (Greg Troxel)
Date: Tue, 17 Sep 2024 17:49:49 -0400
Subject: [PROJ] Dealing with epoch and transformations
In-Reply-To: <AS8P192MB223828BCB31A8216B5126185EF612@AS8P192MB2238.EURP192.PROD.OUTLOOK.COM>
 (Jochem Lesparre's message of "Tue, 17 Sep 2024 14:16:43 +0000")
References: <CADRrdKtyZMLVSjY7JFEE6uL0xmhXKpw8tBLKhGhnw+HsQ_b=dQ@mail.gmail.com>
 <rmiikvrbhxr.fsf@s1.lexort.com>
 <AS8P192MB223828BCB31A8216B5126185EF612@AS8P192MB2238.EURP192.PROD.OUTLOOK.COM>
Message-ID: <rmi7cba0x36.fsf@s1.lexort.com>

"Lesparre, Jochem" <Jochem.Lesparre at kadaster.nl> writes:

>> My somewhat hazy understanding is that ITRF2020 without a specified
>> epoch means 2015.0.
>
> I would say ITRF2020 without a specified epoch is undefined, but the
> reference epoch 2015.00 is sometimes also used as default epoch in
> software. Which is a poor choice for data that is current epoch,
> because ITRF2020 wasn't even published in 2015. So, a default epoch
> like 2025.00 would give more accurate results.

Is there any real support for picking some year not the reference epoch?
I can see treating ITRF2020 data without an epoch as either

  of the reference epoch, or

  an error, meaning an expecption is thrown and no results returned

This would be for to ITRF2020 or from.

And, if we pick the second option, we should do the same for each WGS84
realization (except maybe TRANSIT on the NA plate), and further reject
data in the ensemble.

I therefore think the only reasonable plan is to treat it as being of
the reference epoch, which is what I think proj is doing now.

I think it would take a very strong argument to pick a different default
epoch.

From Jochem.Lesparre at kadaster.nl  Tue Sep 17 23:41:41 2024
From: Jochem.Lesparre at kadaster.nl (Lesparre, Jochem)
Date: Wed, 18 Sep 2024 06:41:41 +0000
Subject: [PROJ] Dealing with epoch and transformations
In-Reply-To: <rmi7cba0x36.fsf@s1.lexort.com>
References: <CADRrdKtyZMLVSjY7JFEE6uL0xmhXKpw8tBLKhGhnw+HsQ_b=dQ@mail.gmail.com>
 <rmiikvrbhxr.fsf@s1.lexort.com>
 <AS8P192MB223828BCB31A8216B5126185EF612@AS8P192MB2238.EURP192.PROD.OUTLOOK.COM>
 <rmi7cba0x36.fsf@s1.lexort.com>
Message-ID: <DU2P192MB2235B6C2EA666E02B4C01E8AEF622@DU2P192MB2235.EURP192.PROD.OUTLOOK.COM>

Besides command line PROJ, I don't think there is much software that supports time-dependent transformations. Or does ArcGIS support this now? I heard they were working on it. It will probably take a long time and a lot of effort to raise awareness before time-dependent transformations become common practice in geo-information. So, we need a default epoch for such transformations.

The most practical default epoch would be in the middle of the expected lifetime of a realisation (for ITRF2014 this would be between the publication date of ITRF2014 and the publication date of ITRF2020). However, the publications of ITRS and WGS 84 realisations do not have a regular interval. So, there is no real way to predict the lifespan of a realisation. Ideally, IAG would choose a suitable default epoch by publishing ITRS realisations with a reference epoch in the future instead of in the past. Such extrapolation might feel a bit unscientific for IAG, so maybe some other organisation will have to come up with recommendations for more practical default epochs. I do not think PROJ should make this decision. So, I agree with you that using the reference epoch, like PROJ does, is the most reasonable thing to do for the moment.

I hope to discuss the need for a joint European strategy for dealing with the time-dependent ETRS89-ITRS transformation for geo-information at the upcoming EUREF-EuroSDR workshop in Troms?, Norway. Is anyone else from this mailing list going there? Registration is still open...
https://www.eurosdr.net/workshops/joint-euref-and-eurosdr-workshop-how-increase-use-spatial-data-sharing-data-across-borders

Jochem


-----Original Message-----
From: Greg Troxel <gdt at lexort.com>
Sent: dinsdag 17 september 2024 23:50
To: Lesparre, Jochem <Jochem.Lesparre at kadaster.nl>
Cc: PROJ at lists.osgeo.org
Subject: Re: [PROJ] Dealing with epoch and transformations

"Lesparre, Jochem" <Jochem.Lesparre at kadaster.nl> writes:

>> My somewhat hazy understanding is that ITRF2020 without a specified
>> epoch means 2015.0.
>
> I would say ITRF2020 without a specified epoch is undefined, but the
> reference epoch 2015.00 is sometimes also used as default epoch in
> software. Which is a poor choice for data that is current epoch,
> because ITRF2020 wasn't even published in 2015. So, a default epoch
> like 2025.00 would give more accurate results.

Is there any real support for picking some year not the reference epoch?
I can see treating ITRF2020 data without an epoch as either

  of the reference epoch, or

  an error, meaning an expecption is thrown and no results returned

This would be for to ITRF2020 or from.

And, if we pick the second option, we should do the same for each WGS84 realization (except maybe TRANSIT on the NA plate), and further reject data in the ensemble.

I therefore think the only reasonable plan is to treat it as being of the reference epoch, which is what I think proj is doing now.

I think it would take a very strong argument to pick a different default epoch.


Disclaimer:
De inhoud van deze e-mail is vertrouwelijk en uitsluitend bestemd voor de geadresseerde(n).
Gebruik, openbaarmaking, vermenigvuldiging, verspreiding en/of verstrekking van deze informatie aan derden is niet toegestaan.
Op al onze producten en diensten zijn onze algemene leveringsvoorwaarden van toepassing
[https://www.kadaster.nl/algemene-leveringsvoorwaarden].

Disclaimer:
This email and any files transmitted with it are confidential and intended solely for the use of the individual or entity to whom they are addressed.
If you are not the intended recipient, you are notified that disclosing, copying, distributing or taking any action in reliance on the contents of this information is strictly prohibited.
Our general terms and conditions of delivery apply to all our products and services
[https://www.kadaster.com/general-terms-and-conditions].

From even.rouault at spatialys.com  Wed Sep 18 00:10:19 2024
From: even.rouault at spatialys.com (Even Rouault)
Date: Wed, 18 Sep 2024 09:10:19 +0200
Subject: [PROJ] Dealing with epoch and transformations
In-Reply-To: <DU2P192MB2235B6C2EA666E02B4C01E8AEF622@DU2P192MB2235.EURP192.PROD.OUTLOOK.COM>
References: <CADRrdKtyZMLVSjY7JFEE6uL0xmhXKpw8tBLKhGhnw+HsQ_b=dQ@mail.gmail.com>
 <rmiikvrbhxr.fsf@s1.lexort.com>
 <AS8P192MB223828BCB31A8216B5126185EF612@AS8P192MB2238.EURP192.PROD.OUTLOOK.COM>
 <rmi7cba0x36.fsf@s1.lexort.com>
 <DU2P192MB2235B6C2EA666E02B4C01E8AEF622@DU2P192MB2235.EURP192.PROD.OUTLOOK.COM>
Message-ID: <a1a4f682-7a93-42cd-afec-60118b52ac35@spatialys.com>


 > So, I agree with you that using the reference epoch, like PROJ does, 
is the most reasonable thing to do for the moment.

Just to clarify that if you use a time-dependent Helmert transformation 
without specifying an epoch, PROJ will only apply the non-time-dependent 
terms. So the "reference epoch" in that situation is the one of the 
transformation, not the frame reference epoch of the datum

Cf:

$ echo 1 0 0 | bin/cct +proj=helmert +x=1 +dx=.1 +t_epoch=1234 2.0000 
0.0000 0.0000 inf

$ echo 1 0 0 1235 | bin/cct +proj=helmert +x=1 +dx=.1 +t_epoch=1234
2.1000 0.0000 0.0000 1235.0000

PROJ 9.5 has now a new API function, 
proj_coordoperation_requires_per_coordinate_input_time(), to indicate 
you if a given coordinate operation expects time-dependent terms: 
https://github.com/OSGeo/PROJ/pull/4221 .

There's also an explicit error code for the transformations where the 
coordinate epoch is really required, so currently +proj=defmodel and 
+proj=deformation +t_epoch= . For time-dependent Helmert, this is 
considered optional as mentioned above (mostly for backward compatibility)

Even

-- 
http://www.spatialys.com
My software is free, but my time generally not.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240918/62931b05/attachment.htm>

From Jochem.Lesparre at kadaster.nl  Wed Sep 18 02:53:31 2024
From: Jochem.Lesparre at kadaster.nl (Lesparre, Jochem)
Date: Wed, 18 Sep 2024 09:53:31 +0000
Subject: [PROJ] Transformations in ITRF2020
In-Reply-To: <CADRrdKuP1wWPOT4a_TUduBNM_0Hfgp0qfhEp1aadpECng8hyCg@mail.gmail.com>
References: <CADRrdKuP1wWPOT4a_TUduBNM_0Hfgp0qfhEp1aadpECng8hyCg@mail.gmail.com>
Message-ID: <DU2P192MB2235B6B6224164C0CACC5765EF622@DU2P192MB2235.EURP192.PROD.OUTLOOK.COM>


> Looking at the pipelines, the steps would be ITRF2020 -> ETRF2020 -> ETRS89 -> CH1903+

I am pretty sure Switzerland uses ETRF2000 as ETRS89 realisation, not ETRF2020. So, the correct transformation would be:

ITRF2020 -> ETRF2000 -> ETRS89 -> CH1903+

The difference between ETRF2000 and ETRF2020 is about 7 cm. ETRF2000 is recommended for use by national mapping agencies.

Jochem


From: PROJ <proj-bounces at lists.osgeo.org> On Behalf Of Javier Jimenez Shaw via PROJ
Sent: dinsdag 27 augustus 2024 19:30
To: proj <PROJ at lists.osgeo.org>
Subject: [PROJ] Transformations in ITRF2020

Hi

I am now facing transformations with ITRF2020 with time(yes, because Skylark, but I guess more NTRIPs are going to do (or already doing) the same)

The point is when the destination CRS does not have a direct transformation from ITRF2020 (or almost).

For instance, EPSG:4150, CH1903+ (the geographic of LV95, in Switzerland) is only connected to ETRS89. See that CH1903+ is in the European tectonic plate, as ETRS89

A direct transformation is completely ballpark

echo 42 6 0 2024.6 | ./cs2cs EPSG:9989 EPSG:4150 -d 9 --3d
42.000000000 6.000000000 0.000000000 2024.6

However, from ITRF2020 to ETRS89 there is some change due to the time (the European plate moving at 2.5 cm/a since 2015):
echo 42 6 0 2024.6 | ./cs2cs EPSG:9989 EPSG:4937 -d 9 --3d
41.999994981 5.999991317 -0.001861237 2024.6

and from ETRS89 to CH1903+ due to the datum offset:
echo 42 6 0 2024.6 | ./cs2cs EPSG:4937 EPSG:4150 -d 9 --3d
42.000742733 6.000670188 -60.682799297 2024.6

Looking at the pipelines, the steps would be ITRF2020 -> ETRF2020 -> ETRS89 -> CH1903+
(btw, only since PROJ 9.4.1, when ETRF2020 was added)

I understand that the only way to get the proper transformation is chaining these two manually. Via ETRS89 ... because I know it. Right?

Well, the future does not look so promising to me: in EPSG I only see transformations from ITRF2020 to ETRF family, NAD83(2011) family and NAD83(CSRS)v8. That is Europe, USA and Canada. That's all, folks.

Thanks,
.___ ._ ..._ .. . ._.  .___ .. __ . _. . __..  ... .... ._ .__
Javier Jimenez Shaw
Mercator str 42.
Null-Island


Disclaimer:
De inhoud van deze e-mail is vertrouwelijk en uitsluitend bestemd voor de geadresseerde(n).
Gebruik, openbaarmaking, vermenigvuldiging, verspreiding en/of verstrekking van deze informatie aan derden is niet toegestaan.
Op al onze producten en diensten zijn onze algemene leveringsvoorwaarden van toepassing
[https://www.kadaster.nl/algemene-leveringsvoorwaarden].

Disclaimer:
This email and any files transmitted with it are confidential and intended solely for the use of the individual or entity to whom they are addressed.
If you are not the intended recipient, you are notified that disclosing, copying, distributing or taking any action in reliance on the contents of this information is strictly prohibited.
Our general terms and conditions of delivery apply to all our products and services
[https://www.kadaster.com/general-terms-and-conditions].
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240918/27f96576/attachment-0001.htm>

From j1 at jimenezshaw.com  Wed Sep 18 09:36:16 2024
From: j1 at jimenezshaw.com (Javier Jimenez Shaw)
Date: Wed, 18 Sep 2024 18:36:16 +0200
Subject: [PROJ] Transformations in ITRF2020
In-Reply-To: <DU2P192MB2235B6B6224164C0CACC5765EF622@DU2P192MB2235.EURP192.PROD.OUTLOOK.COM>
References: <CADRrdKuP1wWPOT4a_TUduBNM_0Hfgp0qfhEp1aadpECng8hyCg@mail.gmail.com>
 <DU2P192MB2235B6B6224164C0CACC5765EF622@DU2P192MB2235.EURP192.PROD.OUTLOOK.COM>
Message-ID: <CADRrdKtMm1tYka9BBmQ_0kcn-icpik_4VHcy3NQk-pw_5ztdrw@mail.gmail.com>

Aren't they using CHTRS95 ?
https://epsg.org/crs_4933/CHTRS95.html

On Wed, 18 Sept 2024 at 11:53, Lesparre, Jochem <Jochem.Lesparre at kadaster.nl>
wrote:

>
>
> > Looking at the pipelines, the steps would be ITRF2020 -> ETRF2020 ->
> ETRS89 -> CH1903+
>
>
>
> I am pretty sure Switzerland uses ETRF2000 as ETRS89 realisation, not
> ETRF2020. So, the correct transformation would be:
>
>
>
> ITRF2020 -> ETRF2000 -> ETRS89 -> CH1903+
>
>
>
> The difference between ETRF2000 and ETRF2020 is about 7 cm. ETRF2000 is
> recommended for use by national mapping agencies.
>
>
>
> Jochem
>
>
>
>
>
> *From:* PROJ <proj-bounces at lists.osgeo.org> *On Behalf Of *Javier Jimenez
> Shaw via PROJ
> *Sent:* dinsdag 27 augustus 2024 19:30
> *To:* proj <PROJ at lists.osgeo.org>
> *Subject:* [PROJ] Transformations in ITRF2020
>
>
>
> Hi
>
>
>
> I am now facing transformations with ITRF2020 with time(yes, because
> Skylark, but I guess more NTRIPs are going to do (or already doing) the
> same)
>
>
>
> The point is when the destination CRS does not have a direct
> transformation from ITRF2020 (or almost).
>
>
>
> For instance, EPSG:4150, CH1903+ (the geographic of LV95, in Switzerland)
> is only connected to ETRS89. See that CH1903+ is in the European tectonic
> plate, as ETRS89
>
>
>
> A direct transformation is completely ballpark
>
>
>
> echo 42 6 0 2024.6 | ./cs2cs EPSG:9989 EPSG:4150 -d 9 --3d
> 42.000000000 6.000000000 0.000000000 2024.6
>
>
>
> However, from ITRF2020 to ETRS89 there is some change due to the time (the
> European plate moving at 2.5 cm/a since 2015):
>
> echo 42 6 0 2024.6 | ./cs2cs EPSG:9989 EPSG:4937 -d 9 --3d
> 41.999994981 5.999991317 -0.001861237 2024.6
>
>
>
> and from ETRS89 to CH1903+ due to the datum offset:
> echo 42 6 0 2024.6 | ./cs2cs EPSG:4937 EPSG:4150 -d 9 --3d
> 42.000742733 6.000670188 -60.682799297 2024.6
>
>
>
> Looking at the pipelines, the steps would be ITRF2020 -> ETRF2020 ->
> ETRS89 -> CH1903+
>
> (btw, only since PROJ 9.4.1, when ETRF2020 was added)
>
>
>
> I understand that the only way to get the proper transformation is
> chaining these two manually. Via ETRS89 ... because I know it. Right?
>
>
>
> Well, the future does not look so promising to me: in EPSG I only see
> transformations from ITRF2020 to ETRF family, NAD83(2011) family and
> NAD83(CSRS)v8. That is Europe, USA and Canada. That's all, folks.
>
>
>
> Thanks,
>
> .___ ._ ..._ .. . ._.  .___ .. __ . _. . __..  ... .... ._ .__
>
> Javier Jimenez Shaw
>
> Mercator str 42.
>
> Null-Island
>
>
> Disclaimer:
> De inhoud van deze e-mail is vertrouwelijk en uitsluitend bestemd voor de
> geadresseerde(n).
> Gebruik, openbaarmaking, vermenigvuldiging, verspreiding en/of
> verstrekking van deze informatie aan derden is niet toegestaan.
> Op al onze producten en diensten zijn onze algemene leveringsvoorwaarden
> van toepassing
> [https://www.kadaster.nl/algemene-leveringsvoorwaarden].
>
> Disclaimer:
> This email and any files transmitted with it are confidential and intended
> solely for the use of the individual or entity to whom they are addressed.
> If you are not the intended recipient, you are notified that disclosing,
> copying, distributing or taking any action in reliance on the contents of
> this information is strictly prohibited.
> Our general terms and conditions of delivery apply to all our products and
> services
> [https://www.kadaster.com/general-terms-and-conditions].
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240918/36d14d56/attachment.htm>

From Jochem.Lesparre at kadaster.nl  Wed Sep 18 10:55:14 2024
From: Jochem.Lesparre at kadaster.nl (Lesparre, Jochem)
Date: Wed, 18 Sep 2024 17:55:14 +0000
Subject: [PROJ] Transformations in ITRF2020
In-Reply-To: <CADRrdKtMm1tYka9BBmQ_0kcn-icpik_4VHcy3NQk-pw_5ztdrw@mail.gmail.com>
References: <CADRrdKuP1wWPOT4a_TUduBNM_0Hfgp0qfhEp1aadpECng8hyCg@mail.gmail.com>
 <DU2P192MB2235B6B6224164C0CACC5765EF622@DU2P192MB2235.EURP192.PROD.OUTLOOK.COM>
 <CADRrdKtMm1tYka9BBmQ_0kcn-icpik_4VHcy3NQk-pw_5ztdrw@mail.gmail.com>
Message-ID: <VI1P192MB22563671EE16192EAD99CC43EF622@VI1P192MB2256.EURP192.PROD.OUTLOOK.COM>

> Aren't they using CHTRS95 ?

I don?t know the details. But CHTRS95 seems to be a their national realisation of ETRS89. And I know their national realisation of ETRS89 is close to ETRF2000, or at least much closer to ETRF2000 than to ETRF2020.

Jochem



Disclaimer:
De inhoud van deze e-mail is vertrouwelijk en uitsluitend bestemd voor de geadresseerde(n).
Gebruik, openbaarmaking, vermenigvuldiging, verspreiding en/of verstrekking van deze informatie aan derden is niet toegestaan.
Op al onze producten en diensten zijn onze algemene leveringsvoorwaarden van toepassing
[https://www.kadaster.nl/algemene-leveringsvoorwaarden].

Disclaimer:
This email and any files transmitted with it are confidential and intended solely for the use of the individual or entity to whom they are addressed.
If you are not the intended recipient, you are notified that disclosing, copying, distributing or taking any action in reliance on the contents of this information is strictly prohibited.
Our general terms and conditions of delivery apply to all our products and services
[https://www.kadaster.com/general-terms-and-conditions].
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240918/8d3794ac/attachment-0001.htm>

From even.rouault at spatialys.com  Thu Sep 19 13:06:54 2024
From: even.rouault at spatialys.com (Even Rouault)
Date: Thu, 19 Sep 2024 22:06:54 +0200
Subject: [PROJ] robots.txt
In-Reply-To: <CADRrdKuO7AiSa1RhAztAUPXi_A2_qVAgQ1jdA64Dq17y7Jk7Pw@mail.gmail.com>
References: <CADRrdKuO7AiSa1RhAztAUPXi_A2_qVAgQ1jdA64Dq17y7Jk7Pw@mail.gmail.com>
Message-ID: <20fbd087-925f-4102-a3e9-5276c3585ceb@spatialys.com>

Javier,
>
> Should we do the same in PROJ as in GDAL?

Seems a good idea. What should we index for PROJ: /en/latest/ or 
/en/stable/ ?

But I'm puzzled by the content of stable. 
https://proj.org/en/stable/download.html points to 9.4.1 as the latest 
release, but https://readthedocs.org/projects/osgeo-proj/versions/ 
indicates that stable corresponds to commit 0a407325 which is the 
https://github.com/OSGeo/PROJ/commits/9.5.0 tag. I've triggered a manual 
build of stable in the RtD UI again, but to no avail. Not sure what's 
going on there.

Even

-- 
http://www.spatialys.com
My software is free, but my time generally not.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240919/51ad1a25/attachment.htm>

From j1 at jimenezshaw.com  Fri Sep 20 04:57:15 2024
From: j1 at jimenezshaw.com (Javier Jimenez Shaw)
Date: Fri, 20 Sep 2024 13:57:15 +0200
Subject: [PROJ] robots.txt
In-Reply-To: <20fbd087-925f-4102-a3e9-5276c3585ceb@spatialys.com>
References: <CADRrdKuO7AiSa1RhAztAUPXi_A2_qVAgQ1jdA64Dq17y7Jk7Pw@mail.gmail.com>
 <20fbd087-925f-4102-a3e9-5276c3585ceb@spatialys.com>
Message-ID: <CADRrdKv5NkZejnjU_VbLd9fOjCgPKpiOsaWxBsr4D0xrPiWCdQ@mail.gmail.com>

On Thu, 19 Sept 2024 at 22:06, Even Rouault <even.rouault at spatialys.com>
wrote:

> Javier,
>
>
> Should we do the same in PROJ as in GDAL?
>
>
> Seems a good idea. What should we index for PROJ: /en/latest/ or
> /en/stable/ ?
>
What is the difference between latest and stable?
For a moment I thought that latest was from "master", and stable the "last
release". But there are changes from https://github.com/OSGeo/PROJ/pull/4251
that are not in latest.

Even
>
> -- http://www.spatialys.com
> My software is free, but my time generally not.
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240920/370b08e4/attachment.htm>

From even.rouault at spatialys.com  Fri Sep 20 05:43:20 2024
From: even.rouault at spatialys.com (Even Rouault)
Date: Fri, 20 Sep 2024 14:43:20 +0200
Subject: [PROJ] robots.txt
In-Reply-To: <CADRrdKv5NkZejnjU_VbLd9fOjCgPKpiOsaWxBsr4D0xrPiWCdQ@mail.gmail.com>
References: <CADRrdKuO7AiSa1RhAztAUPXi_A2_qVAgQ1jdA64Dq17y7Jk7Pw@mail.gmail.com>
 <20fbd087-925f-4102-a3e9-5276c3585ceb@spatialys.com>
 <CADRrdKv5NkZejnjU_VbLd9fOjCgPKpiOsaWxBsr4D0xrPiWCdQ@mail.gmail.com>
Message-ID: <ae8c7829-90db-4473-b18d-a7bce520797d@spatialys.com>


Le 20/09/2024 ? 13:57, Javier Jimenez Shaw a ?crit?:
>
>
> On Thu, 19 Sept 2024 at 22:06, Even Rouault 
> <even.rouault at spatialys.com> wrote:
>
>     Javier,
>>
>>     Should we do the same in PROJ as in GDAL?
>
>     Seems a good idea. What should we index for PROJ: /en/latest/ or
>     /en/stable/ ?
>
> What is the difference between latest and stable?
> For a moment I thought that latest was from "master", and stable the 
> "last release". But there are changes from 
> https://github.com/OSGeo/PROJ/pull/4251 that are not in latest.

yes, "RTD latest" = "git master" and "RTD stable" = "last git tag"

Comparing the commit history of 
https://github.com/OSGeo/PROJ/commits/9.5/ (the branch) and 
https://github.com/OSGeo/PROJ/commits/9.5.0 (the tag) I now understand 
why RTD stable == tag 9.5.0 currently doesn't display the 9.5.0 release. 
The reason is that it lacks the commit 
https://github.com/OSGeo/PROJ/commit/1960849ba7b65f05c13e10cac233e021a3e045dd 
"Update docs for 9.5.0 release".

So this is mostly a matter of adjusting the release procedure to make 
sure the tag incorporates the download link for it (at that point the 
release tarball is not yet generated, but its name and location are 
entirely predictable) and the updated news.

We could for example tag commit 1960849ba7b65f05c13e10cac233e021a3e045dd 
as "9.5.0-updated-doc" and that would do, but there might be side 
effects in doing that (like all distributions automatically tracking 
tags that would trigger new build).

I'm wondering if a simpler and more desirable behavior would be to 
manage to convince RTD to alias "stable" to the "9.5" branch currently, 
so stable receives backported doc fixes, etc. That would be surprising 
that the RTD configuration doesn't allow to do that.


-- 
http://www.spatialys.com
My software is free, but my time generally not.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240920/3a1b5f0d/attachment.htm>

From j1 at jimenezshaw.com  Fri Sep 20 06:31:04 2024
From: j1 at jimenezshaw.com (Javier Jimenez Shaw)
Date: Fri, 20 Sep 2024 15:31:04 +0200
Subject: [PROJ] robots.txt
In-Reply-To: <ae8c7829-90db-4473-b18d-a7bce520797d@spatialys.com>
References: <CADRrdKuO7AiSa1RhAztAUPXi_A2_qVAgQ1jdA64Dq17y7Jk7Pw@mail.gmail.com>
 <20fbd087-925f-4102-a3e9-5276c3585ceb@spatialys.com>
 <CADRrdKv5NkZejnjU_VbLd9fOjCgPKpiOsaWxBsr4D0xrPiWCdQ@mail.gmail.com>
 <ae8c7829-90db-4473-b18d-a7bce520797d@spatialys.com>
Message-ID: <CADRrdKvRQvoue25ovvAqKFX-EvNWZJ+AzVps=0rhhq9tEa4CsQ@mail.gmail.com>

On Fri, 20 Sept 2024 at 14:43, Even Rouault <even.rouault at spatialys.com>
wrote:

>
> Le 20/09/2024 ? 13:57, Javier Jimenez Shaw a ?crit :
>
>
>
> On Thu, 19 Sept 2024 at 22:06, Even Rouault <even.rouault at spatialys.com>
> wrote:
>
>> Javier,
>>
>>
>> Should we do the same in PROJ as in GDAL?
>>
>>
>> Seems a good idea. What should we index for PROJ: /en/latest/ or
>> /en/stable/ ?
>>
> What is the difference between latest and stable?
> For a moment I thought that latest was from "master", and stable the "last
> release". But there are changes from
> https://github.com/OSGeo/PROJ/pull/4251 that are not in latest.
>
> yes, "RTD latest" = "git master" and "RTD stable" = "last git tag"
>
> Comparing the commit history of https://github.com/OSGeo/PROJ/commits/9.5/
> (the branch) and https://github.com/OSGeo/PROJ/commits/9.5.0 (the tag) I
> now understand why RTD stable == tag 9.5.0 currently doesn't display the
> 9.5.0 release. The reason is that it lacks the commit
> https://github.com/OSGeo/PROJ/commit/1960849ba7b65f05c13e10cac233e021a3e045dd
> "Update docs for 9.5.0 release".
>
> So this is mostly a matter of adjusting the release procedure to make sure
> the tag incorporates the download link for it (at that point the release
> tarball is not yet generated, but its name and location are entirely
> predictable) and the updated news.
>
> We could for example tag commit 1960849ba7b65f05c13e10cac233e021a3e045dd
> as "9.5.0-updated-doc" and that would do, but there might be side effects
> in doing that (like all distributions automatically tracking tags that
> would trigger new build).
>
> I'm wondering if a simpler and more desirable behavior would be to manage
> to convince RTD to alias "stable" to the "9.5" branch currently, so stable
> receives backported doc fixes, etc. That would be surprising that the RTD
> configuration doesn't allow to do that.
>
>
Does it explain why "latest" documentation does not include the typos
corrected in the PR 4251, already merged into master?

-- http://www.spatialys.com
> My software is free, but my time generally not.
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240920/9758c573/attachment.htm>

From even.rouault at spatialys.com  Fri Sep 20 06:40:42 2024
From: even.rouault at spatialys.com (Even Rouault)
Date: Fri, 20 Sep 2024 15:40:42 +0200
Subject: [PROJ] robots.txt
In-Reply-To: <CADRrdKvRQvoue25ovvAqKFX-EvNWZJ+AzVps=0rhhq9tEa4CsQ@mail.gmail.com>
References: <CADRrdKuO7AiSa1RhAztAUPXi_A2_qVAgQ1jdA64Dq17y7Jk7Pw@mail.gmail.com>
 <20fbd087-925f-4102-a3e9-5276c3585ceb@spatialys.com>
 <CADRrdKv5NkZejnjU_VbLd9fOjCgPKpiOsaWxBsr4D0xrPiWCdQ@mail.gmail.com>
 <ae8c7829-90db-4473-b18d-a7bce520797d@spatialys.com>
 <CADRrdKvRQvoue25ovvAqKFX-EvNWZJ+AzVps=0rhhq9tEa4CsQ@mail.gmail.com>
Message-ID: <1289e63a-b315-4e62-be38-855054e0dd18@spatialys.com>


>
> Does it explain why "latest" documentation does not include the typos 
> corrected in the PR 4251, already merged into master?

Ah, well, this is due to the merging of 
https://github.com/OSGeo/PROJ/pull/4249, which is a commit to honour [ci 
skip] for RTD. But as that commit is the last one in master currently, 
and it does include "[ci skip]" in its commit message, well, the doc 
didn't get rebuilt as expected :-)

I've just pushed a dummy commit to trigger a rebuild: 
https://app.readthedocs.org/projects/osgeo-proj/builds/25693188/

>
>     -- 
>     http://www.spatialys.com
>     My software is free, but my time generally not.
>
-- 
http://www.spatialys.com
My software is free, but my time generally not.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240920/862a483f/attachment-0001.htm>

From j1 at jimenezshaw.com  Fri Sep 20 06:54:38 2024
From: j1 at jimenezshaw.com (Javier Jimenez Shaw)
Date: Fri, 20 Sep 2024 15:54:38 +0200
Subject: [PROJ] robots.txt
In-Reply-To: <1289e63a-b315-4e62-be38-855054e0dd18@spatialys.com>
References: <CADRrdKuO7AiSa1RhAztAUPXi_A2_qVAgQ1jdA64Dq17y7Jk7Pw@mail.gmail.com>
 <20fbd087-925f-4102-a3e9-5276c3585ceb@spatialys.com>
 <CADRrdKv5NkZejnjU_VbLd9fOjCgPKpiOsaWxBsr4D0xrPiWCdQ@mail.gmail.com>
 <ae8c7829-90db-4473-b18d-a7bce520797d@spatialys.com>
 <CADRrdKvRQvoue25ovvAqKFX-EvNWZJ+AzVps=0rhhq9tEa4CsQ@mail.gmail.com>
 <1289e63a-b315-4e62-be38-855054e0dd18@spatialys.com>
Message-ID: <CADRrdKumTrn2cW_=TWYmYPjLrsuC5-YjE=gG3xK8boWKc+nykQ@mail.gmail.com>

Coming back to the question about
"What should we index for PROJ: /en/latest/ or /en/stable/ ?"

Now that I have clear what is what, I would say that robots.txt should
include only "en/stable"
IIRC, gdal has "latest" because at that point in time (and today as well)
there is no stable available yet, only latest.

BTW, is there any reason why in GDAL the "Read the Docs" menu is on the
right, and not in the left as in PROJ? (I prefer as in PROJ)

Cheers.
Javier

On Fri, 20 Sept 2024 at 15:40, Even Rouault <even.rouault at spatialys.com>
wrote:

>
>
> Does it explain why "latest" documentation does not include the typos
> corrected in the PR 4251, already merged into master?
>
> Ah, well, this is due to the merging of
> https://github.com/OSGeo/PROJ/pull/4249, which is a commit to honour [ci
> skip] for RTD. But as that commit is the last one in master currently, and
> it does include "[ci skip]" in its commit message, well, the doc didn't get
> rebuilt as expected :-)
>
> I've just pushed a dummy commit to trigger a rebuild:
> https://app.readthedocs.org/projects/osgeo-proj/builds/25693188/
>
>
> -- http://www.spatialys.com
>> My software is free, but my time generally not.
>>
>> -- http://www.spatialys.com
> My software is free, but my time generally not.
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240920/f35bffac/attachment.htm>

From even.rouault at spatialys.com  Fri Sep 20 07:05:27 2024
From: even.rouault at spatialys.com (Even Rouault)
Date: Fri, 20 Sep 2024 16:05:27 +0200
Subject: [PROJ] robots.txt
In-Reply-To: <CADRrdKumTrn2cW_=TWYmYPjLrsuC5-YjE=gG3xK8boWKc+nykQ@mail.gmail.com>
References: <CADRrdKuO7AiSa1RhAztAUPXi_A2_qVAgQ1jdA64Dq17y7Jk7Pw@mail.gmail.com>
 <20fbd087-925f-4102-a3e9-5276c3585ceb@spatialys.com>
 <CADRrdKv5NkZejnjU_VbLd9fOjCgPKpiOsaWxBsr4D0xrPiWCdQ@mail.gmail.com>
 <ae8c7829-90db-4473-b18d-a7bce520797d@spatialys.com>
 <CADRrdKvRQvoue25ovvAqKFX-EvNWZJ+AzVps=0rhhq9tEa4CsQ@mail.gmail.com>
 <1289e63a-b315-4e62-be38-855054e0dd18@spatialys.com>
 <CADRrdKumTrn2cW_=TWYmYPjLrsuC5-YjE=gG3xK8boWKc+nykQ@mail.gmail.com>
Message-ID: <c86cc3b3-7de9-48ba-bbe0-14d4c209af24@spatialys.com>


Le 20/09/2024 ? 15:54, Javier Jimenez Shaw a ?crit?:
> Coming back to the question about
> "What should we index for PROJ: /en/latest/ or /en/stable/ ?"
>
> Now that I have clear what is what, I would say that robots.txt should 
> include only "en/stable"
Yes, ideally. The annoying part is that currently it points to the state 
of the 9.5.0 tag that doesn't point to the 9.5.0 release tarball...
> IIRC, gdal has "latest" because at that point in time (and today as 
> well) there is no stable available yet, only latest.
>
> BTW, is there any reason why in GDAL the "Read the Docs" menu is on 
> the right, and not in the left as in PROJ? (I prefer as in PROJ)

Already ticketed as https://github.com/OSGeo/gdal/issues/10680 . I 
suspect this is due to GDAL using a custom Sphinx theme (derived from 
one made by late Boundless, itself derived from the official RtD one, 
due to a past Boundless employee who helped bootstrapping the Sphinx 
migration). I guess just using the standard RtD theme would be a way to 
fix this.


-- 
http://www.spatialys.com
My software is free, but my time generally not.


From j1 at jimenezshaw.com  Fri Sep 20 07:09:11 2024
From: j1 at jimenezshaw.com (Javier Jimenez Shaw)
Date: Fri, 20 Sep 2024 16:09:11 +0200
Subject: [PROJ] robots.txt
In-Reply-To: <c86cc3b3-7de9-48ba-bbe0-14d4c209af24@spatialys.com>
References: <CADRrdKuO7AiSa1RhAztAUPXi_A2_qVAgQ1jdA64Dq17y7Jk7Pw@mail.gmail.com>
 <20fbd087-925f-4102-a3e9-5276c3585ceb@spatialys.com>
 <CADRrdKv5NkZejnjU_VbLd9fOjCgPKpiOsaWxBsr4D0xrPiWCdQ@mail.gmail.com>
 <ae8c7829-90db-4473-b18d-a7bce520797d@spatialys.com>
 <CADRrdKvRQvoue25ovvAqKFX-EvNWZJ+AzVps=0rhhq9tEa4CsQ@mail.gmail.com>
 <1289e63a-b315-4e62-be38-855054e0dd18@spatialys.com>
 <CADRrdKumTrn2cW_=TWYmYPjLrsuC5-YjE=gG3xK8boWKc+nykQ@mail.gmail.com>
 <c86cc3b3-7de9-48ba-bbe0-14d4c209af24@spatialys.com>
Message-ID: <CADRrdKszfX7RGY3wrkGqD5KyZMaCNF9a=qyDZ38fXiKgWbfQww@mail.gmail.com>

On Fri, 20 Sept 2024, 16:05 Even Rouault, <even.rouault at spatialys.com>
wrote:

>
> Le 20/09/2024 ? 15:54, Javier Jimenez Shaw a ?crit :
> > Coming back to the question about
> > "What should we index for PROJ: /en/latest/ or /en/stable/ ?"
> >
> > Now that I have clear what is what, I would say that robots.txt should
> > include only "en/stable"
> Yes, ideally. The annoying part is that currently it points to the state
> of the 9.5.0 tag that doesn't point to the 9.5.0 release tarball...
>

If it is complicated or ugly we can do it for 9.5.1.

> IIRC, gdal has "latest" because at that point in time (and today as
> > well) there is no stable available yet, only latest.
> >
> > BTW, is there any reason why in GDAL the "Read the Docs" menu is on
> > the right, and not in the left as in PROJ? (I prefer as in PROJ)
>
> Already ticketed as https://github.com/OSGeo/gdal/issues/10680 . I
> suspect this is due to GDAL using a custom Sphinx theme (derived from
> one made by late Boundless, itself derived from the official RtD one,
> due to a past Boundless employee who helped bootstrapping the Sphinx
> migration). I guess just using the standard RtD theme would be a way to
> fix this.
>
>
> --
> http://www.spatialys.com
> My software is free, but my time generally not.
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240920/f6c5186c/attachment.htm>

From gdt at lexort.com  Sat Sep 21 15:51:20 2024
From: gdt at lexort.com (Greg Troxel)
Date: Sat, 21 Sep 2024 18:51:20 -0400
Subject: [PROJ] downloadable documentation ?
Message-ID: <rmi5xqoy61j.fsf@s1.lexort.com>

I know there are docs on the web, but I have a bias that docs should be
downloadable and packaged, so they can be available offline.

There is a pkgsrc package 'proj-docs', which wraps:

  # \todo See if upstream provides pdf docs, and update if so, or delete if not.
  DISTNAME=               proj-gh-pages
  PKGNAME=                proj-doc-9.1.0
  CATEGORIES=             geography
  MASTER_SITES=           ${MASTER_SITE_GITHUB:=OSGeo/}
  GITHUB_PROJECT=         proj
  # Perhaps associated with 9.1.1, really.
  GITHUB_TAG=             c8132e949948c532e9aef6722ae6eb3e74cbc519

and currently has a single pdf.

I see

  https://github.com/OSGeo/PROJ/tree/gh-pages

but it doesn't seem recent.  I can't figure out if this is what is at
proj.org.

Should I be building proj docs from someplace else?

From j1 at jimenezshaw.com  Sat Sep 21 15:59:35 2024
From: j1 at jimenezshaw.com (Javier Jimenez Shaw)
Date: Sun, 22 Sep 2024 00:59:35 +0200
Subject: [PROJ] downloadable documentation ?
In-Reply-To: <rmi5xqoy61j.fsf@s1.lexort.com>
References: <rmi5xqoy61j.fsf@s1.lexort.com>
Message-ID: <CADRrdKuwbNJqhqJz61b3-0nuLgJCg89GV_qPTzoRYpru3epFpw@mail.gmail.com>

In proj.org, in the left menu (burger menu in a cellphone) you can download
as pdf or html
For instance https://proj.org/_/downloads/en/9.5/pdf/

On Sun, 22 Sept 2024, 00:51 Greg Troxel via PROJ, <proj at lists.osgeo.org>
wrote:

> I know there are docs on the web, but I have a bias that docs should be
> downloadable and packaged, so they can be available offline.
>
> There is a pkgsrc package 'proj-docs', which wraps:
>
>   # \todo See if upstream provides pdf docs, and update if so, or delete
> if not.
>   DISTNAME=               proj-gh-pages
>   PKGNAME=                proj-doc-9.1.0
>   CATEGORIES=             geography
>   MASTER_SITES=           ${MASTER_SITE_GITHUB:=OSGeo/}
>   GITHUB_PROJECT=         proj
>   # Perhaps associated with 9.1.1, really.
>   GITHUB_TAG=             c8132e949948c532e9aef6722ae6eb3e74cbc519
>
> and currently has a single pdf.
>
> I see
>
>   https://github.com/OSGeo/PROJ/tree/gh-pages
>
> but it doesn't seem recent.  I can't figure out if this is what is at
> proj.org.
>
> Should I be building proj docs from someplace else?
> _______________________________________________
> PROJ mailing list
> PROJ at lists.osgeo.org
> https://lists.osgeo.org/mailman/listinfo/proj
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240922/811952f7/attachment.htm>

From gdt at lexort.com  Sat Sep 21 16:07:47 2024
From: gdt at lexort.com (Greg Troxel)
Date: Sat, 21 Sep 2024 19:07:47 -0400
Subject: [PROJ] downloadable documentation ?
In-Reply-To: <CADRrdKuwbNJqhqJz61b3-0nuLgJCg89GV_qPTzoRYpru3epFpw@mail.gmail.com>
 (Javier Jimenez Shaw's message of "Sun, 22 Sep 2024 00:59:35 +0200")
References: <rmi5xqoy61j.fsf@s1.lexort.com>
 <CADRrdKuwbNJqhqJz61b3-0nuLgJCg89GV_qPTzoRYpru3epFpw@mail.gmail.com>
Message-ID: <rmi1q1cy5a4.fsf@s1.lexort.com>

Javier Jimenez Shaw <j1 at jimenezshaw.com> writes:

> In proj.org, in the left menu (burger menu in a cellphone) you can download
> as pdf or html
> For instance https://proj.org/_/downloads/en/9.5/pdf/

Thanks - I had no idea!

Is there a stable URL, where I can be guaranteed of the same bits for a
repeat request, in the same way that a distribution tarball is fixed?
It seems like this is a nightly build of the 9.5 branch, but I'm not
sure.

Where are the sources?

What do other packagers do?

From even.rouault at spatialys.com  Sat Sep 21 16:23:02 2024
From: even.rouault at spatialys.com (Even Rouault)
Date: Sun, 22 Sep 2024 01:23:02 +0200
Subject: [PROJ] downloadable documentation ?
In-Reply-To: <rmi1q1cy5a4.fsf@s1.lexort.com>
References: <rmi5xqoy61j.fsf@s1.lexort.com>
 <CADRrdKuwbNJqhqJz61b3-0nuLgJCg89GV_qPTzoRYpru3epFpw@mail.gmail.com>
 <rmi1q1cy5a4.fsf@s1.lexort.com>
Message-ID: <ec26e1cf-b56d-4d45-88e2-99600dcd06ed@spatialys.com>

> Is there a stable URL, where I can be guaranteed of the same bits for a
> repeat request, in the same way that a distribution tarball is fixed?
> It seems like this is a nightly build of the 9.5 branch, but I'm not
> sure.

Currently /stable points to the latest tag (9.5.0): 
https://proj.org/_/downloads/en/stable/pdf/

That will change to 9.5.1 docs once 9.5.1 is released

>
> Where are the sources?

"make latexpdf"? from the docs/ directory, using the full tarball of 
https://github.com/OSGeo/PROJ/archive/refs/tags/9.5.0.tar.gz that 
includes that directory

See doc/environment.yml for the various built requirements (here using 
conda-forge package naming, but should map in a straightforward way in 
other packaging solutions)

-- 
http://www.spatialys.com
My software is free, but my time generally not.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20240922/e321816a/attachment.htm>

From gdt at lexort.com  Sat Sep 21 16:36:30 2024
From: gdt at lexort.com (Greg Troxel)
Date: Sat, 21 Sep 2024 19:36:30 -0400
Subject: [PROJ] downloadable documentation ?
In-Reply-To: <ec26e1cf-b56d-4d45-88e2-99600dcd06ed@spatialys.com> (Even
 Rouault's message of "Sun, 22 Sep 2024 01:23:02 +0200")
References: <rmi5xqoy61j.fsf@s1.lexort.com>
 <CADRrdKuwbNJqhqJz61b3-0nuLgJCg89GV_qPTzoRYpru3epFpw@mail.gmail.com>
 <rmi1q1cy5a4.fsf@s1.lexort.com>
 <ec26e1cf-b56d-4d45-88e2-99600dcd06ed@spatialys.com>
Message-ID: <rmiwmj4wpke.fsf@s1.lexort.com>

Even Rouault <even.rouault at spatialys.com> writes:

> Currently /stable points to the latest tag (9.5.0):
> https://proj.org/_/downloads/en/stable/pdf/

> That will change to 9.5.1 docs once 9.5.1 is released

I realize that is helpful for humans, but in general packaging systems
want a URL that will always return the same bits, so others can build
the package and get the same result, and the checksum for the distfile
will match.  Ideally they whould of be like release tarballs, but with
docs instead of sources.  (A redirect URL to the latest is fine of
course.)


Thanks for the pointer to the sources, todo queued to deal with this.

So 'release tarball' does not contain the docs, but they are available
via the github tag mechanism.  I didn't figure that out from the readme.

In the days of autoconf, it was somewhat normal to have files in the
repo but not in release tarballs, and I have the impression that in the
cmake and especially github world, it is not, so I didn't think of it.

(I appreciate everone's patient with and replies to my questions; for
various reasons a bunch of geo packages were behind and I've been trying
to get caught up.)


