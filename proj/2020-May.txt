From kreve at sdfe.dk  Fri May  1 01:27:14 2020
From: kreve at sdfe.dk (Kristian Evers)
Date: Fri, 1 May 2020 08:27:14 +0000
Subject: [PROJ] PROJ 7.0.1RC1 & 6.3.2RC1
In-Reply-To: <CAH0YoEMvX2QdOAT4TRAGhAZptzDhqZdWaMpijQn_Jr8z=rBvmA@mail.gmail.com>
References: <E50977E3-EC8D-41B5-B7DA-2BCD4FCBA0AF@gmail.com>
 <173c487f771040339ce70a474ce2c11f@sdfe.dk>
 <CAH0YoEMvX2QdOAT4TRAGhAZptzDhqZdWaMpijQn_Jr8z=rBvmA@mail.gmail.com>
Message-ID: <d1b6c2e80076449ab977a58822e60a82@sdfe.dk>

Motion passed with +1’s from Kristian, Even, Howard and Thomas.

The final releases will be available soon.

/Kristian

From: Thomas Knudsen <knudsen.thomas at gmail.com>
Sent: 30. april 2020 17:32
To: Kristian Evers <kreve at sdfe.dk>
Cc: Kristian Evers <kristianevers at gmail.com>; PROJ <proj at lists.osgeo.org>
Subject: Re: [PROJ] PROJ 7.0.1RC1 & 6.3.2RC1

+1 Thomas

Den tor. 30. apr. 2020 kl. 11.23 skrev Kristian Evers <kreve at sdfe.dk<mailto:kreve at sdfe.dk>>:
With the exception of a few minor warnings in 6.3.2RC1 reported by Greg,
no serious problems have been found in the two release candidates.

So, I hereby motion that we promote proj-7.0.1RC1 and proj-6.3.2RC1 to their final
versions.

I’ll start with my +1

/Kristian

-----Original Message-----
From: PROJ <proj-bounces at lists.osgeo.org<mailto:proj-bounces at lists.osgeo.org>> On Behalf Of Kristian Evers
Sent: 27. april 2020 11:23
To: PROJ <proj at lists.osgeo.org<mailto:proj at lists.osgeo.org>>
Subject: [PROJ] PROJ 7.0.1RC1 & 6.3.2RC1

All,

With scheduled releases of PROJ 7.0.1 and 6.3.2. on May 1st it is time
to put out release candidates. Both candidates includes a number of bug
fixes since the previous release. 7.0.1 includes 39 bug fixes and 16 bugs
has been fixed in 6.3.2. See the release notes below.

Archives are available here:

http://download.osgeo.org/proj/proj-7.0.1RC1.tar.gz
http://download.osgeo.org/proj/proj-7.0.1RC1.zip
http://download.osgeo.org/proj/proj-6.3.2RC1.tar.gz
http://download.osgeo.org/proj/proj-6.3.2RC1.zip


Please test the release candidates and report back any problems you
may encounter.

If no issues are found with the two release candidates the final releases
will be announced on Friday May 1st.

/Kristian



7.0.1 Release Notes
-------------------

 Updates
 -------

 o Database: update to EPSG v9.8.9 #2141

 Bug fixes
 ---------

 o Make tests independent of proj-datumgrid (#1995)

 o Add missing projection property tables (#1996)

 o Avoid crash when running against SQLite3 binary built with
   -DSQLITE_OMIT_AUTOINIT (#1999)

 o createOperations(): fix wrong pipeline generation with CRS that has +nadgrids=
   and +pm= (#2002)

 o Fix bad copy&replace pattern on HEALPix and rHEALPix projection names (#2007)

 o createUnitOfMeasure(): use full double resolution for the conversion
   factor (#2014)

 o Update README with info on PROJ-data (#2015)

 o utm/ups: make sure to set errno to PJD_ERR_ELLIPSOID_USE_REQUIRED if
   es==0 (#2045)

 o data/Makefile.am: remove bashism (#2048)

 o ProjectedCRS::identify(): tune it to better work with ESRI WKT
   representation of EPSG:2193 (#2059)

 o Fix build with gcc 4.8.5 (#2066)

 o Autotools/pkg-conf: Define datarootdir (#2069)

 o cs2cs: don't require +to for '{source_crs} {target_crs} filename...'
   syntax (#2081)

 o CMake: fix bug with find_package(PROJ) with macOS (#2082)

 o ESRI WKT import / identification: special case for
   NAD_1983_HARN_StatePlane_Colorado_North_FIPS_0501 with Foot_US unit (#2088)

 o ESRI WKT import / identification: special case for
   NAD_1983_HARN_StatePlane_Colorado_North_FIPS_0501 with Foot_US unit (#2089)

 o EngineeringCRS: when exporting to WKT1_GDAL, output unit and axis (#2092)

 o Use jtsk03-jtsk horizontal grid from CDN (#2098)

 o CMake: prefer to use use PROJ_SOURCE_DIR and PROJ_BINARY_DIR (#2100)

 o Fix wrong grids file name in esri.sql (#2104)

 o Fix identification of projected CRS whose name is close but not strictly
   equal to a ESRI alias (#2106)

 o Fix working of Helmert transform between the horizontal part of
   2 compoundCRS (#2111)

 o Database: fix registration of custom entries of grid_transformation_custom.sql
   for geoid grids (#2114)

 o ESRI_WKT ingestion: make sure to identify to non-deprecated EPSG entry when
   possible (#2119)

 o Make sure that importing a Projected 3D CRS from WKT:2019 keeps the base
   geographic CRS as 3D (#2125)

 o createOperations(): improve results of compoundCRS to compoundCRS case (#2131)

 o hgridshift/vgridshift: defer grid opening when grid has already
   been opened (#2132)

 o Resolve a few shadowed declaration warnings (#2142)

 o ProjectedCRS identification: deal with switched 1st/2nd std parallels for
   LCC_2SP(#2153)

 o Fix Robinson inverse projection (#2154)

 o createOperations(): do not remove ballpark transformation if there are only
   grid based operations, even if they cover the whole area of use (#2156)

 o createFromCoordinateReferenceSystemCodes(): 'optimization' to avoid using
   C++ exceptions (#2161)

 o Ingestion of WKT1_GDAL: correctly map 'Cylindrical_Equal_Area' (#2167)

 o Add limited support for non-conformant WKT1 LAS COMPD_CS[] (#2172)

 o PROJ4 string import: take into correctly non-metre unit when the string
   looks like the one for WGS 84 / Pseudo Mercator (#2177)

 o io.hpp: avoid dependency to proj_json_streaming_writer.hpp (#2184)

 o Fix support of WKT1_GDAL with netCDF rotated pole formulation (#2186)



6.3.2 Release Notes
-------------------

 Bug fixes
 ---------

 o validateParameters(): fix false-positive warning on
   Equidistant Cylindrical (#1947)

 o proj_create_crs_to_crs(): avoid potential reprojection failures when
   reprojecting area of use to source and target CRS (#1993)

 o createOperations(): fix wrong pipeline generation with CRS that has +nadgrids=
   and +pm= (#2003)

 o Fix bad copy&replace pattern on HEALPix and rHEALPix projection names (#2006)

 o createUnitOfMeasure(): use full double resolution for the conversion
   factor (#2013)

 o data/Makefile.am: remove bashism (#2047)

 o ProjectedCRS::identify(): tune it to better work with ESRI WKT representation
   of EPSG:2193 (#2058)

 o EngineeringCRS: when exporting to WKT1_GDAL, output unit and axis (#2091)

 o Add missing entries in grid_alternatives for Portugal grids coming from
   ESRI entries (#2103)

 o Fix working of Helmert transform between the horizontal part of 2
   compoundCRS (#2110)

 o ESRI_WKT ingestion: make sure to identify to non-deprecated EPSG entry when
   possible (#2118)

 o Make sure that importing a Projected 3D CRS from WKT:2019 keeps the base
   geographic CRS as 3D (#2124)

 o createOperations(): improve results of compoundCRS to compoundCRS case (#2130)

 o PROJ4 string import: take into correctly non-metre unit when the string looks
   like the one for WGS 84 / Pseudo Mercator (#2178)

 o Fix support of WKT1_GDAL with netCDF rotated pole formulation (#2187)

 o io.hpp: avoid dependency to proj_json_streaming_writer.hpp (#2188)



_______________________________________________
PROJ mailing list
PROJ at lists.osgeo.org<mailto:PROJ at lists.osgeo.org>
https://lists.osgeo.org/mailman/listinfo/proj
_______________________________________________
PROJ mailing list
PROJ at lists.osgeo.org<mailto:PROJ at lists.osgeo.org>
https://lists.osgeo.org/mailman/listinfo/proj
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20200501/5a6de813/attachment.html>

From kristianevers at gmail.com  Fri May  1 02:00:47 2020
From: kristianevers at gmail.com (Kristian Evers)
Date: Fri, 1 May 2020 11:00:47 +0200
Subject: [PROJ] PROJ 7.0.1 & 6.3.2
Message-ID: <754AD4C9-ADA5-491A-9319-8EF7EAFE6A21@gmail.com>

On behalf of the PROJ development team I am happy to announce the release
of both PROJ 6.3.2 and 7.0.1. These are both bug fix releases and should
provide a more stable experience for PROJ users on both the 6.3 and 7.0
branches.

See release notes below for details. Download the source distributions here: 

https://download.osgeo.org/proj/proj-6.3.2.tar.gz (https://download.osgeo.org/proj/proj-6.3.2.tar.gz.md5) 
https://download.osgeo.org/proj/proj-6.3.2.zip (https://download.osgeo.org/proj/proj-6.3.2.zip.md5)

https://download.osgeo.org/proj/proj-7.0.1.tar.gz (https://download.osgeo.org/proj/proj-7.0.1.tar.gz.md5)
https://download.osgeo.org/proj/proj-7.0.1.zip (https://download.osgeo.org/proj/proj-7.0.1.zip.md5)   



7.0.1 Release Notes
-------------------

Updates
-------

o Database: update to EPSG v9.8.9 (#2141)

Bug fixes
---------

o Make tests independent of proj-datumgrid (#1995)

o Add missing projection property tables (#1996)

o Avoid crash when running against SQLite3 binary built with
  -DSQLITE_OMIT_AUTOINIT (#1999)

o createOperations(): fix wrong pipeline generation with CRS that has +nadgrids=
  and +pm= (#2002)

o Fix bad copy&replace pattern on HEALPix and rHEALPix projection names (#2007)

o createUnitOfMeasure(): use full double resolution for the conversion
  factor (#2014)

o Update README with info on PROJ-data (#2015)

o utm/ups: make sure to set errno to PJD_ERR_ELLIPSOID_USE_REQUIRED if
  es==0 (#2045)

o data/Makefile.am: remove bashism (#2048)

o ProjectedCRS::identify(): tune it to better work with ESRI WKT
  representation of EPSG:2193 (#2059)

o Fix build with gcc 4.8.5 (#2066)

o Autotools/pkg-conf: Define datarootdir (#2069)

o cs2cs: don't require +to for '{source_crs} {target_crs} filename...'
  syntax (#2081)

o CMake: fix bug with find_package(PROJ) with macOS (#2082)

o ESRI WKT import / identification: special case for
  NAD_1983_HARN_StatePlane_Colorado_North_FIPS_0501 with Foot_US unit (#2088)

o ESRI WKT import / identification: special case for
  NAD_1983_HARN_StatePlane_Colorado_North_FIPS_0501 with Foot_US unit (#2089)

o EngineeringCRS: when exporting to WKT1_GDAL, output unit and axis (#2092)

o Use jtsk03-jtsk horizontal grid from CDN (#2098)

o CMake: prefer to use use PROJ_SOURCE_DIR and PROJ_BINARY_DIR (#2100)

o Fix wrong grids file name in esri.sql (#2104)

o Fix identification of projected CRS whose name is close but not strictly
  equal to a ESRI alias (#2106)

o Fix working of Helmert transform between the horizontal part of
  2 compoundCRS (#2111)

o Database: fix registration of custom entries of grid_transformation_custom.sql
  for geoid grids (#2114)

o ESRI_WKT ingestion: make sure to identify to non-deprecated EPSG entry when
  possible (#2119)

o Make sure that importing a Projected 3D CRS from WKT:2019 keeps the base
  geographic CRS as 3D (#2125)

o createOperations(): improve results of compoundCRS to compoundCRS case (#2131)

o hgridshift/vgridshift: defer grid opening when grid has already
  been opened (#2132)

o Resolve a few shadowed declaration warnings (#2142)

o ProjectedCRS identification: deal with switched 1st/2nd std parallels for
  LCC_2SP(#2153)

o Fix Robinson inverse projection (#2154)

o createOperations(): do not remove ballpark transformation if there are only
  grid based operations, even if they cover the whole area of use (#2156)

o createFromCoordinateReferenceSystemCodes(): 'optimization' to avoid using
  C++ exceptions (#2161)

o Ingestion of WKT1_GDAL: correctly map 'Cylindrical_Equal_Area' (#2167)

o Add limited support for non-conformant WKT1 LAS COMPD_CS[] (#2172)

o PROJ4 string import: take into correctly non-metre unit when the string
  looks like the one for WGS 84 / Pseudo Mercator (#2177)

o io.hpp: avoid dependency to proj_json_streaming_writer.hpp (#2184)

o Fix support of WKT1_GDAL with netCDF rotated pole formulation (#2186)



6.3.2 Release Notes
-------------------

Bug fixes
---------

o validateParameters(): fix false-positive warning on
  Equidistant Cylindrical (#1947)

o proj_create_crs_to_crs(): avoid potential reprojection failures when
  reprojecting area of use to source and target CRS (#1993)

o createOperations(): fix wrong pipeline generation with CRS that has +nadgrids=
  and +pm= (#2003)

o Fix bad copy&replace pattern on HEALPix and rHEALPix projection names (#2006)

o createUnitOfMeasure(): use full double resolution for the conversion
  factor (#2013)

o data/Makefile.am: remove bashism (#2047)

o ProjectedCRS::identify(): tune it to better work with ESRI WKT representation
  of EPSG:2193 (#2058)

o EngineeringCRS: when exporting to WKT1_GDAL, output unit and axis (#2091)

o Add missing entries in grid_alternatives for Portugal grids coming from
  ESRI entries (#2103)

o Fix working of Helmert transform between the horizontal part of 2
  compoundCRS (#2110)

o ESRI_WKT ingestion: make sure to identify to non-deprecated EPSG entry when
  possible (#2118)

o Make sure that importing a Projected 3D CRS from WKT:2019 keeps the base
  geographic CRS as 3D (#2124)

o createOperations(): improve results of compoundCRS to compoundCRS case (#2130)

o PROJ4 string import: take into correctly non-metre unit when the string looks
  like the one for WGS 84 / Pseudo Mercator (#2178)

o Fix support of WKT1_GDAL with netCDF rotated pole formulation (#2187)

o io.hpp: avoid dependency to proj_json_streaming_writer.hpp (#2188)

From dalia at lmi.is  Mon May  4 03:13:13 2020
From: dalia at lmi.is (Dalia Prizginiene)
Date: Mon, 4 May 2020 10:13:13 +0000
Subject: [PROJ] ct2 format to GTG
Message-ID: <DB8PR09MB27934088D0D59CF0B7CA6464C7A60@DB8PR09MB2793.eurprd09.prod.outlook.com>

Hello,
For Proj7 all grids must be transformed to GTG format. We have two grids in .ct2 format
But I can not find a script in PROJ-data/grid_tools  for ct2 to GTG transformation. Could you give some suggestions on this ?

Með kveðju/ Best regards
Dalia

--------------
Dalia Prizginiene
Landmælingar Íslands /  National Land Survey of Iceland
Mælingaverkfræðingur / GNSS Processing
Stillholt 16 - 18, 300 Akranes, +354 430 9006
www.lmi.is<http://www.lmi.is/> / Facebook<https://www.facebook.com/landmaelingar.islands?fref=ts> / Um meðferð tölvupósts / Disclaimer<http://www.lmi.is/landmaelingar-islands/medferd-tolvuposts/>

Hugið að umhverfinu áður en prentað er
Please consider the environment before printing

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20200504/e74b87f2/attachment.html>

From kreve at sdfe.dk  Mon May  4 03:32:16 2020
From: kreve at sdfe.dk (Kristian Evers)
Date: Mon, 4 May 2020 10:32:16 +0000
Subject: [PROJ] ct2 format to GTG
In-Reply-To: <DB8PR09MB27934088D0D59CF0B7CA6464C7A60@DB8PR09MB2793.eurprd09.prod.outlook.com>
References: <DB8PR09MB27934088D0D59CF0B7CA6464C7A60@DB8PR09MB2793.eurprd09.prod.outlook.com>
Message-ID: <5401e023cdf442f491783dd7ff8e5370@sdfe.dk>

Hi Dalia

First of all, PROJ 7 can read ct2 files so you don't have to convert them. But of course the GTG is a better format so I would encourage you to do so. What files are you trying to convert? All the grid files that you have previously submitted to proj-datumgrid have all been converted to GTG as you can see here: https://github.com/OSGeo/PROJ-data/tree/master/is_lmi

/Kristian

From: PROJ <proj-bounces at lists.osgeo.org> On Behalf Of Dalia Prizginiene
Sent: 4. maj 2020 12:13
To: proj at lists.osgeo.org
Subject: [PROJ] ct2 format to GTG

Hello,
For Proj7 all grids must be transformed to GTG format. We have two grids in .ct2 format
But I can not find a script in PROJ-data/grid_tools  for ct2 to GTG transformation. Could you give some suggestions on this ?

Með kveðju/ Best regards
Dalia

--------------
Dalia Prizginiene
Landmælingar Íslands /  National Land Survey of Iceland
Mælingaverkfræðingur / GNSS Processing
Stillholt 16 - 18, 300 Akranes, +354 430 9006
www.lmi.is<http://www.lmi.is/> / Facebook<https://www.facebook.com/landmaelingar.islands?fref=ts> / Um meðferð tölvupósts / Disclaimer<http://www.lmi.is/landmaelingar-islands/medferd-tolvuposts/>

Hugið að umhverfinu áður en prentað er
Please consider the environment before printing

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20200504/2d4df2c2/attachment.html>

From even.rouault at spatialys.com  Mon May  4 03:42:42 2020
From: even.rouault at spatialys.com (Even Rouault)
Date: Mon, 04 May 2020 12:42:42 +0200
Subject: [PROJ] ct2 format to GTG
In-Reply-To: <DB8PR09MB27934088D0D59CF0B7CA6464C7A60@DB8PR09MB2793.eurprd09.prod.outlook.com>
References: <DB8PR09MB27934088D0D59CF0B7CA6464C7A60@DB8PR09MB2793.eurprd09.prod.outlook.com>
Message-ID: <1974721.93CzYfuoxq@even-i700>

Dalia,

> For Proj7 all grids must be transformed to GTG format. 

You can still use the old formats, but this is considered as legacy.

> We have two grids in
> .ct2 format But I can not find a script in PROJ-data/grid_tools  for ct2 to
> GTG transformation. Could you give some suggestions on this ?

There's no ready-made script for that as .ct2 use is (thought to be) not widespread.

If it is just a single .ct2 file with a longitude and latitude offset, then,
- you can use "gdal_translate your.ct2 your.vrt -of VRT"
- edit the VRT to add all required and recommended metadata items as per the GTG spec 
(attached an example of a VRT file corresponding to a combination of a .ct2 + .gtx to give you 
an idea on how to insert metadata)
- convert the VRT to TIFF with:
	gdal_translate your.vrt your.tif -co COMPRESS=DEFLATE
		-co BLOCKYSIZE=YYY -co INTERLEAVE=BAND
  where YYY is the height of the grid if YYY <= 512
  Otherwise replace -co BLOCKYSIZE=YYY with -co TILED=YES
- run the check_gtiff_grid.py script to validate everything is right

If the .ct2 file is combined with a .gtx file to have for example a velocity grid, like 
is_lmi_ISN_vel_beta.tif, then you can apply pretty much the above method by converting first 
the .ct2 to VRT, and manually edit it to combine the .gtx band.

Even

-- 
Spatialys - Geospatial professional services
http://www.spatialys.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20200504/c50ea9ff/attachment-0001.html>
-------------- next part --------------
<VRTDataset rasterXSize="223" rasterYSize="241">
  <SRS dataAxisToSRSAxisMapping="2,1">GEOGCRS["Unknown based on GRS80",
    DATUM["Unknown based on GRS80",
        ELLIPSOID["GRS 1980",6378137,298.257222101,
            LENGTHUNIT["metre",1]]],
    PRIMEM["Greenwich",0,
        ANGLEUNIT["degree",0.0174532925199433]],
    CS[ellipsoidal,2],
        AXIS["geodetic latitude (Lat)",north,
            ORDER[1],
            ANGLEUNIT["degree",0.0174532925199433]],
        AXIS["geodetic longitude (Lon)",east,
            ORDER[2],
            ANGLEUNIT["degree",0.0174532925199433]]]
</SRS>
  <GeoTransform>  2.9166666666666670e+00,  1.6666666666666666e-01,  0.0000000000000000e+00,  7.3041666666666686e+01,  0.0000000000000000e+00, -8.3333333333333329e-02</GeoTransform>
  <Metadata>
    <MDI key="DESCRIPTION"></MDI>
    <MDI key="area_of_use">Nordic and Baltic countries</MDI>
    <MDI key="AREA_OR_POINT">Point</MDI>
    <MDI key="TIFFTAG_COPYRIGHT">The Nordic Geodetic Commission. Creative Commons Attribution 4.0 https://creativecommons.org/licenses/by/4.0/</MDI>
    <MDI key="TIFFTAG_DATETIME">2019:12:30 00:00:00</MDI>
    <MDI key="TIFFTAG_IMAGEDESCRIPTION">Deformation model covering the Nordic and Baltic countries. Used in transformations between global reference frames and the local realisations of ETRS89 in the Nordic and Baltic countries</MDI>
    <MDI key="TYPE">VELOCITY</MDI>
  </Metadata>
  <VRTRasterBand dataType="Float32" band="1">
    <Description>east_velocity</Description>
    <UnitType>millimetres per year</UnitType>
    <SimpleSource>
      <SourceFilename relativeToVRT="0">/home/even/proj/proj-datumgrid/europe/nkgrf03vel_realigned_xy.ct2</SourceFilename>
      <SourceBand>2</SourceBand> <!-- GDAL exposes the first physical component of the file (longitude offset normally, here east velocity) as the second band -->
      <SrcRect xOff="0" yOff="0" xSize="223" ySize="241" />
      <DstRect xOff="0" yOff="0" xSize="223" ySize="241" />
    </SimpleSource>
  </VRTRasterBand>
  <VRTRasterBand dataType="Float32" band="2">
    <Description>north_velocity</Description>
    <UnitType>millimetres per year</UnitType>
    <SimpleSource>
      <SourceFilename relativeToVRT="0">/home/even/proj/proj-datumgrid/europe/nkgrf03vel_realigned_xy.ct2</SourceFilename>
      <SourceBand>1</SourceBand> <!-- and the second physical component (latitude offset normally, here north velocity) as the first band -->
      <SrcRect xOff="0" yOff="0" xSize="223" ySize="241" />
      <DstRect xOff="0" yOff="0" xSize="223" ySize="241" />
    </SimpleSource>
  </VRTRasterBand>
  <VRTRasterBand dataType="Float32" band="3">
    <Description>up_velocity</Description>
    <UnitType>millimetres per year</UnitType>
    <SimpleSource>
      <SourceFilename relativeToVRT="0">/home/even/proj/proj-datumgrid/europe/nkgrf03vel_realigned_z.gtx</SourceFilename>
      <SourceBand>1</SourceBand>
      <SrcRect xOff="0" yOff="0" xSize="223" ySize="241" />
      <DstRect xOff="0" yOff="0" xSize="223" ySize="241" />
    </SimpleSource>
  </VRTRasterBand>
</VRTDataset>

From nyall.dawson at gmail.com  Wed May  6 12:20:32 2020
From: nyall.dawson at gmail.com (Nyall Dawson)
Date: Thu, 7 May 2020 05:20:32 +1000
Subject: [PROJ] Matching EPSG:3005
Message-ID: <CAB28AsgFuqbcBtrQPxN6K3sCatN29ROKnvJOnSA2g9pp6dkS0w@mail.gmail.com>

Hi list!

I suspect I'm overlooking something obvious, but I've read and re-read
this multiple times and can't spot it!

When attempting the identify the WKT string

PROJCS["NAD83 / BC Albers", GEOGCS [ "NAD83", DATUM ["North American
Datum 1983 (EPSG ID 6269)", SPHEROID ["GRS 1980 (EPSG ID 7019)",
6378137.0, 298.257222101]], PRIMEM [ "Greenwich", 0.000000 ], UNIT
["Decimal Degree", 0.0174532925199433]], PROJECTION ["Albers Conical
Equal Area"], PARAMETER ["Latitude_Of_Origin", 45.0], PARAMETER
["Central_Meridian", -126.0], PARAMETER ["Standard_Parallel_1", 50.0],
PARAMETER ["Standard_Parallel_2", 58.5], PARAMETER ["False_Easting",
1000000.0], PARAMETER ["False_Northing", 0.0], UNIT ["Meter", 1.0]]

I get a 25% match to EPSG:3005. Yet (obvious differences in the
various names aside) this DOES look equivalent to the definition
returned by projinfo EPSG:3005 -o WKT1_ESRI:

PROJCS["NAD_1983_BC_Environment_Albers",GEOGCS["GCS_North_American_1983",DATUM["D_North_American_1983",SPHEROID["GRS_1980",6378137.0,298.257222101]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Albers"],PARAMETER["False_Easting",1000000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",-126.0],PARAMETER["Standard_Parallel_1",50.0],PARAMETER["Standard_Parallel_2",58.5],PARAMETER["Latitude_Of_Origin",45.0],UNIT["Meter",1.0]]

Why do I only get a 25% confidence match here?

Nyall

From even.rouault at spatialys.com  Wed May  6 12:46:30 2020
From: even.rouault at spatialys.com (Even Rouault)
Date: Wed, 06 May 2020 21:46:30 +0200
Subject: [PROJ] Matching EPSG:3005
In-Reply-To: <CAB28AsgFuqbcBtrQPxN6K3sCatN29ROKnvJOnSA2g9pp6dkS0w@mail.gmail.com>
References: <CAB28AsgFuqbcBtrQPxN6K3sCatN29ROKnvJOnSA2g9pp6dkS0w@mail.gmail.com>
Message-ID: <13050144.EOgUeszHDS@even-i700>

Hi Nyall,

> I suspect I'm overlooking something obvious, but I've read and re-read
> this multiple times and can't spot it!
> 
> When attempting the identify the WKT string
> 
> PROJCS["NAD83 / BC Albers", GEOGCS [ "NAD83", DATUM ["North American
> Datum 1983 (EPSG ID 6269)", SPHEROID ["GRS 1980 (EPSG ID 7019)",
> 6378137.0, 298.257222101]], PRIMEM [ "Greenwich", 0.000000 ], UNIT
> ["Decimal Degree", 0.0174532925199433]], PROJECTION ["Albers Conical
> Equal Area"], PARAMETER ["Latitude_Of_Origin", 45.0], PARAMETER
> ["Central_Meridian", -126.0], PARAMETER ["Standard_Parallel_1", 50.0],
> PARAMETER ["Standard_Parallel_2", 58.5], PARAMETER ["False_Easting",
> 1000000.0], PARAMETER ["False_Northing", 0.0], UNIT ["Meter", 1.0]]
> 
> I get a 25% match to EPSG:3005. Yet (obvious differences in the
> various names aside) this DOES look equivalent to the definition
> returned by projinfo EPSG:3005 -o WKT1_ESRI:
> 
> PROJCS["NAD_1983_BC_Environment_Albers",GEOGCS["GCS_North_American_1983",DAT
> UM["D_North_American_1983",SPHEROID["GRS_1980",6378137.0,298.257222101]],PRI
> MEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Albers"]
> ,PARAMETER["False_Easting",1000000.0],PARAMETER["False_Northing",0.0],PARAME
> TER["Central_Meridian",-126.0],PARAMETER["Standard_Parallel_1",50.0],PARAMET
> ER["Standard_Parallel_2",58.5],PARAMETER["Latitude_Of_Origin",45.0],UNIT["Me
> ter",1.0]]
> 
> Why do I only get a 25% confidence match here?

Do not hesitate to give the full context for your question. I suspect this is related to https://
github.com/qgis/QGIS/issues/36216 and Oracle WKT.

First, there's no particular effort in PROJ to deal with and "normalize" (that is use EPSG 
official names) Oracle WKT, so I'm not surprised that it doesn't work out of the box.

So let's play the "spot the difference" game.

One thing that I can see, is that, as PROJ doesn't (yet ?) include an IA, "North American 
Datum 1983 (EPSG ID 6269)" and "North American Datum 1983" are considered to be 
different.

Another more annoying reason is that when actually feeding the Oracle WKT in projinfo it 
reports "Unsupported conversion method: Albers Conical Equal Area", because it doesn't 
know this variant of the projection method name.

So I was rather surprised you got any identification at all. This is only due to just "NAD83 / BC 
Albers" matching exactly the EPSG name for this CRS.
Generally, the identification is done with the "normalized" names, so even if the Oracle WKT 
and ESRI WKT look similar, only the proximity of the ingested & potentially normalized WKT 
you try to identify with the WKT2_2019 output of the candidates CRS matters.

Even


-- 
Spatialys - Geospatial professional services
http://www.spatialys.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20200506/a2f9bdf6/attachment.html>

From nyall.dawson at gmail.com  Wed May  6 13:23:37 2020
From: nyall.dawson at gmail.com (Nyall Dawson)
Date: Thu, 7 May 2020 06:23:37 +1000
Subject: [PROJ] Matching EPSG:3005
In-Reply-To: <13050144.EOgUeszHDS@even-i700>
References: <CAB28AsgFuqbcBtrQPxN6K3sCatN29ROKnvJOnSA2g9pp6dkS0w@mail.gmail.com>
 <13050144.EOgUeszHDS@even-i700>
Message-ID: <CAB28AsgnCfTm84Ap88yT8PZVU=g4vpqn2BdCCQmFfpj35RJe8Q@mail.gmail.com>

On Thu, 7 May 2020 at 05:46, Even Rouault <even.rouault at spatialys.com> wrote:

> Do not hesitate to give the full context for your question. I suspect this is related to https://github.com/qgis/QGIS/issues/36216 and Oracle WKT.

Correct! I'm mid way through a reply to that (but I'm blaming Oracle
here, not proj!)

> First, there's no particular effort in PROJ to deal with and "normalize" (that is use EPSG official names) Oracle WKT, so I'm not surprised that it doesn't work out of the box.

I guess I misunderstood the proj docs: "90% means that CRS are
equivalent, but the names are not exactly the same.". I assumed this
meant that a 90% match would ignore things like the
NAD83/GCS_North_American_1983 differences. But I'm guessing now that
there's only **some** names in the wkt which can vary?

> One thing that I can see, is that, as PROJ doesn't (yet ?) include an IA, "North American Datum 1983 (EPSG ID 6269)" and "North American Datum 1983" are considered to be different.

Can you clarify what IA stands for?

> Another more annoying reason is that when actually feeding the Oracle WKT in projinfo it reports "Unsupported conversion method: Albers Conical Equal Area", because it doesn't know this variant of the projection method name.

I did try with replacing this with the versions used by PROJ, but that
didn't alter the match at all.

Looks like Oracle is definitely at fault here. But for my own
curiosity, what else is missing in proj to allow identifying this
definition (aside for an alias to match "Albers Conical Equal Area")?

Nyall

From even.rouault at spatialys.com  Wed May  6 14:09:59 2020
From: even.rouault at spatialys.com (Even Rouault)
Date: Wed, 06 May 2020 23:09:59 +0200
Subject: [PROJ] Matching EPSG:3005
In-Reply-To: <CAB28AsgnCfTm84Ap88yT8PZVU=g4vpqn2BdCCQmFfpj35RJe8Q@mail.gmail.com>
References: <CAB28AsgFuqbcBtrQPxN6K3sCatN29ROKnvJOnSA2g9pp6dkS0w@mail.gmail.com>
 <13050144.EOgUeszHDS@even-i700>
 <CAB28AsgnCfTm84Ap88yT8PZVU=g4vpqn2BdCCQmFfpj35RJe8Q@mail.gmail.com>
Message-ID: <1892028.DZFQNOxmNK@even-i700>

On jeudi 7 mai 2020 06:23:37 CEST Nyall Dawson wrote:
> On Thu, 7 May 2020 at 05:46, Even Rouault <even.rouault at spatialys.com> wrote:
> > Do not hesitate to give the full context for your question. I suspect this
> > is related to https://github.com/qgis/QGIS/issues/36216 and Oracle WKT.
> Correct! I'm mid way through a reply to that (but I'm blaming Oracle
> here, not proj!)

Would I be mean if I'd point that they opted for not being part of the team supporting the 
GDAL barn effort :-) ?

> I guess I misunderstood the proj docs: "90% means that CRS are
> equivalent, but the names are not exactly the same.". I assumed this
> meant that a 90% match would ignore things like the
> NAD83/GCS_North_American_1983 differences. But I'm guessing now that
> there's only **some** names in the wkt which can vary?

Yes I believe this is only on the "top" name of the CRS. Datum names need to match quite 
closely. With PROJ current accuracy, you cannot really consider that NAD83 ~= NAD83(2011) 
or GDA94 ~= GDA2020. Of course as humans we are able to identify that "North American 
Datum 1983 (EPSG ID 6269)" is the same as "North American Datum 1983"

> Can you clarify what IA stands for?

Ah, sorry, I meant AI = Artificial Intelligence. (IA = Intelligence Artificielle in French)

> I did try with replacing this with the versions used by PROJ, but that
> didn't alter the match at all.

Yes, the normalization of the non-WKT2 parameter names is not done if you use the WKT2 
projection method name. If you use the WKT1_GDAL one (Albers_Conic_Equal_Area), it will 
be done.

So the following identifies to EPSG:3005 at 100%

PROJCS["NAD83 / BC Albers", GEOGCS [ "NAD83", DATUM ["North American Datum 1983", 
SPHEROID ["GRS 1980 (EPSG ID 7019)", 6378137.0, 298.257222101]], PRIMEM [ "Greenwich", 
0.000000 ], UNIT ["Decimal Degree", 0.0174532925199433]], PROJECTION 
["Albers_Conic_Equal_Area"], PARAMETER ["Latitude_Of_Origin", 45.0], PARAMETER 
["Central_Meridian", -126.0], PARAMETER ["Standard_Parallel_1", 50.0], PARAMETER 
["Standard_Parallel_2", 58.5], PARAMETER ["False_Easting", 1000000.0], PARAMETER 
["False_Northing", 0.0], UNIT ["Meter", 1.0]]

> Looks like Oracle is definitely at fault here.

Well, WKT has a long history of not being super interoperable, and not sure this has really 
been solved... In 2007, Frank Warmerdam collected some of the mess in the WKT world: 
https://gdal.org/tutorials/wktproblems.html . Part of it is probably outdated now.

> But for my own
> curiosity, what else is missing in proj to allow identifying this
> definition (aside for an alias to match "Albers Conical Equal Area")?

Just the above: triggering normalization of parameter names from WKT1 if "Albers Conical 
Equal Area" is found

-- 
Spatialys - Geospatial professional services
http://www.spatialys.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20200506/76f35a06/attachment-0001.html>

From nyall.dawson at gmail.com  Wed May  6 15:04:25 2020
From: nyall.dawson at gmail.com (Nyall Dawson)
Date: Thu, 7 May 2020 08:04:25 +1000
Subject: [PROJ] Matching EPSG:3005
In-Reply-To: <1892028.DZFQNOxmNK@even-i700>
References: <CAB28AsgFuqbcBtrQPxN6K3sCatN29ROKnvJOnSA2g9pp6dkS0w@mail.gmail.com>
 <13050144.EOgUeszHDS@even-i700>
 <CAB28AsgnCfTm84Ap88yT8PZVU=g4vpqn2BdCCQmFfpj35RJe8Q@mail.gmail.com>
 <1892028.DZFQNOxmNK@even-i700>
Message-ID: <CAB28Ash_aPSxEoWboELzAwbc+nWNLy4GwZfMrz_B2EAWg+kSjA@mail.gmail.com>

On Thu, 7 May 2020 at 07:10, Even Rouault <even.rouault at spatialys.com> wrote:
>
> On jeudi 7 mai 2020 06:23:37 CEST Nyall Dawson wrote:
>
> > On Thu, 7 May 2020 at 05:46, Even Rouault <even.rouault at spatialys.com> wrote:
>
> > > Do not hesitate to give the full context for your question. I suspect this
>
> > > is related to https://github.com/qgis/QGIS/issues/36216 and Oracle WKT.
>
> > Correct! I'm mid way through a reply to that (but I'm blaming Oracle
>
> > here, not proj!)
>
>
>
> Would I be mean if I'd point that they opted for not being part of the team supporting the GDAL barn effort :-) ?
>
>
Thanks for the explanations!

Given the above, I've closed off the issue with this resolution:

"So the fix here would be:

Speak to your oracle rep and request that they fix the incorrect
authority definition in mdsys.cs_srs
Pressure your oracle sales rep to get Oracle to fund improvements in
the proj library to handle Oracle's "special" variants of WKT"

(Because I'm with you, and have 0 motivation to spend any effort
supporting such a fundamentally shitty database)

Nyall

From sgh at sgh.dk  Thu May  7 07:57:22 2020
From: sgh at sgh.dk (=?ISO-8859-1?Q?S=F8ren?= Holm)
Date: Thu, 07 May 2020 16:57:22 +0200
Subject: [PROJ] The state of PROJ C++ 2020
Message-ID: <4647631.x7YV6tmGiP@koontz>

Hi

Because of some technical reasons we are still using proj 5.1.0 but we are 
working on migrating to never versions. During that work to make sure 
everything works no matter if it is compiled against 5.1 or 6.x I noticed the 
horrors of modern C++ to it's full extend.

PROJ 5.1 (released 2018-05-24) contains around 204 c-files and 2 cpp-files. It 
takes 12 seconds to compile on my system. PROJ 6.3.0.1 (released 2019-12-28) 
contains 223 cpp-files and 17 c-files and takes 220 seconds to compile on my 
system.

I know that PROJ 6.3.0 contains more code (approx x3) and the tests take a 
long time to compile because of google-test but subtracting those 20 test-
files (2 seconds each) still leaves 6.3.0 with a compiletime 165 longer that 
5.1.0.

It might just be that I am old or something (apparently 39 is old these days), 
but it seems to me that taking a working software library and increasing 
linecount x3 while increasing compiletime x10 without adding new files is just 
crazy.

Is it realy worth it?
Is it easier to maintain?
Do we get better performance (I doubt it)?
How about portability?

-- 
Søren Holm



From howard at hobu.co  Thu May  7 08:54:56 2020
From: howard at hobu.co (Howard Butler)
Date: Thu, 7 May 2020 10:54:56 -0500
Subject: [PROJ] The state of PROJ C++ 2020
In-Reply-To: <4647631.x7YV6tmGiP@koontz>
References: <4647631.x7YV6tmGiP@koontz>
Message-ID: <6CAF6A0D-B6FD-4EDF-B3F6-530D02D3E12D@hobu.co>



> On May 7, 2020, at 9:57 AM, Søren Holm <sgh at sgh.dk> wrote:

> 
> I know that PROJ 6.3.0 contains more code (approx x3) and the tests take a 
> long time to compile because of google-test but subtracting those 20 test-
> files (2 seconds each) still leaves 6.3.0 with a compiletime 165 longer that 
> 5.1.0.

Compile times matter to you? If you are recompiling PROJ so much, where are all your pull requests? 

> It might just be that I am old or something (apparently 39 is old these days), 
> but it seems to me that taking a working software library and increasing 
> linecount x3 while increasing compiletime x10 without adding new files is just 
> crazy.

You are welcome to keep using PROJ 5.1.0 indefinitely. That's the beauty of open source. You are not forced to upgrade.

> Is it realy worth it?
> Is it easier to maintain?
> Do we get better performance (I doubt it)?
> How about portability?

It's worth it to me, because PROJ 5.1 produced wrong answers for any sufficiently interesting geodetic transformations. As geodetic agencies move toward space-based geodesy and time dependent coordinate systems, that problem was going to get much worse. Without the updates that PROJ received over the past two+ years, software dependent upon PROJ would have been producing incorrect values. Those incorrect answers would have had consequences in the form of PROJ-based software being disallowed in situations where geodetic accuracy matters. YOU might not need that, but the active contributors and sponsors that supported gdalbarn.com <http://gdalbarn.com/> did. As a result, PROJ is now one of the most advanced capability software libraries available commercial or otherwise in this regard.

PROJ has more active contributors now than it has in its 35+ year lifespan. Indeed there is more to maintain because more is being asked of the software. There's more docs and more tests than at any point in the project's lifespan too.

The project would be very interested in performance metrics, numbers, and examples. The PostGIS and QGIS projects have provided a ton of performance feedback that has resulted in many significant improvements. Disappointingly, commercial users of PROJ did not provide much feedback on the topic at all to date.

As for portability, that costs. Is your organization offering to support portability through contributed time or money? 

Howard


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20200507/193ba598/attachment.html>

From martin.desruisseaux at geomatys.com  Thu May  7 08:57:10 2020
From: martin.desruisseaux at geomatys.com (Martin Desruisseaux)
Date: Thu, 7 May 2020 17:57:10 +0200
Subject: [PROJ] The state of PROJ C++ 2020
In-Reply-To: <4647631.x7YV6tmGiP@koontz>
References: <4647631.x7YV6tmGiP@koontz>
Message-ID: <085c23fe-b31d-c2f4-26b8-1b9640d7fb0f@geomatys.com>

Hello Søren

I will let other peoples answer for maintenance, portability and 
performance parts. The one area I'm more familiar with is the conceptual 
model behind PROJ 6 C++ API. The PROJ 4 model was designed for map 
projections, not really for the more general topic of coordinate 
transformations (including datum shifts). Even if PROJ 4 was capable to 
do some datum shifts, the use of WGS 84 as an universal hub made 
impossible to achieve sub-metric precision for some pairs of source and 
target Coordinate Reference System (CRS).

On the question about whether it is worth or not, it depends on the 
desired accuracy. Not everyone needs centimetric precision. But my 
opinion is that it is okay to use approximations provided that we tell 
users which accuracy (s)he can expect, so (s)he can decide if it is 
sufficient for their needs or not. The PROJ 4 model had no room for this 
information and was luring users with a false sense of accuracy. It did 
not had neither information for telling user that (s)he is using a 
coordinate operation outside its domain of validity. The PROJ 6 model 
fixes those shortcomings, among other issues.

The PROJ 6 model is derived from an international standard, ISO 19111, 
which has more capabilities than what is currently implemented. By using 
this model, PROJ 6 also prepares itself for future evolution on topics 
like dynamic datum. It is true that the ISO 19111 model is much more 
complex than the PROJ 4 model, but this complexity reflects the 
complexity of accurate geodesy on Earth.

     Regards,

         Martin


Le 07/05/2020 à 16:57, Søren Holm a écrit :

> Hi
>
> Because of some technical reasons we are still using proj 5.1.0 but we are
> working on migrating to never versions. During that work to make sure
> everything works no matter if it is compiled against 5.1 or 6.x I noticed the
> horrors of modern C++ to it's full extend.
>
> PROJ 5.1 (released 2018-05-24) contains around 204 c-files and 2 cpp-files. It
> takes 12 seconds to compile on my system. PROJ 6.3.0.1 (released 2019-12-28)
> contains 223 cpp-files and 17 c-files and takes 220 seconds to compile on my
> system.
>
> I know that PROJ 6.3.0 contains more code (approx x3) and the tests take a
> long time to compile because of google-test but subtracting those 20 test-
> files (2 seconds each) still leaves 6.3.0 with a compiletime 165 longer that
> 5.1.0.
>
> It might just be that I am old or something (apparently 39 is old these days),
> but it seems to me that taking a working software library and increasing
> linecount x3 while increasing compiletime x10 without adding new files is just
> crazy.
>
> Is it realy worth it?
> Is it easier to maintain?
> Do we get better performance (I doubt it)?
> How about portability?
>

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20200507/3e0dc21e/attachment.html>

From sgh at sgh.dk  Thu May  7 09:31:16 2020
From: sgh at sgh.dk (=?ISO-8859-1?Q?S=F8ren?= Holm)
Date: Thu, 07 May 2020 18:31:16 +0200
Subject: [PROJ] The state of PROJ C++ 2020
In-Reply-To: <085c23fe-b31d-c2f4-26b8-1b9640d7fb0f@geomatys.com>
References: <4647631.x7YV6tmGiP@koontz>
 <085c23fe-b31d-c2f4-26b8-1b9640d7fb0f@geomatys.com>
Message-ID: <6184201.E2rLHS4oeR@koontz>

Thank you for the answers Martin and Howard.

I realy like that the precision of proj has increase comparing to earlier proj 
versions. Also the readyness for future evolution is great. I did not question 
any of that.

I do however not understand why the precision and future evolution readiness - 
which are features in inself - is brough into a purely language oriented 
question. I'm quite sure that using C or C++ without the stuff that makes it 
slow can be just as precise as anything else. 

I clearly I do not compile PROJ all the time, but that kind of standpoint 
leads to ever increasing compiletimes for developers and users.

Lastly I just want to say that I did not write these email to start a 
discussion. It was a mere combination of:

"Hey, thing thing is takes 10 times longer to compile, Why is that?" 

      and 

"If my software projects compile time increased 10 fold I would see it as a 
bug."



-- 
Søren Holm



From martin.desruisseaux at geomatys.com  Thu May  7 10:03:23 2020
From: martin.desruisseaux at geomatys.com (Martin Desruisseaux)
Date: Thu, 7 May 2020 19:03:23 +0200
Subject: [PROJ] The state of PROJ C++ 2020
In-Reply-To: <4272984.Nx0Bj934n7@koontz>
References: <4647631.x7YV6tmGiP@koontz>
 <085c23fe-b31d-c2f4-26b8-1b9640d7fb0f@geomatys.com>
 <4272984.Nx0Bj934n7@koontz>
Message-ID: <250c5961-1d93-dd41-3eae-6fa377414e02@geomatys.com>

Hello Søren

Le 07/05/2020 à 18:24, Søren Holm a écrit :

> I do however not understand why the precision and future evolution readiness -
> which are features in inself - is brough into a purely language oriented
> question. I'm quite sure that using C or C++ without the stuff that makes it
> slow can be just as precise as anything else.

The discussion about precision was an attempt to explain why PROJ 6 
become larger and in some circumstances slower. Improving the precision 
required a more extensive use of EPSG geodetic database than what PROJ 4 
did. Answering to the question "what is the transformation from A to B" 
requires a search in the database. PROJ 4 by contrast was trying to 
answer this question with a little bit of logic in the code, which was 
insufficient (the CSV files were not provided required information). It 
seems hard to me to get the functionality of relatively complex queries 
in a relational database with only a few changes in PROJ 4 C code, 
without SQLite or something similar.

The discussion about future evolution was an attempt to explain why PROJ 
6 got a C++ API much larger than the previous C API. This C++ API is a 
consequence of the decision to follow OGC/ISO standards, which are a bit 
large but usually for good reasons I think. The weight of ISO/OGC 
standards sometime looks like useless complexity, but my experience in 
20 years of use of those standards is that (in my opinion) the 
geodesists who designed them have done a pretty good job of addressing 
"real world" problems that, as developers, we hardly imagine before years.

     Martin


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20200507/1c81fd20/attachment-0001.html>

From sebastic at xs4all.nl  Thu May  7 10:03:41 2020
From: sebastic at xs4all.nl (Sebastiaan Couwenberg)
Date: Thu, 7 May 2020 19:03:41 +0200
Subject: [PROJ] The state of PROJ C++ 2020
In-Reply-To: <6184201.E2rLHS4oeR@koontz>
References: <4647631.x7YV6tmGiP@koontz>
 <085c23fe-b31d-c2f4-26b8-1b9640d7fb0f@geomatys.com>
 <6184201.E2rLHS4oeR@koontz>
Message-ID: <4395811b-0a51-f8a7-8b18-bd7a978cafc3@xs4all.nl>

On 5/7/20 6:31 PM, Søren Holm wrote:
> I do however not understand why the precision and future evolution readiness - 
> which are features in inself - is brough into a purely language oriented 
> question. I'm quite sure that using C or C++ without the stuff that makes it 
> slow can be just as precise as anything else. 

You should read this thread:

 https://lists.osgeo.org/pipermail/proj/2018-May/007799.html

> Lastly I just want to say that I did not write these email to start a 
> discussion. It was a mere combination of:
> 
> "Hey, thing thing is takes 10 times longer to compile, Why is that?" 
> 
>       and 
> 
> "If my software projects compile time increased 10 fold I would see it as a 
> bug."

Mailinglists are for discussions, issue trackers are for bugs.

If you're concerned about the increased time it takes to build software,
you haven't been building QGIS since before 3.x and you should stay away
from it.

Kind Regards,

Bas

-- 
 GPG Key ID: 4096R/6750F10AE88D4AF1
Fingerprint: 8182 DE41 7056 408D 6146  50D1 6750 F10A E88D 4AF1

From schwehr at gmail.com  Thu May  7 12:09:23 2020
From: schwehr at gmail.com (Kurt Schwehr)
Date: Thu, 7 May 2020 12:09:23 -0700
Subject: [PROJ] The state of PROJ C++ 2020
In-Reply-To: <4395811b-0a51-f8a7-8b18-bd7a978cafc3@xs4all.nl>
References: <4647631.x7YV6tmGiP@koontz>
 <085c23fe-b31d-c2f4-26b8-1b9640d7fb0f@geomatys.com>
 <6184201.E2rLHS4oeR@koontz> <4395811b-0a51-f8a7-8b18-bd7a978cafc3@xs4all.nl>
Message-ID: <CACmBxysxHcw802mvdP=7_5yyX9hki4DcMWzfEFgJbi8HZmPtGA@mail.gmail.com>

See also other projects' discussions on the topic.

e.g. https://gdal.org/development/rfc/rfc68_cplusplus11.html

On Thu, May 7, 2020 at 10:10 AM Sebastiaan Couwenberg <sebastic at xs4all.nl>
wrote:

> On 5/7/20 6:31 PM, Søren Holm wrote:
> > I do however not understand why the precision and future evolution
> readiness -
> > which are features in inself - is brough into a purely language oriented
> > question. I'm quite sure that using C or C++ without the stuff that
> makes it
> > slow can be just as precise as anything else.
>
> You should read this thread:
>
>  https://lists.osgeo.org/pipermail/proj/2018-May/007799.html
>
> > Lastly I just want to say that I did not write these email to start a
> > discussion. It was a mere combination of:
> >
> > "Hey, thing thing is takes 10 times longer to compile, Why is that?"
> >
> >       and
> >
> > "If my software projects compile time increased 10 fold I would see it
> as a
> > bug."
>
> Mailinglists are for discussions, issue trackers are for bugs.
>
> If you're concerned about the increased time it takes to build software,
> you haven't been building QGIS since before 3.x and you should stay away
> from it.
>
> Kind Regards,
>
> Bas
>
> --
>  GPG Key ID: 4096R/6750F10AE88D4AF1
> Fingerprint: 8182 DE41 7056 408D 6146  50D1 6750 F10A E88D 4AF1
> _______________________________________________
> PROJ mailing list
> PROJ at lists.osgeo.org
> https://lists.osgeo.org/mailman/listinfo/proj
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20200507/abce5e79/attachment.html>

From knudsen.thomas at gmail.com  Thu May  7 12:29:38 2020
From: knudsen.thomas at gmail.com (Thomas Knudsen)
Date: Thu, 7 May 2020 21:29:38 +0200
Subject: [PROJ] The state of PROJ C++ 2020
In-Reply-To: <6184201.E2rLHS4oeR@koontz>
References: <4647631.x7YV6tmGiP@koontz>
 <085c23fe-b31d-c2f4-26b8-1b9640d7fb0f@geomatys.com>
 <6184201.E2rLHS4oeR@koontz>
Message-ID: <CAH0YoEPfaSPJVuXo95z3_HPxc7oDsPksDmtpqAfQ16yDELt6rQ@mail.gmail.com>

Søren,

Bas already referred you to another relevant thread from 2018. But for
completeness,
please let me quote my own concluding remark from that thread, which I in
the meantime
have had no reason to regret:

Even>* OK let me try to summarize my thoughts in a bullet list fashion*

Thomas:

... misread that as "thoughts in a bullshit fashion" :-)

Although I will probably never grow up to actually *love* C++,
I occasionally fall in love with the "the much smaller and cleaner
language struggling to get out" (as C++ creator Bjarne Stroustrup
stated it) .

I do, however, *love* the thought of seeing libproj supporting
WKT2, ISO19111 and friends. And if embracing C++ is the way
you can implement that fastest and most efficiently, I believe that
is what should be done.

I have spent 2 years of my life working towards a libproj more
suitable for handling general geodetic transformations, while
staying within the bounds set by C89. This really makes me want
to see a less restrictive environment for your important next step.

Also, I would love to see a more clearly defined delineation of
where PROJ stops and GDAL takes over. Obviously, this will
only happen by applying an overall architectural restructuring,
involving both C and C++ code, from both PROJ and GDAL.

I believe, as accuracy expectations grow, PROJ will have to
evolve into not only a libcrs, but into a lib-general-geodesy,
to stay relevant. Doing that without introducing sharper tools
will result in an unmaintainable mess.

So enough of my "thoughts in bullshit fashion" - just let me
summarize by saying that I believe that introducing C++
elements in libproj will be necessary to achieve the goals
set forward in the gdal barn raising, and hence not really a
decision to consider, but just an inevitable bullet to bite
(or candy to enjoy, for those so inclined).


Den tor. 7. maj 2020 kl. 18.31 skrev Søren Holm <sgh at sgh.dk>:

> Thank you for the answers Martin and Howard.
>
> I realy like that the precision of proj has increase comparing to earlier
> proj
> versions. Also the readyness for future evolution is great. I did not
> question
> any of that.
>
> I do however not understand why the precision and future evolution
> readiness -
> which are features in inself - is brough into a purely language oriented
> question. I'm quite sure that using C or C++ without the stuff that makes
> it
> slow can be just as precise as anything else.
>
> I clearly I do not compile PROJ all the time, but that kind of standpoint
> leads to ever increasing compiletimes for developers and users.
>
> Lastly I just want to say that I did not write these email to start a
> discussion. It was a mere combination of:
>
> "Hey, thing thing is takes 10 times longer to compile, Why is that?"
>
>       and
>
> "If my software projects compile time increased 10 fold I would see it as
> a
> bug."
>
>
>
> --
> Søren Holm
>
>
> _______________________________________________
> PROJ mailing list
> PROJ at lists.osgeo.org
> https://lists.osgeo.org/mailman/listinfo/proj
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20200507/94cf3996/attachment.html>

From even.rouault at spatialys.com  Mon May 11 02:02:33 2020
From: even.rouault at spatialys.com (Even Rouault)
Date: Mon, 11 May 2020 11:02:33 +0200
Subject: [PROJ] Deformation model implementation
Message-ID: <2927217.FPeZ5GbBhU@even-i700>

Hi,

Over the course of past years, we discussed here or in
https://github.com/OSGeo/PROJ/issues/1001 how to extend PROJ to deal with deformation 
models able to cope with 3D time-dependent deformations, and particularly, multiple ources 
of deformations with different time constants, such as secular velocity models for GIA 
(glacial isostatic adjustment), or complex deformations due tectonic events such as 
earthquakes, which may include both coseismic deformation (a step function) as well an 
ongoing post-seismic deformation signal.

Chris Crook wrote a specification of an encoding for such a deformation model [1], consisting 
of a main JSON file describing general metadata and parameters of the model, and listing 
different spatial components with their associated time function (velocity, step/reverse step, 
constant, exponential, piece-wise). The grids of each spatial component use the Geodetic 
TIFF grids (GTG) profile of GeoTIFF ([2]) that is available since PROJ 7.0.

The PROJ implementation for this deformation model specification is now available for 
review in the pull request
https://github.com/OSGeo/PROJ/pull/2206 . Chris has tested it on the NZGD200 deformation 
model.

Even

[1] 
https://github.com/linz/deformation-model-format/blob/master/doc/
JsonGeotiffDeformationModelFormat_20200501.pdf
[2] https://proj.org/specifications/geodetictiffgrids.html

-- 
Spatialys - Geospatial professional services
http://www.spatialys.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20200511/0214d781/attachment.html>

From jfandre at student.ethz.ch  Thu May 14 04:10:25 2020
From: jfandre at student.ethz.ch (=?Windows-1252?Q?Fandr=E9__Josianne?=)
Date: Thu, 14 May 2020 11:10:25 +0000
Subject: [PROJ] Implemtation of WKT in cs2cs
Message-ID: <dadbdf2567ea498382387a8007389596@student.ethz.ch>

Hi

I'm trying to use a WKT string to transform between two CSs but I haven't found any examples on how to do this. I'm using the OSGeo4W Shell and all attempts so far didn't work. I'm using the following code:

cs2cs +init=epsg:4326 +to +proj_create_from_wkt(0,"GEODCRS[„WGS 84“,DATUM[„World Geodetic System 1984“,ELLIPSOID[“WGS 84”,6378137,298.257223563,LENGTHUNIT[“metre”,1.0]]]CS[ellipsoidal,2],AXIS[“latitude”,north,ORDER[1]],AXIS[“longitude”,east,ORDER[2]],ANGLEUNIT[“degree”,0.0174532952]]") . I tried using +proj_create() as well but I get each time the error:proj_create: unrecognized format / unknown name.


Thank you


Josianne

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20200514/f70c736e/attachment.html>

From kristianevers at gmail.com  Thu May 14 04:50:04 2020
From: kristianevers at gmail.com (Kristian Evers)
Date: Thu, 14 May 2020 13:50:04 +0200
Subject: [PROJ] Implemtation of WKT in cs2cs
In-Reply-To: <dadbdf2567ea498382387a8007389596@student.ethz.ch>
References: <dadbdf2567ea498382387a8007389596@student.ethz.ch>
Message-ID: <788BD22A-CC89-4F79-B19D-0187E1D4BBC4@gmail.com>

Fandre,

You have several problems:

1. proj_create_from_wkt() and proj_create() are C functions - they can’t be used from the command line
2. Your WKT contains several non-standard quote (“) character that cs2cs won’t understand
3. The quote characters has to be escaped with backslashes, except the first and last one.

Here’s an updated version of your cs2cs call that works for me:

$ echo 56 12 0 | cs2cs EPSG:4326  "GEODCRS[\"WGS 84\",DATUM[\"World Geodetic System 1984\",ELLIPSOID[\"WGS 84\",6378137,298.257223563,LENGTHUNIT[\"metre\",1.0]]]CS[ellipsoidal,2],AXIS[\"latitude\",north,ORDER[1]],AXIS[\"longitude\",east,ORDER[2]],ANGLEUNIT[\"degree\",0.0174532952]]"
56dN    12dE 0.000

/Kristian


> On 14 May 2020, at 13:10, Fandré Josianne <jfandre at student.ethz.ch> wrote:
> 
> cs2cs +init=epsg:4326 +to +proj_create_from_wkt(0,"GEODCRS[„WGS 84“,DATUM[„World Geodetic System 1984“,ELLIPSOID[“WGS 84”,6378137,298.257223563,LENGTHUNIT[“metre”,1.0]]]CS[ellipsoidal,2],AXIS[“latitude”,north,ORDER[1]],AXIS[“longitude”,east,ORDER[2]],ANGLEUNIT[“degree”,0.0174532952]]")

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20200514/58816fd6/attachment.html>

From jfandre at student.ethz.ch  Thu May 14 04:57:47 2020
From: jfandre at student.ethz.ch (=?Windows-1252?Q?Fandr=E9__Josianne?=)
Date: Thu, 14 May 2020 11:57:47 +0000
Subject: [PROJ] Implemtation of WKT in cs2cs
In-Reply-To: <788BD22A-CC89-4F79-B19D-0187E1D4BBC4@gmail.com>
References: <dadbdf2567ea498382387a8007389596@student.ethz.ch>,
 <788BD22A-CC89-4F79-B19D-0187E1D4BBC4@gmail.com>
Message-ID: <d55fae17d7c44ece93ce331f722daabf@student.ethz.ch>

Thank you very much. Now it works. I'm new to PROJ and unfortunately I haven't found any examples for the use of WKT in proj.


Josianne

________________________________
Von: Kristian Evers <kristianevers at gmail.com>
Gesendet: Donnerstag, 14. Mai 2020 13:50:04
An: Fandré Josianne
Cc: proj at lists.osgeo.org
Betreff: Re: [PROJ] Implemtation of WKT in cs2cs

Fandre,

You have several problems:

1. proj_create_from_wkt() and proj_create() are C functions - they can’t be used from the command line
2. Your WKT contains several non-standard quote (“) character that cs2cs won’t understand
3. The quote characters has to be escaped with backslashes, except the first and last one.

Here’s an updated version of your cs2cs call that works for me:

$ echo 56 12 0 | cs2cs EPSG:4326  "GEODCRS[\"WGS 84\",DATUM[\"World Geodetic System 1984\",ELLIPSOID[\"WGS 84\",6378137,298.257223563,LENGTHUNIT[\"metre\",1.0]]]CS[ellipsoidal,2],AXIS[\"latitude\",north,ORDER[1]],AXIS[\"longitude\",east,ORDER[2]],ANGLEUNIT[\"degree\",0.0174532952]]"
56dN    12dE 0.000

/Kristian


On 14 May 2020, at 13:10, Fandré Josianne <jfandre at student.ethz.ch<mailto:jfandre at student.ethz.ch>> wrote:

cs2cs +init=epsg:4326 +to +proj_create_from_wkt(0,"GEODCRS[„WGS 84“,DATUM[„World Geodetic System 1984“,ELLIPSOID[“WGS 84”,6378137,298.257223563,LENGTHUNIT[“metre”,1.0]]]CS[ellipsoidal,2],AXIS[“latitude”,north,ORDER[1]],AXIS[“longitude”,east,ORDER[2]],ANGLEUNIT[“degree”,0.0174532952]]")

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20200514/f68cbd50/attachment.html>

From proj at dima.secretsauce.net  Fri May 15 13:12:25 2020
From: proj at dima.secretsauce.net (Dima Kogan)
Date: Fri, 15 May 2020 13:12:25 -0700
Subject: [PROJ] Explaining geodesic distance discrepancies
Message-ID: <871rnllzyu.fsf@secretsauce.net>

Hi. I'm seeing behavior I don't understand. Any clarification would be
greatly appreciated.

I have two positions represented as latitude,longitude pairs, and I'm
trying to get the distance between them. I've 3 methods that all yield
different results, where I think they should be VERY close. The methods
are:

- Converting the lat/lon to a Cartesian UTM system, and then using the
  Cartesian distance

- pyproj.Geod

- The "geod" command-line tool

For an arbitrary pair of points that are ~1km apart, I see:

diff utm:          1161.43346448816
diff geod:         1161.1017567084384
diff geod cmdline: 1163.971

This looks wrong. The UTM probably should be slightly off because the
two Cartesian systems are slightly tilted, but is 30cm over 1km really
how far off it should be?

The difference between pyproj.Geod and the "geod" cmdline tool makes
even less sense. In theory they're doing the same thing, so the results
should be identical.

I'm attaching a Python script to run the 3 methods, and print the
ranges.

Thanks!

-------------- next part --------------
A non-text attachment was scrubbed...
Name: tst.py
Type: text/x-python
Size: 944 bytes
Desc: not available
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20200515/0acebba9/attachment.py>

From charles at karney.com  Fri May 15 13:45:30 2020
From: charles at karney.com (Charles Karney)
Date: Fri, 15 May 2020 16:45:30 -0400
Subject: [PROJ] Explaining geodesic distance discrepancies
In-Reply-To: <871rnllzyu.fsf@secretsauce.net>
References: <871rnllzyu.fsf@secretsauce.net>
Message-ID: <e5d4d544-b535-1b29-6cf8-9f54e3e80bb8@karney.com>

The ratio utm distance/geodesic distance is the "scale" of the UTM
transformation.  (The "tilting" you refer to is called the "meridian
convergence"; this doesn't affect the distance calculation because TM is
a conformal projection.)  For the midpoint of the geodesic you are
examining, the scale is 1.00028568317.  And the ratio you get is

   utm/geod = 1161.43346448816/1161.1017567084384 = 1.00028568364

So your utm and geod results are consistent.  I can't reproduce your
geod cmdline result.  If I run your python script, I get

     one: 17
     diff utm:          1161.433464475265
     diff geod:         1161.1017567084402
     diff geod cmdline: 1161.102

Perhaps you have the "wrong" geod in your path?

   --Charles

On 5/15/20 4:12 PM, Dima Kogan wrote:
> Hi. I'm seeing behavior I don't understand. Any clarification would be
> greatly appreciated.
> 
> I have two positions represented as latitude,longitude pairs, and I'm
> trying to get the distance between them. I've 3 methods that all yield
> different results, where I think they should be VERY close. The methods
> are:
> 
> - Converting the lat/lon to a Cartesian UTM system, and then using the
>    Cartesian distance
> 
> - pyproj.Geod
> 
> - The "geod" command-line tool
> 
> For an arbitrary pair of points that are ~1km apart, I see:
> 
> diff utm:          1161.43346448816
> diff geod:         1161.1017567084384
> diff geod cmdline: 1163.971
> 
> This looks wrong. The UTM probably should be slightly off because the
> two Cartesian systems are slightly tilted, but is 30cm over 1km really
> how far off it should be?
> 
> The difference between pyproj.Geod and the "geod" cmdline tool makes
> even less sense. In theory they're doing the same thing, so the results
> should be identical.
> 
> I'm attaching a Python script to run the 3 methods, and print the
> ranges.
> 
> Thanks!
> 
> 
> _______________________________________________
> PROJ mailing list
> PROJ at lists.osgeo.org
> https://lists.osgeo.org/mailman/listinfo/proj
> 

From proj at dima.secretsauce.net  Fri May 15 14:00:06 2020
From: proj at dima.secretsauce.net (Dima Kogan)
Date: Fri, 15 May 2020 14:00:06 -0700
Subject: [PROJ] Explaining geodesic distance discrepancies
In-Reply-To: <e5d4d544-b535-1b29-6cf8-9f54e3e80bb8@karney.com>
References: <871rnllzyu.fsf@secretsauce.net>
 <e5d4d544-b535-1b29-6cf8-9f54e3e80bb8@karney.com>
Message-ID: <87zha8lxrd.fsf@dima.secretsauce.net>

Thank you very much. That's VERY useful info. How did you get that scale
factor? Is there a proj tool and/or function call?

I have just tried to run the "geod" cmd on another box with another proj
install, and it matches up over there. Which is probably enough for me
to go figure this out. We DO expect the "geod" cmdline and the
pyproj.Geod results to match 100%, right?

Thanks again.

From charles at karney.com  Fri May 15 15:33:33 2020
From: charles at karney.com (Charles Karney)
Date: Fri, 15 May 2020 18:33:33 -0400
Subject: [PROJ] Explaining geodesic distance discrepancies
In-Reply-To: <87zha8lxrd.fsf@dima.secretsauce.net>
References: <871rnllzyu.fsf@secretsauce.net>
 <e5d4d544-b535-1b29-6cf8-9f54e3e80bb8@karney.com>
 <87zha8lxrd.fsf@dima.secretsauce.net>
Message-ID: <cd1ff526-bb88-946a-9e28-b3fac4ba86e0@karney.com>

I believe PROJ does have some way of computing the scale of a
projection; but it uses numerical differencing.  GeographicLib computes
the scale of TM from an analytic expression, so it's probably more
accurate.  The command I used to get the scale (using GeographicLib) is:

     echo 0.5 |
     GeodSolve -I 31.4617 -83.4849 31.4704 -83.4781 -F -p 10 |
     cut -f1,2 -d' ' | GeoConvert -c -p 10
=>
     -1.2959245331415 1.000285683174366

The GeodSolve expression gets the midpoint of a geodesic.  GeoConvert -c
returns the meridian convergence and scale for the UTM projection.

The command line utility geod uses the same code as pyproj.Geod.  So
unless you have extra versions of geod lying around they should return
the same results.


On 5/15/20 5:00 PM, Dima Kogan wrote:
> Thank you very much. That's VERY useful info. How did you get that scale
> factor? Is there a proj tool and/or function call?
> 
> I have just tried to run the "geod" cmd on another box with another proj
> install, and it matches up over there. Which is probably enough for me
> to go figure this out. We DO expect the "geod" cmdline and the
> pyproj.Geod results to match 100%, right?
> 
> Thanks again.
> _______________________________________________
> PROJ mailing list
> PROJ at lists.osgeo.org
> https://lists.osgeo.org/mailman/listinfo/proj
> 

From alansnow21 at gmail.com  Fri May 15 17:02:11 2020
From: alansnow21 at gmail.com (Alan Snow)
Date: Fri, 15 May 2020 19:02:11 -0500
Subject: [PROJ] Explaining geodesic distance discrepancies
In-Reply-To: <cd1ff526-bb88-946a-9e28-b3fac4ba86e0@karney.com>
References: <871rnllzyu.fsf@secretsauce.net>
 <e5d4d544-b535-1b29-6cf8-9f54e3e80bb8@karney.com>
 <87zha8lxrd.fsf@dima.secretsauce.net>
 <cd1ff526-bb88-946a-9e28-b3fac4ba86e0@karney.com>
Message-ID: <CAGybdFQ5znmo24OAfh23OMWV_ahcsGppv0vQ6_Omr7rQgJ+=cQ@mail.gmail.com>

This may help getting the factors:
https://pyproj4.github.io/pyproj/stable/api/proj.html#pyproj.proj.Proj.get_factors

On Fri, May 15, 2020, 5:33 PM Charles Karney <charles at karney.com> wrote:

> I believe PROJ does have some way of computing the scale of a
> projection; but it uses numerical differencing.  GeographicLib computes
> the scale of TM from an analytic expression, so it's probably more
> accurate.  The command I used to get the scale (using GeographicLib) is:
>
>      echo 0.5 |
>      GeodSolve -I 31.4617 -83.4849 31.4704 -83.4781 -F -p 10 |
>      cut -f1,2 -d' ' | GeoConvert -c -p 10
> =>
>      -1.2959245331415 1.000285683174366
>
> The GeodSolve expression gets the midpoint of a geodesic.  GeoConvert -c
> returns the meridian convergence and scale for the UTM projection.
>
> The command line utility geod uses the same code as pyproj.Geod.  So
> unless you have extra versions of geod lying around they should return
> the same results.
>
>
> On 5/15/20 5:00 PM, Dima Kogan wrote:
> > Thank you very much. That's VERY useful info. How did you get that scale
> > factor? Is there a proj tool and/or function call?
> >
> > I have just tried to run the "geod" cmd on another box with another proj
> > install, and it matches up over there. Which is probably enough for me
> > to go figure this out. We DO expect the "geod" cmdline and the
> > pyproj.Geod results to match 100%, right?
> >
> > Thanks again.
> > _______________________________________________
> > PROJ mailing list
> > PROJ at lists.osgeo.org
> > https://lists.osgeo.org/mailman/listinfo/proj
> >
> _______________________________________________
> PROJ mailing list
> PROJ at lists.osgeo.org
> https://lists.osgeo.org/mailman/listinfo/proj
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20200515/3060dabf/attachment.html>

From proj at dima.secretsauce.net  Sat May 16 00:18:18 2020
From: proj at dima.secretsauce.net (Dima Kogan)
Date: Sat, 16 May 2020 00:18:18 -0700
Subject: [PROJ] Explaining geodesic distance discrepancies
In-Reply-To: <87zha8lxrd.fsf@dima.secretsauce.net>
References: <871rnllzyu.fsf@secretsauce.net>
 <e5d4d544-b535-1b29-6cf8-9f54e3e80bb8@karney.com>
 <87zha8lxrd.fsf@dima.secretsauce.net>
Message-ID: <87y2psl551.fsf@secretsauce.net>

Alright, so I chased down the difference. For uninteresting reasons, the
box with the "geod" discrepancy is ancient, and was running proj 4.8.0.
By 4.9.0 the discrepancy was gone. The commit that fixed it was this:

  https://github.com/OSGeo/PROJ/commit/f1f1f9f2aea725663499f449961027df2b38e296

Thank you very much, all.

From jgpallero at gmail.com  Mon May 18 14:03:02 2020
From: jgpallero at gmail.com (=?UTF-8?Q?Jos=C3=A9_Luis_Garc=C3=ADa_Pallero?=)
Date: Mon, 18 May 2020 23:03:02 +0200
Subject: [PROJ] About unit conversion
Message-ID: <CAFemY3b0LABXmSSTk2r6YnsRsuC9G+OEZ=smrw8A0hRpc3uj_w@mail.gmail.com>

Hello:

I'm trying to do dome projections (forward and inverse) using the
function proj_trans_generic() and parameter string in PROJ format (+
style) and I'm a bit confused about unit conversions. My reference for
the syntax is https://proj.org/operations/conversions/unitconvert.html

For the forward problem I write

C = proj_context_create();
projection = proj_create(C,param);
proj_trans_generic(projection,PJ_FWD,lon,sizeof(double),nElem,lat,sizeof(double),nElem,NULL,0,0,NULL,0,0);

I've used the param string

'+proj=pipeline +step +proj=unitconvert +xy_in=deg +step +proj=utm
+lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_out=km'

which means that the input coordinates are in degrees and the output
in kilometers. All works right. The results are the same if I pass the
input coordinates in radians and I use the param string

'+proj=pipeline +step +proj=utm +lon_0=3w +ellps=GRS80 +step
+proj=unitconvert +xy_out=km'

The problem comes when I try to do the inverse step. The procedure is the same:

C = proj_context_create();
projection = proj_create(C,param);
proj_trans_generic(projection,PJ_INV,x,sizeof(double),nElem,y,sizeof(double),nElem,NULL,0,0,NULL,0,0);

In the input xoordinates are in meters and I use the param string

'+proj=utm +lon_0=3w +ellps=GRS80'

The resulting longtude and latitude are correct and the units are
radians. But if I use the param string

'+proj=pipeline +step +proj=utm +lon_0=3w +ellps=GRS80 +step
+proj=unitconvert +xy_out=deg'

The output is totally wrong. I expect degrees, but the values have no
sense. Also, if I use the input X and Y in kilometers ans the param
string is

'+proj=pipeline +step +proj=unitconvert +xy_in=km +step +proj=utm
+lon_0=3w +ellps=GRS80'

the result is wrong again.

I suppose I'm doing something wrong with unit conversion, but I can not find it

Can someone help me?

Thanks

-- 
*****************************************
José Luis García Pallero
jgpallero at gmail.com
(o<
/ / \
V_/_
Use Debian GNU/Linux and enjoy!
*****************************************

From nyall.dawson at gmail.com  Mon May 18 15:00:50 2020
From: nyall.dawson at gmail.com (Nyall Dawson)
Date: Tue, 19 May 2020 08:00:50 +1000
Subject: [PROJ] Efficiently obtaining all known ellipsoid details
Message-ID: <CAB28Asi+0wkBo+fviK-gWvLYT-PEZJ8sE=_CEvNihdgJJVdkuQ@mail.gmail.com>

Hi list,

In QGIS we need to obtain a list of all known ellipsoid definitions
from proj. Currently we do this via the approach:

  if ( PROJ_STRING_LIST authorities =
proj_get_authorities_from_database( context ) )
  {
    PROJ_STRING_LIST authoritiesIt = authorities;
    while ( char *authority = *authoritiesIt )
    {
      if ( PROJ_STRING_LIST codes = proj_get_codes_from_database(
context, authority, PJ_TYPE_ELLIPSOID, 0 ) )
      {
        PROJ_STRING_LIST codesIt = codes;
        while ( char *code = *codesIt )
        {
          proj_create_from_database( context, authority, code,
PJ_CATEGORY_ELLIPSOID, 0, nullptr ) );
           proj_get_name(...)
           proj_ellipsoid_get_parameters(...)
         }
     }
   }
}

While this works, it's quite slow -- understandably, because it's
doing one-by-one lookups in the proj sqlite database. Is there a more
efficient approach which could be used to obtain all these details in
bulk?

Nyall

From even.rouault at spatialys.com  Mon May 18 16:13:08 2020
From: even.rouault at spatialys.com (Even Rouault)
Date: Tue, 19 May 2020 01:13:08 +0200
Subject: [PROJ] Efficiently obtaining all known ellipsoid details
In-Reply-To: <CAB28Asi+0wkBo+fviK-gWvLYT-PEZJ8sE=_CEvNihdgJJVdkuQ@mail.gmail.com>
References: <CAB28Asi+0wkBo+fviK-gWvLYT-PEZJ8sE=_CEvNihdgJJVdkuQ@mail.gmail.com>
Message-ID: <2915019.G4okiyH19G@even-i700>

On mardi 19 mai 2020 08:00:50 CEST Nyall Dawson wrote:
> Hi list,
> 
> In QGIS we need to obtain a list of all known ellipsoid definitions
> from proj. Currently we do this via the approach:
> 
>   if ( PROJ_STRING_LIST authorities =
> proj_get_authorities_from_database( context ) )
>   {
>     PROJ_STRING_LIST authoritiesIt = authorities;
>     while ( char *authority = *authoritiesIt )
>     {
>       if ( PROJ_STRING_LIST codes = proj_get_codes_from_database(
> context, authority, PJ_TYPE_ELLIPSOID, 0 ) )
>       {
>         PROJ_STRING_LIST codesIt = codes;
>         while ( char *code = *codesIt )
>         {
>           proj_create_from_database( context, authority, code,
> PJ_CATEGORY_ELLIPSOID, 0, nullptr ) );
>            proj_get_name(...)
>            proj_ellipsoid_get_parameters(...)
>          }
>      }
>    }
> }

Nyall,

how slow is that exactly ? There are just 303 ellipsoids in the DB, and those are relatively 
simple objects, so that's a bit surprising.

We have proj_get_crs_info_list_from_database() (which was justified given that there are 
close to 10K CRS and those are more complex objects) that could serve as an inspiration for 
similar functionality for ellipsoids, but I think it could be worth finding if there is an obvious 
bottleneck with the existing infrastructure.

Even

-- 
Spatialys - Geospatial professional services
http://www.spatialys.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20200519/03e13aeb/attachment.html>

From thy at 42.dk  Mon May 18 23:13:45 2020
From: thy at 42.dk (Kristian Thy)
Date: Tue, 19 May 2020 08:13:45 +0200
Subject: [PROJ] Efficiently obtaining all known ellipsoid details
In-Reply-To: <2915019.G4okiyH19G@even-i700>
References: <CAB28Asi+0wkBo+fviK-gWvLYT-PEZJ8sE=_CEvNihdgJJVdkuQ@mail.gmail.com>
 <2915019.G4okiyH19G@even-i700>
Message-ID: <20200519061345.i2bn3jdmghzrp6p3@42.dk>

On Tue, May 19, Even Rouault wrote:
> how slow is that exactly ? There are just 303 ellipsoids in the DB,
> and those are relatively simple objects, so that's a bit surprising.

As I understand Nyall's code he's iterating over all projections to
gather the ellipsoids, so that's a bit more than 303 objects to loop
over.

-- 
/Kristian

From nyall.dawson at gmail.com  Tue May 19 00:56:50 2020
From: nyall.dawson at gmail.com (Nyall Dawson)
Date: Tue, 19 May 2020 17:56:50 +1000
Subject: [PROJ] Efficiently obtaining all known ellipsoid details
In-Reply-To: <2915019.G4okiyH19G@even-i700>
References: <CAB28Asi+0wkBo+fviK-gWvLYT-PEZJ8sE=_CEvNihdgJJVdkuQ@mail.gmail.com>
 <2915019.G4okiyH19G@even-i700>
Message-ID: <CAB28AsiC1e-YbpUmsW7-7gv9sK9Xy1FUubk0PiUdPbAeWOZpVg@mail.gmail.com>

On Tue, 19 May 2020 at 09:13, Even Rouault <even.rouault at spatialys.com> wrote:
>
> how slow is that exactly ? There are just 303 ellipsoids in the DB, and those are relatively simple objects, so that's a bit surprising.

> We have proj_get_crs_info_list_from_database() (which was justified given that there are close to 10K CRS and those are more complex objects) that could serve as an inspiration for similar functionality for ellipsoids, but I think it could be worth finding if there is an obvious bottleneck with the existing infrastructure.

Actually - I was mistaken. Digging further into the profile it wasn't
the call to proj_ellipsoid_get_parameters/proj_create_from_database
which is taking the time, it's some code which happens just after this
but inside that same loop!

Nyall

From jgpallero at gmail.com  Tue May 19 01:58:59 2020
From: jgpallero at gmail.com (=?UTF-8?Q?Jos=C3=A9_Luis_Garc=C3=ADa_Pallero?=)
Date: Tue, 19 May 2020 10:58:59 +0200
Subject: [PROJ] About unit conversion
In-Reply-To: <CAFemY3b0LABXmSSTk2r6YnsRsuC9G+OEZ=smrw8A0hRpc3uj_w@mail.gmail.com>
References: <CAFemY3b0LABXmSSTk2r6YnsRsuC9G+OEZ=smrw8A0hRpc3uj_w@mail.gmail.com>
Message-ID: <CAFemY3Z5RS+GikzLC0kYQmD0v2pDFY82i5DJe1s+d3jDFkEXDw@mail.gmail.com>

I've written a small program in order to illustrate my last mail.
Attached (and pasted at the bottom of the message) I send the code.
The results are

Original data -> lon: -6.00000, lat: 43.00000 (degrees) -> lon:
-0.1047197551, lat: 0.7504915784 (radians)

rad to m  -> X= 255466.981, Y=4765182.933 (+proj=utm +lon_0=3w +ellps=GRS80)
rad to km -> X=    255.467, Y=   4765.183 (+proj=pipeline +step
+proj=utm +lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_out=km)
deg to m  -> X= 255466.981, Y=4765182.933 (+proj=pipeline +step
+proj=unitconvert +xy_in=deg +step +proj=utm +lon_0=3w +ellps=GRS80)
deg to km -> X=    255.467, Y=   4765.183 (+proj=pipeline +step
+proj=unitconvert +xy_in=deg +step +proj=utm +lon_0=3w +ellps=GRS80
+step +proj=unitconvert +xy_out=km)

m  to rad -> lon=-0.1047197551, lat= 0.7504915784 (+proj=utm +lon_0=3w
+ellps=GRS80)
km to rad -> lon=-0.0001306633, lat= 0.0000007501 (+proj=pipeline
+step +proj=unitconvert +xy_in=km +step +proj=utm +lon_0=3w
+ellps=GRS80)
m  to deg -> lon=-0.1300126568, lat= 0.0130928532 (+proj=pipeline
+step +proj=utm +lon_0=3w +ellps=GRS80 +step +proj=unitconvert
+xy_out=deg)
km to deg -> lon=-0.0001307025, lat= 0.0000000131 (+proj=pipeline
+step +proj=unitconvert +xy_in=km +step +proj=utm +lon_0=3w
+ellps=GRS80 +step +proj=unitconvert +xy_out=deg)

As you can see, the only right INV conversion is the meters_to_radians
one. All other combinations produce all different results, but all
combinations for the FWD step are right. Im using PROJ 7.0.1 from the
Debian Sid repositories

***********************

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<proj.h>
#define CONST_PI (3.14159265358979323846264338328)
int main()
{
    double lond1=-6.0,latd1=43.0,lond2=lond1,latd2=latd1;
    double lonr1=lond1*CONST_PI/180.0,latr1=latd1*CONST_PI/180.0,lonr2=lonr1,latr2=latr1;
    char param_rad_to_m[]="+proj=utm +lon_0=3w +ellps=GRS80";
    char param_rad_to_km[]="+proj=pipeline +step +proj=utm +lon_0=3w
+ellps=GRS80 +step +proj=unitconvert +xy_out=km";
    char param_deg_to_m[]="+proj=pipeline +step +proj=unitconvert
+xy_in=deg +step +proj=utm +lon_0=3w +ellps=GRS80";
    char param_deg_to_km[]="+proj=pipeline +step +proj=unitconvert
+xy_in=deg +step +proj=utm +lon_0=3w +ellps=GRS80 +step
+proj=unitconvert +xy_out=km";
    char param_m_to_rad[]="+proj=utm +lon_0=3w +ellps=GRS80";
    char param_km_to_rad[]="+proj=pipeline +step +proj=unitconvert
+xy_in=km +step +proj=utm +lon_0=3w +ellps=GRS80";
    char param_m_to_deg[]="+proj=pipeline +step +proj=utm +lon_0=3w
+ellps=GRS80 +step +proj=unitconvert +xy_out=deg";
    char param_km_to_deg[]="+proj=pipeline +step +proj=unitconvert
+xy_in=km +step +proj=utm +lon_0=3w +ellps=GRS80 +step
+proj=unitconvert +xy_out=deg";
    PJ_CONTEXT *C=proj_context_create();
    PJ *proj=NULL;
    size_t ld=sizeof(double);

    //Display original data
    printf("Original data -> lon: %.5lf, lat: %.5lf (degrees) -> lon:
%.10lf, lat: %.10lf (radians)\n\n",
           lond1,latd1,lonr1,latr1);
    //FWD, radiands to meters
    proj = proj_create(C,param_rad_to_m);
    proj_trans_generic(proj,PJ_FWD,&lonr1,ld,1,&latr1,ld,1,NULL,0,0,NULL,0,0);
    printf("rad to m  -> X=%11.3lf, Y=%11.3lf
(%s)\n",lonr1,latr1,param_rad_to_m);
    proj_destroy(proj);
    //FWD, radiands to kilometers
    proj = proj_create(C,param_rad_to_km);
    proj_trans_generic(proj,PJ_FWD,&lonr2,ld,1,&latr2,ld,1,NULL,0,0,NULL,0,0);
    printf("rad to km -> X=%11.3lf, Y=%11.3lf
(%s)\n",lonr2,latr2,param_rad_to_km);
    proj_destroy(proj);
    //FWD, degrees to meters
    proj = proj_create(C,param_deg_to_m);
    proj_trans_generic(proj,PJ_FWD,&lond1,ld,1,&latd1,ld,1,NULL,0,0,NULL,0,0);
    printf("deg to m  -> X=%11.3lf, Y=%11.3lf
(%s)\n",lond1,latd1,param_deg_to_m);
    proj_destroy(proj);
    //FWD, degrees to kilometers
    proj = proj_create(C,param_deg_to_km);
    proj_trans_generic(proj,PJ_FWD,&lond2,ld,1,&latd2,ld,1,NULL,0,0,NULL,0,0);
    printf("deg to km -> X=%11.3lf, Y=%11.3lf
(%s)\n\n",lond2,latd2,param_deg_to_km);
    proj_destroy(proj);
    //INV, meters to radians
    proj = proj_create(C,param_m_to_rad);
    proj_trans_generic(proj,PJ_INV,&lonr1,ld,1,&latr1,ld,1,NULL,0,0,NULL,0,0);
    printf("m  to rad -> lon=%13.10lf, lat=%13.10lf
(%s)\n",lonr1,latr1,param_m_to_rad);
    proj_destroy(proj);
    //INV, kilometers to radians
    proj = proj_create(C,param_km_to_rad);
    proj_trans_generic(proj,PJ_INV,&lonr2,ld,1,&latr2,ld,1,NULL,0,0,NULL,0,0);
    printf("km to rad -> lon=%13.10lf, lat=%13.10lf
(%s)\n",lonr2,latr2,param_km_to_rad);
    proj_destroy(proj);
    //INV, meters to degrees
    proj = proj_create(C,param_m_to_deg);
    proj_trans_generic(proj,PJ_INV,&lond1,ld,1,&latd1,ld,1,NULL,0,0,NULL,0,0);
    printf("m  to deg -> lon=%13.10lf, lat=%13.10lf
(%s)\n",lond1,latd1,param_m_to_deg);
    proj_destroy(proj);
    //INV, kilometers to degrees
    proj = proj_create(C,param_km_to_deg);
    proj_trans_generic(proj,PJ_INV,&lond2,ld,1,&latd2,ld,1,NULL,0,0,NULL,0,0);
    printf("km to deg -> lon=%13.10lf, lat=%13.10lf
(%s)\n",lond2,latd2,param_km_to_deg);
    proj_destroy(proj);
    proj_context_destroy(C);
    return 0;
}

El lun., 18 may. 2020 a las 23:03, José Luis García Pallero
(<jgpallero at gmail.com>) escribió:
>
> Hello:
>
> I'm trying to do dome projections (forward and inverse) using the
> function proj_trans_generic() and parameter string in PROJ format (+
> style) and I'm a bit confused about unit conversions. My reference for
> the syntax is https://proj.org/operations/conversions/unitconvert.html
>
> For the forward problem I write
>
> C = proj_context_create();
> projection = proj_create(C,param);
> proj_trans_generic(projection,PJ_FWD,lon,sizeof(double),nElem,lat,sizeof(double),nElem,NULL,0,0,NULL,0,0);
>
> I've used the param string
>
> '+proj=pipeline +step +proj=unitconvert +xy_in=deg +step +proj=utm
> +lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_out=km'
>
> which means that the input coordinates are in degrees and the output
> in kilometers. All works right. The results are the same if I pass the
> input coordinates in radians and I use the param string
>
> '+proj=pipeline +step +proj=utm +lon_0=3w +ellps=GRS80 +step
> +proj=unitconvert +xy_out=km'
>
> The problem comes when I try to do the inverse step. The procedure is the same:
>
> C = proj_context_create();
> projection = proj_create(C,param);
> proj_trans_generic(projection,PJ_INV,x,sizeof(double),nElem,y,sizeof(double),nElem,NULL,0,0,NULL,0,0);
>
> In the input xoordinates are in meters and I use the param string
>
> '+proj=utm +lon_0=3w +ellps=GRS80'
>
> The resulting longtude and latitude are correct and the units are
> radians. But if I use the param string
>
> '+proj=pipeline +step +proj=utm +lon_0=3w +ellps=GRS80 +step
> +proj=unitconvert +xy_out=deg'
>
> The output is totally wrong. I expect degrees, but the values have no
> sense. Also, if I use the input X and Y in kilometers ans the param
> string is
>
> '+proj=pipeline +step +proj=unitconvert +xy_in=km +step +proj=utm
> +lon_0=3w +ellps=GRS80'
>
> the result is wrong again.
>
> I suppose I'm doing something wrong with unit conversion, but I can not find it
>
> Can someone help me?
>
> Thanks
>
> --
> *****************************************
> José Luis García Pallero
> jgpallero at gmail.com
> (o<
> / / \
> V_/_
> Use Debian GNU/Linux and enjoy!
> *****************************************



-- 
*****************************************
José Luis García Pallero
jgpallero at gmail.com
(o<
/ / \
V_/_
Use Debian GNU/Linux and enjoy!
*****************************************
-------------- next part --------------
A non-text attachment was scrubbed...
Name: test-proj.c
Type: text/x-csrc
Size: 3604 bytes
Desc: not available
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20200519/918e3c04/attachment-0001.c>

From schmidtsamuel2 at gmail.com  Tue May 19 21:37:03 2020
From: schmidtsamuel2 at gmail.com (Artemis Live)
Date: Tue, 19 May 2020 23:37:03 -0500
Subject: [PROJ] build the earth custom projection
Message-ID: <CAB3VPPLwXL3ifeeJqoMv8UtvcoRWFrbR6TqfOvUS5TjNNdS7Zg@mail.gmail.com>

Hi everyone. A while back, the build the earth project changed their
projection to a custom made one. It is a conformal dymaxion bisected along
the north pole and deals with more complex math. I was researching custom
projections for qgis and was wondering if it was even possible to recreate
the projection. Thanks for all your help.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20200519/764c366c/attachment.html>

From strebe at aol.com  Tue May 19 23:44:02 2020
From: strebe at aol.com (strebe at aol.com)
Date: Wed, 20 May 2020 06:44:02 +0000 (UTC)
Subject: [PROJ] build the earth custom projection
In-Reply-To: <CAB3VPPLwXL3ifeeJqoMv8UtvcoRWFrbR6TqfOvUS5TjNNdS7Zg@mail.gmail.com>
References: <CAB3VPPLwXL3ifeeJqoMv8UtvcoRWFrbR6TqfOvUS5TjNNdS7Zg@mail.gmail.com>
Message-ID: <1667359866.2038595.1589957042731@mail.yahoo.com>

 Are you asking if it would be possible to add a projection of known construction into PROJ? Or are you asking if the projection details are known to sufficient detail to add it into PROJ? Or are you asking if someone is willing to do this? Or…?
— daan
 
-----Original Message-----
From: Artemis Live <schmidtsamuel2 at gmail.com>
To: proj at lists.osgeo.org
Sent: Tue, May 19, 2020 9:37 pm
Subject: [PROJ] build the earth custom projection

Hi everyone. A while back, the build the earth project changed their projection to a custom made one. It is a conformal dymaxion bisected along the north pole and deals with more complex math. I was researching custom projections for qgis and was wondering if it was even possible to recreate the projection. Thanks for all your help.
_______________________________________________
PROJ mailing list
PROJ at lists.osgeo.org
https://lists.osgeo.org/mailman/listinfo/proj
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20200520/13a9e81e/attachment.html>

From kreve at sdfe.dk  Wed May 20 02:00:50 2020
From: kreve at sdfe.dk (Kristian Evers)
Date: Wed, 20 May 2020 09:00:50 +0000
Subject: [PROJ] About unit conversion
In-Reply-To: <CAFemY3Z5RS+GikzLC0kYQmD0v2pDFY82i5DJe1s+d3jDFkEXDw@mail.gmail.com>
References: <CAFemY3b0LABXmSSTk2r6YnsRsuC9G+OEZ=smrw8A0hRpc3uj_w@mail.gmail.com>
 <CAFemY3Z5RS+GikzLC0kYQmD0v2pDFY82i5DJe1s+d3jDFkEXDw@mail.gmail.com>
Message-ID: <8100b13c03ef47f1ac26db48ce6f62fc@sdfe.dk>

I see that you don't specify the input units in your unitconvert steps. Try adding a
+xy_in parameter to your unitconvert steps and see if that fixes the problem.
When you only specify of of either +xy_in or +xy_out the operation becomes
somewhat uni-directional which is why not all of your pipelines works in reverse.

See https://proj.org/operations/conversions/unitconvert.html for more.

/Kristian

> -----Original Message-----
> From: PROJ <proj-bounces at lists.osgeo.org> On Behalf Of José Luis García
> Pallero
> Sent: 19. maj 2020 10:59
> To: proj at lists.osgeo.org
> Subject: Re: [PROJ] About unit conversion
> 
> I've written a small program in order to illustrate my last mail.
> Attached (and pasted at the bottom of the message) I send the code.
> The results are
> 
> Original data -> lon: -6.00000, lat: 43.00000 (degrees) -> lon:
> -0.1047197551, lat: 0.7504915784 (radians)
> 
> rad to m  -> X= 255466.981, Y=4765182.933 (+proj=utm +lon_0=3w
> +ellps=GRS80)
> rad to km -> X=    255.467, Y=   4765.183 (+proj=pipeline +step
> +proj=utm +lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_out=km)
> deg to m  -> X= 255466.981, Y=4765182.933 (+proj=pipeline +step
> +proj=unitconvert +xy_in=deg +step +proj=utm +lon_0=3w +ellps=GRS80)
> deg to km -> X=    255.467, Y=   4765.183 (+proj=pipeline +step
> +proj=unitconvert +xy_in=deg +step +proj=utm +lon_0=3w +ellps=GRS80
> +step +proj=unitconvert +xy_out=km)
> 
> m  to rad -> lon=-0.1047197551, lat= 0.7504915784 (+proj=utm +lon_0=3w
> +ellps=GRS80)
> km to rad -> lon=-0.0001306633, lat= 0.0000007501 (+proj=pipeline
> +step +proj=unitconvert +xy_in=km +step +proj=utm +lon_0=3w
> +ellps=GRS80)
> m  to deg -> lon=-0.1300126568, lat= 0.0130928532 (+proj=pipeline
> +step +proj=utm +lon_0=3w +ellps=GRS80 +step +proj=unitconvert
> +xy_out=deg)
> km to deg -> lon=-0.0001307025, lat= 0.0000000131 (+proj=pipeline
> +step +proj=unitconvert +xy_in=km +step +proj=utm +lon_0=3w
> +ellps=GRS80 +step +proj=unitconvert +xy_out=deg)
> 
> As you can see, the only right INV conversion is the meters_to_radians
> one. All other combinations produce all different results, but all
> combinations for the FWD step are right. Im using PROJ 7.0.1 from the
> Debian Sid repositories
> 
> ***********************
> 
> #include<stdio.h>
> #include<stdlib.h>
> #include<math.h>
> #include<proj.h>
> #define CONST_PI (3.14159265358979323846264338328)
> int main()
> {
>     double lond1=-6.0,latd1=43.0,lond2=lond1,latd2=latd1;
>     double
> lonr1=lond1*CONST_PI/180.0,latr1=latd1*CONST_PI/180.0,lonr2=lonr1,latr2
> =latr1;
>     char param_rad_to_m[]="+proj=utm +lon_0=3w +ellps=GRS80";
>     char param_rad_to_km[]="+proj=pipeline +step +proj=utm +lon_0=3w
> +ellps=GRS80 +step +proj=unitconvert +xy_out=km";
>     char param_deg_to_m[]="+proj=pipeline +step +proj=unitconvert
> +xy_in=deg +step +proj=utm +lon_0=3w +ellps=GRS80";
>     char param_deg_to_km[]="+proj=pipeline +step +proj=unitconvert
> +xy_in=deg +step +proj=utm +lon_0=3w +ellps=GRS80 +step
> +proj=unitconvert +xy_out=km";
>     char param_m_to_rad[]="+proj=utm +lon_0=3w +ellps=GRS80";
>     char param_km_to_rad[]="+proj=pipeline +step +proj=unitconvert
> +xy_in=km +step +proj=utm +lon_0=3w +ellps=GRS80";
>     char param_m_to_deg[]="+proj=pipeline +step +proj=utm +lon_0=3w
> +ellps=GRS80 +step +proj=unitconvert +xy_out=deg";
>     char param_km_to_deg[]="+proj=pipeline +step +proj=unitconvert
> +xy_in=km +step +proj=utm +lon_0=3w +ellps=GRS80 +step
> +proj=unitconvert +xy_out=deg";
>     PJ_CONTEXT *C=proj_context_create();
>     PJ *proj=NULL;
>     size_t ld=sizeof(double);
> 
>     //Display original data
>     printf("Original data -> lon: %.5lf, lat: %.5lf (degrees) -> lon:
> %.10lf, lat: %.10lf (radians)\n\n",
>            lond1,latd1,lonr1,latr1);
>     //FWD, radiands to meters
>     proj = proj_create(C,param_rad_to_m);
> 
> proj_trans_generic(proj,PJ_FWD,&lonr1,ld,1,&latr1,ld,1,NULL,0,0,NULL,0,0);
>     printf("rad to m  -> X=%11.3lf, Y=%11.3lf
> (%s)\n",lonr1,latr1,param_rad_to_m);
>     proj_destroy(proj);
>     //FWD, radiands to kilometers
>     proj = proj_create(C,param_rad_to_km);
> 
> proj_trans_generic(proj,PJ_FWD,&lonr2,ld,1,&latr2,ld,1,NULL,0,0,NULL,0,0);
>     printf("rad to km -> X=%11.3lf, Y=%11.3lf
> (%s)\n",lonr2,latr2,param_rad_to_km);
>     proj_destroy(proj);
>     //FWD, degrees to meters
>     proj = proj_create(C,param_deg_to_m);
> 
> proj_trans_generic(proj,PJ_FWD,&lond1,ld,1,&latd1,ld,1,NULL,0,0,NULL,0,0);
>     printf("deg to m  -> X=%11.3lf, Y=%11.3lf
> (%s)\n",lond1,latd1,param_deg_to_m);
>     proj_destroy(proj);
>     //FWD, degrees to kilometers
>     proj = proj_create(C,param_deg_to_km);
> 
> proj_trans_generic(proj,PJ_FWD,&lond2,ld,1,&latd2,ld,1,NULL,0,0,NULL,0,0);
>     printf("deg to km -> X=%11.3lf, Y=%11.3lf
> (%s)\n\n",lond2,latd2,param_deg_to_km);
>     proj_destroy(proj);
>     //INV, meters to radians
>     proj = proj_create(C,param_m_to_rad);
>     proj_trans_generic(proj,PJ_INV,&lonr1,ld,1,&latr1,ld,1,NULL,0,0,NULL,0,0);
>     printf("m  to rad -> lon=%13.10lf, lat=%13.10lf
> (%s)\n",lonr1,latr1,param_m_to_rad);
>     proj_destroy(proj);
>     //INV, kilometers to radians
>     proj = proj_create(C,param_km_to_rad);
>     proj_trans_generic(proj,PJ_INV,&lonr2,ld,1,&latr2,ld,1,NULL,0,0,NULL,0,0);
>     printf("km to rad -> lon=%13.10lf, lat=%13.10lf
> (%s)\n",lonr2,latr2,param_km_to_rad);
>     proj_destroy(proj);
>     //INV, meters to degrees
>     proj = proj_create(C,param_m_to_deg);
> 
> proj_trans_generic(proj,PJ_INV,&lond1,ld,1,&latd1,ld,1,NULL,0,0,NULL,0,0);
>     printf("m  to deg -> lon=%13.10lf, lat=%13.10lf
> (%s)\n",lond1,latd1,param_m_to_deg);
>     proj_destroy(proj);
>     //INV, kilometers to degrees
>     proj = proj_create(C,param_km_to_deg);
> 
> proj_trans_generic(proj,PJ_INV,&lond2,ld,1,&latd2,ld,1,NULL,0,0,NULL,0,0);
>     printf("km to deg -> lon=%13.10lf, lat=%13.10lf
> (%s)\n",lond2,latd2,param_km_to_deg);
>     proj_destroy(proj);
>     proj_context_destroy(C);
>     return 0;
> }
> 
> El lun., 18 may. 2020 a las 23:03, José Luis García Pallero
> (<jgpallero at gmail.com>) escribió:
> >
> > Hello:
> >
> > I'm trying to do dome projections (forward and inverse) using the
> > function proj_trans_generic() and parameter string in PROJ format (+
> > style) and I'm a bit confused about unit conversions. My reference for
> > the syntax is https://proj.org/operations/conversions/unitconvert.html
> >
> > For the forward problem I write
> >
> > C = proj_context_create();
> > projection = proj_create(C,param);
> >
> proj_trans_generic(projection,PJ_FWD,lon,sizeof(double),nElem,lat,sizeof(d
> ouble),nElem,NULL,0,0,NULL,0,0);
> >
> > I've used the param string
> >
> > '+proj=pipeline +step +proj=unitconvert +xy_in=deg +step +proj=utm
> > +lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_out=km'
> >
> > which means that the input coordinates are in degrees and the output
> > in kilometers. All works right. The results are the same if I pass the
> > input coordinates in radians and I use the param string
> >
> > '+proj=pipeline +step +proj=utm +lon_0=3w +ellps=GRS80 +step
> > +proj=unitconvert +xy_out=km'
> >
> > The problem comes when I try to do the inverse step. The procedure is the
> same:
> >
> > C = proj_context_create();
> > projection = proj_create(C,param);
> >
> proj_trans_generic(projection,PJ_INV,x,sizeof(double),nElem,y,sizeof(doubl
> e),nElem,NULL,0,0,NULL,0,0);
> >
> > In the input xoordinates are in meters and I use the param string
> >
> > '+proj=utm +lon_0=3w +ellps=GRS80'
> >
> > The resulting longtude and latitude are correct and the units are
> > radians. But if I use the param string
> >
> > '+proj=pipeline +step +proj=utm +lon_0=3w +ellps=GRS80 +step
> > +proj=unitconvert +xy_out=deg'
> >
> > The output is totally wrong. I expect degrees, but the values have no
> > sense. Also, if I use the input X and Y in kilometers ans the param
> > string is
> >
> > '+proj=pipeline +step +proj=unitconvert +xy_in=km +step +proj=utm
> > +lon_0=3w +ellps=GRS80'
> >
> > the result is wrong again.
> >
> > I suppose I'm doing something wrong with unit conversion, but I can not
> find it
> >
> > Can someone help me?
> >
> > Thanks
> >
> > --
> > *****************************************
> > José Luis García Pallero
> > jgpallero at gmail.com
> > (o<
> > / / \
> > V_/_
> > Use Debian GNU/Linux and enjoy!
> > *****************************************
> 
> 
> 
> --
> *****************************************
> José Luis García Pallero
> jgpallero at gmail.com
> (o<
> / / \
> V_/_
> Use Debian GNU/Linux and enjoy!
> *****************************************

From jgpallero at gmail.com  Wed May 20 09:34:09 2020
From: jgpallero at gmail.com (=?UTF-8?Q?Jos=C3=A9_Luis_Garc=C3=ADa_Pallero?=)
Date: Wed, 20 May 2020 18:34:09 +0200
Subject: [PROJ] About unit conversion
In-Reply-To: <8100b13c03ef47f1ac26db48ce6f62fc@sdfe.dk>
References: <CAFemY3b0LABXmSSTk2r6YnsRsuC9G+OEZ=smrw8A0hRpc3uj_w@mail.gmail.com>
 <CAFemY3Z5RS+GikzLC0kYQmD0v2pDFY82i5DJe1s+d3jDFkEXDw@mail.gmail.com>
 <8100b13c03ef47f1ac26db48ce6f62fc@sdfe.dk>
Message-ID: <CAFemY3ZuFqybZ6drR6UjZ=geVefRZ15GqdtNX3XOHHZwbVWSbg@mail.gmail.com>

El mié., 20 may. 2020 a las 11:00, Kristian Evers (<kreve at sdfe.dk>) escribió:
>
> I see that you don't specify the input units in your unitconvert steps. Try adding a
> +xy_in parameter to your unitconvert steps and see if that fixes the problem.
> When you only specify of of either +xy_in or +xy_out the operation becomes
> somewhat uni-directional which is why not all of your pipelines works in reverse.
>
> See https://proj.org/operations/conversions/unitconvert.html for more.

Thank you for your answer, Kristian, but I can't understand why my
program fails. Clearly, for FWD and input in radians and output in
meters all works without any unitconversion. Also for INV step with
meters as input and radians as output, i.e., using only "+proj=utm
+lon_0=3w +ellps=GRS80" as parameters string is enough. Also for any
combination in the FWD step all works.

For example using "+proj=pipeline +step +proj=unitconvert +xy_in=deg
+step +proj=utm +lon_0=3w +ellps=GRS80 +step +proj=unitconvert
+xy_out=km" accepts as input degrees and returns kilometers. But I
cant understand why in this case for the INV step the parameters
string "+proj=pipeline +step +proj=unitconvert +xy_in=km +step
+proj=utm +lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_out=deg"
is incorrect. I've tested several combinations and none of them works:

"+proj=utm +lon_0=3w +ellps=GRS80" -> wrong results
"+proj=pipeline +step +proj=unitconvert +xy_in=km +step +proj=utm
+lon_0=3w +ellps=GRS80" -> wrong results
"+proj=pipeline +step +proj=unitconvert +xy_in=km +xy_out=m +step
+proj=utm +lon_0=3w +ellps=GRS80" -> wrong results (same numeric value
as before)
"+proj=pipeline +step +proj=unitconvert +xy_in=km +xy_out=deg +step
+proj=utm +lon_0=3w +ellps=GRS80" -> proj_create: Error -59
(inconsistent unit type between input and output): Pipeline: Bad step
definition: proj=unitconvert (inconsistent unit type between input and
output)
"+proj=pipeline +step +proj=utm +lon_0=3w +ellps=GRS80 +step
+proj=unitconvert +xy_in=km +xy_out=deg" -> proj_create: Error -59
(inconsistent unit type between input and output): Pipeline: Bad step
definition: proj=unitconvert (inconsistent unit type between input and
output)
"+proj=pipeline +step +proj=unitconvert +xy_out=deg +step +proj=utm
+lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_in=km" -> wrong
results
"+proj=pipeline +step +proj=unitconvert +xy_in=km +step +proj=utm
+lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_out=deg" -> wrong
results

I can't understand the way as unitconvert works, neither reading
https://proj.org/operations/conversions/unitconvert.html

For only one conversion (km to radians or meters to degrees) the
problem is only again with the INV step

Thanks





>
> /Kristian
>
> > -----Original Message-----
> > From: PROJ <proj-bounces at lists.osgeo.org> On Behalf Of José Luis García
> > Pallero
> > Sent: 19. maj 2020 10:59
> > To: proj at lists.osgeo.org
> > Subject: Re: [PROJ] About unit conversion
> >
> > I've written a small program in order to illustrate my last mail.
> > Attached (and pasted at the bottom of the message) I send the code.
> > The results are
> >
> > Original data -> lon: -6.00000, lat: 43.00000 (degrees) -> lon:
> > -0.1047197551, lat: 0.7504915784 (radians)
> >
> > rad to m  -> X= 255466.981, Y=4765182.933 (+proj=utm +lon_0=3w
> > +ellps=GRS80)
> > rad to km -> X=    255.467, Y=   4765.183 (+proj=pipeline +step
> > +proj=utm +lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_out=km)
> > deg to m  -> X= 255466.981, Y=4765182.933 (+proj=pipeline +step
> > +proj=unitconvert +xy_in=deg +step +proj=utm +lon_0=3w +ellps=GRS80)
> > deg to km -> X=    255.467, Y=   4765.183 (+proj=pipeline +step
> > +proj=unitconvert +xy_in=deg +step +proj=utm +lon_0=3w +ellps=GRS80
> > +step +proj=unitconvert +xy_out=km)
> >
> > m  to rad -> lon=-0.1047197551, lat= 0.7504915784 (+proj=utm +lon_0=3w
> > +ellps=GRS80)
> > km to rad -> lon=-0.0001306633, lat= 0.0000007501 (+proj=pipeline
> > +step +proj=unitconvert +xy_in=km +step +proj=utm +lon_0=3w
> > +ellps=GRS80)
> > m  to deg -> lon=-0.1300126568, lat= 0.0130928532 (+proj=pipeline
> > +step +proj=utm +lon_0=3w +ellps=GRS80 +step +proj=unitconvert
> > +xy_out=deg)
> > km to deg -> lon=-0.0001307025, lat= 0.0000000131 (+proj=pipeline
> > +step +proj=unitconvert +xy_in=km +step +proj=utm +lon_0=3w
> > +ellps=GRS80 +step +proj=unitconvert +xy_out=deg)
> >
> > As you can see, the only right INV conversion is the meters_to_radians
> > one. All other combinations produce all different results, but all
> > combinations for the FWD step are right. Im using PROJ 7.0.1 from the
> > Debian Sid repositories
> >
> > ***********************
> >
> > #include<stdio.h>
> > #include<stdlib.h>
> > #include<math.h>
> > #include<proj.h>
> > #define CONST_PI (3.14159265358979323846264338328)
> > int main()
> > {
> >     double lond1=-6.0,latd1=43.0,lond2=lond1,latd2=latd1;
> >     double
> > lonr1=lond1*CONST_PI/180.0,latr1=latd1*CONST_PI/180.0,lonr2=lonr1,latr2
> > =latr1;
> >     char param_rad_to_m[]="+proj=utm +lon_0=3w +ellps=GRS80";
> >     char param_rad_to_km[]="+proj=pipeline +step +proj=utm +lon_0=3w
> > +ellps=GRS80 +step +proj=unitconvert +xy_out=km";
> >     char param_deg_to_m[]="+proj=pipeline +step +proj=unitconvert
> > +xy_in=deg +step +proj=utm +lon_0=3w +ellps=GRS80";
> >     char param_deg_to_km[]="+proj=pipeline +step +proj=unitconvert
> > +xy_in=deg +step +proj=utm +lon_0=3w +ellps=GRS80 +step
> > +proj=unitconvert +xy_out=km";
> >     char param_m_to_rad[]="+proj=utm +lon_0=3w +ellps=GRS80";
> >     char param_km_to_rad[]="+proj=pipeline +step +proj=unitconvert
> > +xy_in=km +step +proj=utm +lon_0=3w +ellps=GRS80";
> >     char param_m_to_deg[]="+proj=pipeline +step +proj=utm +lon_0=3w
> > +ellps=GRS80 +step +proj=unitconvert +xy_out=deg";
> >     char param_km_to_deg[]="+proj=pipeline +step +proj=unitconvert
> > +xy_in=km +step +proj=utm +lon_0=3w +ellps=GRS80 +step
> > +proj=unitconvert +xy_out=deg";
> >     PJ_CONTEXT *C=proj_context_create();
> >     PJ *proj=NULL;
> >     size_t ld=sizeof(double);
> >
> >     //Display original data
> >     printf("Original data -> lon: %.5lf, lat: %.5lf (degrees) -> lon:
> > %.10lf, lat: %.10lf (radians)\n\n",
> >            lond1,latd1,lonr1,latr1);
> >     //FWD, radiands to meters
> >     proj = proj_create(C,param_rad_to_m);
> >
> > proj_trans_generic(proj,PJ_FWD,&lonr1,ld,1,&latr1,ld,1,NULL,0,0,NULL,0,0);
> >     printf("rad to m  -> X=%11.3lf, Y=%11.3lf
> > (%s)\n",lonr1,latr1,param_rad_to_m);
> >     proj_destroy(proj);
> >     //FWD, radiands to kilometers
> >     proj = proj_create(C,param_rad_to_km);
> >
> > proj_trans_generic(proj,PJ_FWD,&lonr2,ld,1,&latr2,ld,1,NULL,0,0,NULL,0,0);
> >     printf("rad to km -> X=%11.3lf, Y=%11.3lf
> > (%s)\n",lonr2,latr2,param_rad_to_km);
> >     proj_destroy(proj);
> >     //FWD, degrees to meters
> >     proj = proj_create(C,param_deg_to_m);
> >
> > proj_trans_generic(proj,PJ_FWD,&lond1,ld,1,&latd1,ld,1,NULL,0,0,NULL,0,0);
> >     printf("deg to m  -> X=%11.3lf, Y=%11.3lf
> > (%s)\n",lond1,latd1,param_deg_to_m);
> >     proj_destroy(proj);
> >     //FWD, degrees to kilometers
> >     proj = proj_create(C,param_deg_to_km);
> >
> > proj_trans_generic(proj,PJ_FWD,&lond2,ld,1,&latd2,ld,1,NULL,0,0,NULL,0,0);
> >     printf("deg to km -> X=%11.3lf, Y=%11.3lf
> > (%s)\n\n",lond2,latd2,param_deg_to_km);
> >     proj_destroy(proj);
> >     //INV, meters to radians
> >     proj = proj_create(C,param_m_to_rad);
> >     proj_trans_generic(proj,PJ_INV,&lonr1,ld,1,&latr1,ld,1,NULL,0,0,NULL,0,0);
> >     printf("m  to rad -> lon=%13.10lf, lat=%13.10lf
> > (%s)\n",lonr1,latr1,param_m_to_rad);
> >     proj_destroy(proj);
> >     //INV, kilometers to radians
> >     proj = proj_create(C,param_km_to_rad);
> >     proj_trans_generic(proj,PJ_INV,&lonr2,ld,1,&latr2,ld,1,NULL,0,0,NULL,0,0);
> >     printf("km to rad -> lon=%13.10lf, lat=%13.10lf
> > (%s)\n",lonr2,latr2,param_km_to_rad);
> >     proj_destroy(proj);
> >     //INV, meters to degrees
> >     proj = proj_create(C,param_m_to_deg);
> >
> > proj_trans_generic(proj,PJ_INV,&lond1,ld,1,&latd1,ld,1,NULL,0,0,NULL,0,0);
> >     printf("m  to deg -> lon=%13.10lf, lat=%13.10lf
> > (%s)\n",lond1,latd1,param_m_to_deg);
> >     proj_destroy(proj);
> >     //INV, kilometers to degrees
> >     proj = proj_create(C,param_km_to_deg);
> >
> > proj_trans_generic(proj,PJ_INV,&lond2,ld,1,&latd2,ld,1,NULL,0,0,NULL,0,0);
> >     printf("km to deg -> lon=%13.10lf, lat=%13.10lf
> > (%s)\n",lond2,latd2,param_km_to_deg);
> >     proj_destroy(proj);
> >     proj_context_destroy(C);
> >     return 0;
> > }
> >
> > El lun., 18 may. 2020 a las 23:03, José Luis García Pallero
> > (<jgpallero at gmail.com>) escribió:
> > >
> > > Hello:
> > >
> > > I'm trying to do dome projections (forward and inverse) using the
> > > function proj_trans_generic() and parameter string in PROJ format (+
> > > style) and I'm a bit confused about unit conversions. My reference for
> > > the syntax is https://proj.org/operations/conversions/unitconvert.html
> > >
> > > For the forward problem I write
> > >
> > > C = proj_context_create();
> > > projection = proj_create(C,param);
> > >
> > proj_trans_generic(projection,PJ_FWD,lon,sizeof(double),nElem,lat,sizeof(d
> > ouble),nElem,NULL,0,0,NULL,0,0);
> > >
> > > I've used the param string
> > >
> > > '+proj=pipeline +step +proj=unitconvert +xy_in=deg +step +proj=utm
> > > +lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_out=km'
> > >
> > > which means that the input coordinates are in degrees and the output
> > > in kilometers. All works right. The results are the same if I pass the
> > > input coordinates in radians and I use the param string
> > >
> > > '+proj=pipeline +step +proj=utm +lon_0=3w +ellps=GRS80 +step
> > > +proj=unitconvert +xy_out=km'
> > >
> > > The problem comes when I try to do the inverse step. The procedure is the
> > same:
> > >
> > > C = proj_context_create();
> > > projection = proj_create(C,param);
> > >
> > proj_trans_generic(projection,PJ_INV,x,sizeof(double),nElem,y,sizeof(doubl
> > e),nElem,NULL,0,0,NULL,0,0);
> > >
> > > In the input xoordinates are in meters and I use the param string
> > >
> > > '+proj=utm +lon_0=3w +ellps=GRS80'
> > >
> > > The resulting longtude and latitude are correct and the units are
> > > radians. But if I use the param string
> > >
> > > '+proj=pipeline +step +proj=utm +lon_0=3w +ellps=GRS80 +step
> > > +proj=unitconvert +xy_out=deg'
> > >
> > > The output is totally wrong. I expect degrees, but the values have no
> > > sense. Also, if I use the input X and Y in kilometers ans the param
> > > string is
> > >
> > > '+proj=pipeline +step +proj=unitconvert +xy_in=km +step +proj=utm
> > > +lon_0=3w +ellps=GRS80'
> > >
> > > the result is wrong again.
> > >
> > > I suppose I'm doing something wrong with unit conversion, but I can not
> > find it
> > >
> > > Can someone help me?
> > >
> > > Thanks
> > >
> > > --
> > > *****************************************
> > > José Luis García Pallero
> > > jgpallero at gmail.com
> > > (o<
> > > / / \
> > > V_/_
> > > Use Debian GNU/Linux and enjoy!
> > > *****************************************
> >
> >
> >
> > --
> > *****************************************
> > José Luis García Pallero
> > jgpallero at gmail.com
> > (o<
> > / / \
> > V_/_
> > Use Debian GNU/Linux and enjoy!
> > *****************************************



--
*****************************************
José Luis García Pallero
jgpallero at gmail.com
(o<
/ / \
V_/_
Use Debian GNU/Linux and enjoy!
*****************************************

From jgpallero at gmail.com  Wed May 20 10:30:18 2020
From: jgpallero at gmail.com (=?UTF-8?Q?Jos=C3=A9_Luis_Garc=C3=ADa_Pallero?=)
Date: Wed, 20 May 2020 19:30:18 +0200
Subject: [PROJ] About unit conversion
In-Reply-To: <AM6P192MB0470CD2E05579C78917F7B4CEFB60@AM6P192MB0470.EURP192.PROD.OUTLOOK.COM>
References: <CAFemY3b0LABXmSSTk2r6YnsRsuC9G+OEZ=smrw8A0hRpc3uj_w@mail.gmail.com>
 <CAFemY3Z5RS+GikzLC0kYQmD0v2pDFY82i5DJe1s+d3jDFkEXDw@mail.gmail.com>
 <8100b13c03ef47f1ac26db48ce6f62fc@sdfe.dk>
 <CAFemY3ZuFqybZ6drR6UjZ=geVefRZ15GqdtNX3XOHHZwbVWSbg@mail.gmail.com>
 <AM6P192MB0470CD2E05579C78917F7B4CEFB60@AM6P192MB0470.EURP192.PROD.OUTLOOK.COM>
Message-ID: <CAFemY3ZKUvDpgZZjrY4mFX+aeOTUR-wNsmVHsjJChk4=F3aXFQ@mail.gmail.com>

El mié., 20 may. 2020 a las 19:24, Lesparre, Jochem
(<Jochem.Lesparre at kadaster.nl>) escribió:
>
> I just had a quick look, but to me it looks like you are trying to convert between angles and distances?
>
> +proj=utm gives angular results that can be converted to deg, rad or maybe gon, but NOT to m, km of ft! This is such a fundamental part of how PROJ works, that it is probably not explained in the documentation.
>
> If I mis understood, sorry for the confusion.

I'm trying to perform first the forward step in the projection, i.e.,
from geodetic (angular) coordinates to projected (linear) ones. This
step works without problems whatever the unit combinations I use
(radians to meters, radians to kilometers, degrees to meters or
degrees to kilometers). The problem is with the inverse step , i.e.,
from projected (linear) coordinates to geodetic (angular) ones. I want
to use the output coordinates of the forward step as input for the
inverse step. The only combination it works is from meters to radians.
Whatever other combination fails. Attached to this message
(https://lists.osgeo.org/pipermail/proj/2020-May/009648.html) I sent a
C source code with an example showing what I want to do

Cheers

> Kind regards, Jochem
>
>
> -----Original Message-----
> From: PROJ <proj-bounces at lists.osgeo.org> On Behalf Of José Luis García Pallero
> Sent: woensdag 20 mei 2020 18:34
> To: Kristian Evers <kreve at sdfe.dk>
> Cc: proj at lists.osgeo.org
> Subject: Re: [PROJ] About unit conversion
>
> El mié., 20 may. 2020 a las 11:00, Kristian Evers (<kreve at sdfe.dk>) escribió:
> >
> > I see that you don't specify the input units in your unitconvert
> > steps. Try adding a
> > +xy_in parameter to your unitconvert steps and see if that fixes the problem.
> > When you only specify of of either +xy_in or +xy_out the operation
> > becomes somewhat uni-directional which is why not all of your pipelines works in reverse.
> >
> > See https://proj.org/operations/conversions/unitconvert.html for more.
>
> Thank you for your answer, Kristian, but I can't understand why my program fails. Clearly, for FWD and input in radians and output in meters all works without any unitconversion. Also for INV step with meters as input and radians as output, i.e., using only "+proj=utm
> +lon_0=3w +ellps=GRS80" as parameters string is enough. Also for any
> combination in the FWD step all works.
>
> For example using "+proj=pipeline +step +proj=unitconvert +xy_in=deg
> +step +proj=utm +lon_0=3w +ellps=GRS80 +step +proj=unitconvert
> +xy_out=km" accepts as input degrees and returns kilometers. But I
> cant understand why in this case for the INV step the parameters string "+proj=pipeline +step +proj=unitconvert +xy_in=km +step
> +proj=utm +lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_out=deg"
> is incorrect. I've tested several combinations and none of them works:
>
> "+proj=utm +lon_0=3w +ellps=GRS80" -> wrong results "+proj=pipeline +step +proj=unitconvert +xy_in=km +step +proj=utm
> +lon_0=3w +ellps=GRS80" -> wrong results
> "+proj=pipeline +step +proj=unitconvert +xy_in=km +xy_out=m +step
> +proj=utm +lon_0=3w +ellps=GRS80" -> wrong results (same numeric value
> as before)
> "+proj=pipeline +step +proj=unitconvert +xy_in=km +xy_out=deg +step
> +proj=utm +lon_0=3w +ellps=GRS80" -> proj_create: Error -59
> (inconsistent unit type between input and output): Pipeline: Bad step
> definition: proj=unitconvert (inconsistent unit type between input and
> output)
> "+proj=pipeline +step +proj=utm +lon_0=3w +ellps=GRS80 +step
> +proj=unitconvert +xy_in=km +xy_out=deg" -> proj_create: Error -59
> (inconsistent unit type between input and output): Pipeline: Bad step
> definition: proj=unitconvert (inconsistent unit type between input and
> output)
> "+proj=pipeline +step +proj=unitconvert +xy_out=deg +step +proj=utm
> +lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_in=km" -> wrong
> results
> "+proj=pipeline +step +proj=unitconvert +xy_in=km +step +proj=utm
> +lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_out=deg" -> wrong
> results
>
> I can't understand the way as unitconvert works, neither reading https://proj.org/operations/conversions/unitconvert.html
>
> For only one conversion (km to radians or meters to degrees) the problem is only again with the INV step
>
> Thanks
>
>
>
>
>
> >
> > /Kristian
> >
> > > -----Original Message-----
> > > From: PROJ <proj-bounces at lists.osgeo.org> On Behalf Of José Luis
> > > García Pallero
> > > Sent: 19. maj 2020 10:59
> > > To: proj at lists.osgeo.org
> > > Subject: Re: [PROJ] About unit conversion
> > >
> > > I've written a small program in order to illustrate my last mail.
> > > Attached (and pasted at the bottom of the message) I send the code.
> > > The results are
> > >
> > > Original data -> lon: -6.00000, lat: 43.00000 (degrees) -> lon:
> > > -0.1047197551, lat: 0.7504915784 (radians)
> > >
> > > rad to m  -> X= 255466.981, Y=4765182.933 (+proj=utm +lon_0=3w
> > > +ellps=GRS80)
> > > rad to km -> X=    255.467, Y=   4765.183 (+proj=pipeline +step
> > > +proj=utm +lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_out=km)
> > > deg to m  -> X= 255466.981, Y=4765182.933 (+proj=pipeline +step
> > > +proj=unitconvert +xy_in=deg +step +proj=utm +lon_0=3w +ellps=GRS80)
> > > deg to km -> X=    255.467, Y=   4765.183 (+proj=pipeline +step
> > > +proj=unitconvert +xy_in=deg +step +proj=utm +lon_0=3w +ellps=GRS80
> > > +step +proj=unitconvert +xy_out=km)
> > >
> > > m  to rad -> lon=-0.1047197551, lat= 0.7504915784 (+proj=utm
> > > +lon_0=3w
> > > +ellps=GRS80)
> > > km to rad -> lon=-0.0001306633, lat= 0.0000007501 (+proj=pipeline
> > > +step +proj=unitconvert +xy_in=km +step +proj=utm +lon_0=3w
> > > +ellps=GRS80)
> > > m  to deg -> lon=-0.1300126568, lat= 0.0130928532 (+proj=pipeline
> > > +step +proj=utm +lon_0=3w +ellps=GRS80 +step +proj=unitconvert
> > > +xy_out=deg)
> > > km to deg -> lon=-0.0001307025, lat= 0.0000000131 (+proj=pipeline
> > > +step +proj=unitconvert +xy_in=km +step +proj=utm +lon_0=3w
> > > +ellps=GRS80 +step +proj=unitconvert +xy_out=deg)
> > >
> > > As you can see, the only right INV conversion is the
> > > meters_to_radians one. All other combinations produce all different
> > > results, but all combinations for the FWD step are right. Im using
> > > PROJ 7.0.1 from the Debian Sid repositories
> > >
> > > ***********************
> > >
> > > #include<stdio.h>
> > > #include<stdlib.h>
> > > #include<math.h>
> > > #include<proj.h>
> > > #define CONST_PI (3.14159265358979323846264338328) int main() {
> > >     double lond1=-6.0,latd1=43.0,lond2=lond1,latd2=latd1;
> > >     double
> > > lonr1=lond1*CONST_PI/180.0,latr1=latd1*CONST_PI/180.0,lonr2=lonr1,la
> > > tr2
> > > =latr1;
> > >     char param_rad_to_m[]="+proj=utm +lon_0=3w +ellps=GRS80";
> > >     char param_rad_to_km[]="+proj=pipeline +step +proj=utm +lon_0=3w
> > > +ellps=GRS80 +step +proj=unitconvert +xy_out=km";
> > >     char param_deg_to_m[]="+proj=pipeline +step +proj=unitconvert
> > > +xy_in=deg +step +proj=utm +lon_0=3w +ellps=GRS80";
> > >     char param_deg_to_km[]="+proj=pipeline +step +proj=unitconvert
> > > +xy_in=deg +step +proj=utm +lon_0=3w +ellps=GRS80 +step
> > > +proj=unitconvert +xy_out=km";
> > >     char param_m_to_rad[]="+proj=utm +lon_0=3w +ellps=GRS80";
> > >     char param_km_to_rad[]="+proj=pipeline +step +proj=unitconvert
> > > +xy_in=km +step +proj=utm +lon_0=3w +ellps=GRS80";
> > >     char param_m_to_deg[]="+proj=pipeline +step +proj=utm +lon_0=3w
> > > +ellps=GRS80 +step +proj=unitconvert +xy_out=deg";
> > >     char param_km_to_deg[]="+proj=pipeline +step +proj=unitconvert
> > > +xy_in=km +step +proj=utm +lon_0=3w +ellps=GRS80 +step
> > > +proj=unitconvert +xy_out=deg";
> > >     PJ_CONTEXT *C=proj_context_create();
> > >     PJ *proj=NULL;
> > >     size_t ld=sizeof(double);
> > >
> > >     //Display original data
> > >     printf("Original data -> lon: %.5lf, lat: %.5lf (degrees) -> lon:
> > > %.10lf, lat: %.10lf (radians)\n\n",
> > >            lond1,latd1,lonr1,latr1);
> > >     //FWD, radiands to meters
> > >     proj = proj_create(C,param_rad_to_m);
> > >
> > > proj_trans_generic(proj,PJ_FWD,&lonr1,ld,1,&latr1,ld,1,NULL,0,0,NULL,0,0);
> > >     printf("rad to m  -> X=%11.3lf, Y=%11.3lf
> > > (%s)\n",lonr1,latr1,param_rad_to_m);
> > >     proj_destroy(proj);
> > >     //FWD, radiands to kilometers
> > >     proj = proj_create(C,param_rad_to_km);
> > >
> > > proj_trans_generic(proj,PJ_FWD,&lonr2,ld,1,&latr2,ld,1,NULL,0,0,NULL,0,0);
> > >     printf("rad to km -> X=%11.3lf, Y=%11.3lf
> > > (%s)\n",lonr2,latr2,param_rad_to_km);
> > >     proj_destroy(proj);
> > >     //FWD, degrees to meters
> > >     proj = proj_create(C,param_deg_to_m);
> > >
> > > proj_trans_generic(proj,PJ_FWD,&lond1,ld,1,&latd1,ld,1,NULL,0,0,NULL,0,0);
> > >     printf("deg to m  -> X=%11.3lf, Y=%11.3lf
> > > (%s)\n",lond1,latd1,param_deg_to_m);
> > >     proj_destroy(proj);
> > >     //FWD, degrees to kilometers
> > >     proj = proj_create(C,param_deg_to_km);
> > >
> > > proj_trans_generic(proj,PJ_FWD,&lond2,ld,1,&latd2,ld,1,NULL,0,0,NULL,0,0);
> > >     printf("deg to km -> X=%11.3lf, Y=%11.3lf
> > > (%s)\n\n",lond2,latd2,param_deg_to_km);
> > >     proj_destroy(proj);
> > >     //INV, meters to radians
> > >     proj = proj_create(C,param_m_to_rad);
> > >     proj_trans_generic(proj,PJ_INV,&lonr1,ld,1,&latr1,ld,1,NULL,0,0,NULL,0,0);
> > >     printf("m  to rad -> lon=%13.10lf, lat=%13.10lf
> > > (%s)\n",lonr1,latr1,param_m_to_rad);
> > >     proj_destroy(proj);
> > >     //INV, kilometers to radians
> > >     proj = proj_create(C,param_km_to_rad);
> > >     proj_trans_generic(proj,PJ_INV,&lonr2,ld,1,&latr2,ld,1,NULL,0,0,NULL,0,0);
> > >     printf("km to rad -> lon=%13.10lf, lat=%13.10lf
> > > (%s)\n",lonr2,latr2,param_km_to_rad);
> > >     proj_destroy(proj);
> > >     //INV, meters to degrees
> > >     proj = proj_create(C,param_m_to_deg);
> > >
> > > proj_trans_generic(proj,PJ_INV,&lond1,ld,1,&latd1,ld,1,NULL,0,0,NULL,0,0);
> > >     printf("m  to deg -> lon=%13.10lf, lat=%13.10lf
> > > (%s)\n",lond1,latd1,param_m_to_deg);
> > >     proj_destroy(proj);
> > >     //INV, kilometers to degrees
> > >     proj = proj_create(C,param_km_to_deg);
> > >
> > > proj_trans_generic(proj,PJ_INV,&lond2,ld,1,&latd2,ld,1,NULL,0,0,NULL,0,0);
> > >     printf("km to deg -> lon=%13.10lf, lat=%13.10lf
> > > (%s)\n",lond2,latd2,param_km_to_deg);
> > >     proj_destroy(proj);
> > >     proj_context_destroy(C);
> > >     return 0;
> > > }
> > >
> > > El lun., 18 may. 2020 a las 23:03, José Luis García Pallero
> > > (<jgpallero at gmail.com>) escribió:
> > > >
> > > > Hello:
> > > >
> > > > I'm trying to do dome projections (forward and inverse) using the
> > > > function proj_trans_generic() and parameter string in PROJ format
> > > > (+
> > > > style) and I'm a bit confused about unit conversions. My reference
> > > > for the syntax is
> > > > https://proj.org/operations/conversions/unitconvert.html
> > > >
> > > > For the forward problem I write
> > > >
> > > > C = proj_context_create();
> > > > projection = proj_create(C,param);
> > > >
> > > proj_trans_generic(projection,PJ_FWD,lon,sizeof(double),nElem,lat,si
> > > zeof(d
> > > ouble),nElem,NULL,0,0,NULL,0,0);
> > > >
> > > > I've used the param string
> > > >
> > > > '+proj=pipeline +step +proj=unitconvert +xy_in=deg +step +proj=utm
> > > > +lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_out=km'
> > > >
> > > > which means that the input coordinates are in degrees and the
> > > > output in kilometers. All works right. The results are the same if
> > > > I pass the input coordinates in radians and I use the param string
> > > >
> > > > '+proj=pipeline +step +proj=utm +lon_0=3w +ellps=GRS80 +step
> > > > +proj=unitconvert +xy_out=km'
> > > >
> > > > The problem comes when I try to do the inverse step. The procedure
> > > > is the
> > > same:
> > > >
> > > > C = proj_context_create();
> > > > projection = proj_create(C,param);
> > > >
> > > proj_trans_generic(projection,PJ_INV,x,sizeof(double),nElem,y,sizeof
> > > (doubl
> > > e),nElem,NULL,0,0,NULL,0,0);
> > > >
> > > > In the input xoordinates are in meters and I use the param string
> > > >
> > > > '+proj=utm +lon_0=3w +ellps=GRS80'
> > > >
> > > > The resulting longtude and latitude are correct and the units are
> > > > radians. But if I use the param string
> > > >
> > > > '+proj=pipeline +step +proj=utm +lon_0=3w +ellps=GRS80 +step
> > > > +proj=unitconvert +xy_out=deg'
> > > >
> > > > The output is totally wrong. I expect degrees, but the values have
> > > > no sense. Also, if I use the input X and Y in kilometers ans the
> > > > param string is
> > > >
> > > > '+proj=pipeline +step +proj=unitconvert +xy_in=km +step +proj=utm
> > > > +lon_0=3w +ellps=GRS80'
> > > >
> > > > the result is wrong again.
> > > >
> > > > I suppose I'm doing something wrong with unit conversion, but I
> > > > can not
> > > find it
> > > >
> > > > Can someone help me?
> > > >
> > > > Thanks
> > > >
> > > > --
> > > > *****************************************
> > > > José Luis García Pallero
> > > > jgpallero at gmail.com
> > > > (o<
> > > > / / \
> > > > V_/_
> > > > Use Debian GNU/Linux and enjoy!
> > > > *****************************************
> > >
> > >
> > >
> > > --
> > > *****************************************
> > > José Luis García Pallero
> > > jgpallero at gmail.com
> > > (o<
> > > / / \
> > > V_/_
> > > Use Debian GNU/Linux and enjoy!
> > > *****************************************
>
>
>
> --
> *****************************************
> José Luis García Pallero
> jgpallero at gmail.com
> (o<
> / / \
> V_/_
> Use Debian GNU/Linux and enjoy!
> *****************************************
> _______________________________________________
> PROJ mailing list
> PROJ at lists.osgeo.org
> https://lists.osgeo.org/mailman/listinfo/proj



-- 
*****************************************
José Luis García Pallero
jgpallero at gmail.com
(o<
/ / \
V_/_
Use Debian GNU/Linux and enjoy!
*****************************************

From Jochem.Lesparre at kadaster.nl  Wed May 20 10:24:07 2020
From: Jochem.Lesparre at kadaster.nl (Lesparre, Jochem)
Date: Wed, 20 May 2020 17:24:07 +0000
Subject: [PROJ] About unit conversion
In-Reply-To: <CAFemY3ZuFqybZ6drR6UjZ=geVefRZ15GqdtNX3XOHHZwbVWSbg@mail.gmail.com>
References: <CAFemY3b0LABXmSSTk2r6YnsRsuC9G+OEZ=smrw8A0hRpc3uj_w@mail.gmail.com>
 <CAFemY3Z5RS+GikzLC0kYQmD0v2pDFY82i5DJe1s+d3jDFkEXDw@mail.gmail.com>
 <8100b13c03ef47f1ac26db48ce6f62fc@sdfe.dk>
 <CAFemY3ZuFqybZ6drR6UjZ=geVefRZ15GqdtNX3XOHHZwbVWSbg@mail.gmail.com>
Message-ID: <AM6P192MB0470CD2E05579C78917F7B4CEFB60@AM6P192MB0470.EURP192.PROD.OUTLOOK.COM>

I just had a quick look, but to me it looks like you are trying to convert between angles and distances?

+proj=utm gives angular results that can be converted to deg, rad or maybe gon, but NOT to m, km of ft! This is such a fundamental part of how PROJ works, that it is probably not explained in the documentation.

If I mis understood, sorry for the confusion.
Kind regards, Jochem


-----Original Message-----
From: PROJ <proj-bounces at lists.osgeo.org> On Behalf Of José Luis García Pallero
Sent: woensdag 20 mei 2020 18:34
To: Kristian Evers <kreve at sdfe.dk>
Cc: proj at lists.osgeo.org
Subject: Re: [PROJ] About unit conversion

El mié., 20 may. 2020 a las 11:00, Kristian Evers (<kreve at sdfe.dk>) escribió:
>
> I see that you don't specify the input units in your unitconvert 
> steps. Try adding a
> +xy_in parameter to your unitconvert steps and see if that fixes the problem.
> When you only specify of of either +xy_in or +xy_out the operation 
> becomes somewhat uni-directional which is why not all of your pipelines works in reverse.
>
> See https://proj.org/operations/conversions/unitconvert.html for more.

Thank you for your answer, Kristian, but I can't understand why my program fails. Clearly, for FWD and input in radians and output in meters all works without any unitconversion. Also for INV step with meters as input and radians as output, i.e., using only "+proj=utm
+lon_0=3w +ellps=GRS80" as parameters string is enough. Also for any
combination in the FWD step all works.

For example using "+proj=pipeline +step +proj=unitconvert +xy_in=deg
+step +proj=utm +lon_0=3w +ellps=GRS80 +step +proj=unitconvert 
+xy_out=km" accepts as input degrees and returns kilometers. But I
cant understand why in this case for the INV step the parameters string "+proj=pipeline +step +proj=unitconvert +xy_in=km +step
+proj=utm +lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_out=deg"
is incorrect. I've tested several combinations and none of them works:

"+proj=utm +lon_0=3w +ellps=GRS80" -> wrong results "+proj=pipeline +step +proj=unitconvert +xy_in=km +step +proj=utm
+lon_0=3w +ellps=GRS80" -> wrong results
"+proj=pipeline +step +proj=unitconvert +xy_in=km +xy_out=m +step
+proj=utm +lon_0=3w +ellps=GRS80" -> wrong results (same numeric value
as before)
"+proj=pipeline +step +proj=unitconvert +xy_in=km +xy_out=deg +step
+proj=utm +lon_0=3w +ellps=GRS80" -> proj_create: Error -59
(inconsistent unit type between input and output): Pipeline: Bad step
definition: proj=unitconvert (inconsistent unit type between input and
output)
"+proj=pipeline +step +proj=utm +lon_0=3w +ellps=GRS80 +step
+proj=unitconvert +xy_in=km +xy_out=deg" -> proj_create: Error -59
(inconsistent unit type between input and output): Pipeline: Bad step
definition: proj=unitconvert (inconsistent unit type between input and
output)
"+proj=pipeline +step +proj=unitconvert +xy_out=deg +step +proj=utm
+lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_in=km" -> wrong
results
"+proj=pipeline +step +proj=unitconvert +xy_in=km +step +proj=utm
+lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_out=deg" -> wrong
results

I can't understand the way as unitconvert works, neither reading https://proj.org/operations/conversions/unitconvert.html

For only one conversion (km to radians or meters to degrees) the problem is only again with the INV step

Thanks





>
> /Kristian
>
> > -----Original Message-----
> > From: PROJ <proj-bounces at lists.osgeo.org> On Behalf Of José Luis 
> > García Pallero
> > Sent: 19. maj 2020 10:59
> > To: proj at lists.osgeo.org
> > Subject: Re: [PROJ] About unit conversion
> >
> > I've written a small program in order to illustrate my last mail.
> > Attached (and pasted at the bottom of the message) I send the code.
> > The results are
> >
> > Original data -> lon: -6.00000, lat: 43.00000 (degrees) -> lon:
> > -0.1047197551, lat: 0.7504915784 (radians)
> >
> > rad to m  -> X= 255466.981, Y=4765182.933 (+proj=utm +lon_0=3w
> > +ellps=GRS80)
> > rad to km -> X=    255.467, Y=   4765.183 (+proj=pipeline +step
> > +proj=utm +lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_out=km)
> > deg to m  -> X= 255466.981, Y=4765182.933 (+proj=pipeline +step
> > +proj=unitconvert +xy_in=deg +step +proj=utm +lon_0=3w +ellps=GRS80)
> > deg to km -> X=    255.467, Y=   4765.183 (+proj=pipeline +step
> > +proj=unitconvert +xy_in=deg +step +proj=utm +lon_0=3w +ellps=GRS80 
> > +step +proj=unitconvert +xy_out=km)
> >
> > m  to rad -> lon=-0.1047197551, lat= 0.7504915784 (+proj=utm 
> > +lon_0=3w
> > +ellps=GRS80)
> > km to rad -> lon=-0.0001306633, lat= 0.0000007501 (+proj=pipeline
> > +step +proj=unitconvert +xy_in=km +step +proj=utm +lon_0=3w
> > +ellps=GRS80)
> > m  to deg -> lon=-0.1300126568, lat= 0.0130928532 (+proj=pipeline
> > +step +proj=utm +lon_0=3w +ellps=GRS80 +step +proj=unitconvert
> > +xy_out=deg)
> > km to deg -> lon=-0.0001307025, lat= 0.0000000131 (+proj=pipeline
> > +step +proj=unitconvert +xy_in=km +step +proj=utm +lon_0=3w
> > +ellps=GRS80 +step +proj=unitconvert +xy_out=deg)
> >
> > As you can see, the only right INV conversion is the 
> > meters_to_radians one. All other combinations produce all different 
> > results, but all combinations for the FWD step are right. Im using 
> > PROJ 7.0.1 from the Debian Sid repositories
> >
> > ***********************
> >
> > #include<stdio.h>
> > #include<stdlib.h>
> > #include<math.h>
> > #include<proj.h>
> > #define CONST_PI (3.14159265358979323846264338328) int main() {
> >     double lond1=-6.0,latd1=43.0,lond2=lond1,latd2=latd1;
> >     double
> > lonr1=lond1*CONST_PI/180.0,latr1=latd1*CONST_PI/180.0,lonr2=lonr1,la
> > tr2
> > =latr1;
> >     char param_rad_to_m[]="+proj=utm +lon_0=3w +ellps=GRS80";
> >     char param_rad_to_km[]="+proj=pipeline +step +proj=utm +lon_0=3w
> > +ellps=GRS80 +step +proj=unitconvert +xy_out=km";
> >     char param_deg_to_m[]="+proj=pipeline +step +proj=unitconvert
> > +xy_in=deg +step +proj=utm +lon_0=3w +ellps=GRS80";
> >     char param_deg_to_km[]="+proj=pipeline +step +proj=unitconvert
> > +xy_in=deg +step +proj=utm +lon_0=3w +ellps=GRS80 +step 
> > +proj=unitconvert +xy_out=km";
> >     char param_m_to_rad[]="+proj=utm +lon_0=3w +ellps=GRS80";
> >     char param_km_to_rad[]="+proj=pipeline +step +proj=unitconvert
> > +xy_in=km +step +proj=utm +lon_0=3w +ellps=GRS80";
> >     char param_m_to_deg[]="+proj=pipeline +step +proj=utm +lon_0=3w
> > +ellps=GRS80 +step +proj=unitconvert +xy_out=deg";
> >     char param_km_to_deg[]="+proj=pipeline +step +proj=unitconvert
> > +xy_in=km +step +proj=utm +lon_0=3w +ellps=GRS80 +step 
> > +proj=unitconvert +xy_out=deg";
> >     PJ_CONTEXT *C=proj_context_create();
> >     PJ *proj=NULL;
> >     size_t ld=sizeof(double);
> >
> >     //Display original data
> >     printf("Original data -> lon: %.5lf, lat: %.5lf (degrees) -> lon:
> > %.10lf, lat: %.10lf (radians)\n\n",
> >            lond1,latd1,lonr1,latr1);
> >     //FWD, radiands to meters
> >     proj = proj_create(C,param_rad_to_m);
> >
> > proj_trans_generic(proj,PJ_FWD,&lonr1,ld,1,&latr1,ld,1,NULL,0,0,NULL,0,0);
> >     printf("rad to m  -> X=%11.3lf, Y=%11.3lf 
> > (%s)\n",lonr1,latr1,param_rad_to_m);
> >     proj_destroy(proj);
> >     //FWD, radiands to kilometers
> >     proj = proj_create(C,param_rad_to_km);
> >
> > proj_trans_generic(proj,PJ_FWD,&lonr2,ld,1,&latr2,ld,1,NULL,0,0,NULL,0,0);
> >     printf("rad to km -> X=%11.3lf, Y=%11.3lf 
> > (%s)\n",lonr2,latr2,param_rad_to_km);
> >     proj_destroy(proj);
> >     //FWD, degrees to meters
> >     proj = proj_create(C,param_deg_to_m);
> >
> > proj_trans_generic(proj,PJ_FWD,&lond1,ld,1,&latd1,ld,1,NULL,0,0,NULL,0,0);
> >     printf("deg to m  -> X=%11.3lf, Y=%11.3lf 
> > (%s)\n",lond1,latd1,param_deg_to_m);
> >     proj_destroy(proj);
> >     //FWD, degrees to kilometers
> >     proj = proj_create(C,param_deg_to_km);
> >
> > proj_trans_generic(proj,PJ_FWD,&lond2,ld,1,&latd2,ld,1,NULL,0,0,NULL,0,0);
> >     printf("deg to km -> X=%11.3lf, Y=%11.3lf 
> > (%s)\n\n",lond2,latd2,param_deg_to_km);
> >     proj_destroy(proj);
> >     //INV, meters to radians
> >     proj = proj_create(C,param_m_to_rad);
> >     proj_trans_generic(proj,PJ_INV,&lonr1,ld,1,&latr1,ld,1,NULL,0,0,NULL,0,0);
> >     printf("m  to rad -> lon=%13.10lf, lat=%13.10lf 
> > (%s)\n",lonr1,latr1,param_m_to_rad);
> >     proj_destroy(proj);
> >     //INV, kilometers to radians
> >     proj = proj_create(C,param_km_to_rad);
> >     proj_trans_generic(proj,PJ_INV,&lonr2,ld,1,&latr2,ld,1,NULL,0,0,NULL,0,0);
> >     printf("km to rad -> lon=%13.10lf, lat=%13.10lf 
> > (%s)\n",lonr2,latr2,param_km_to_rad);
> >     proj_destroy(proj);
> >     //INV, meters to degrees
> >     proj = proj_create(C,param_m_to_deg);
> >
> > proj_trans_generic(proj,PJ_INV,&lond1,ld,1,&latd1,ld,1,NULL,0,0,NULL,0,0);
> >     printf("m  to deg -> lon=%13.10lf, lat=%13.10lf 
> > (%s)\n",lond1,latd1,param_m_to_deg);
> >     proj_destroy(proj);
> >     //INV, kilometers to degrees
> >     proj = proj_create(C,param_km_to_deg);
> >
> > proj_trans_generic(proj,PJ_INV,&lond2,ld,1,&latd2,ld,1,NULL,0,0,NULL,0,0);
> >     printf("km to deg -> lon=%13.10lf, lat=%13.10lf 
> > (%s)\n",lond2,latd2,param_km_to_deg);
> >     proj_destroy(proj);
> >     proj_context_destroy(C);
> >     return 0;
> > }
> >
> > El lun., 18 may. 2020 a las 23:03, José Luis García Pallero
> > (<jgpallero at gmail.com>) escribió:
> > >
> > > Hello:
> > >
> > > I'm trying to do dome projections (forward and inverse) using the 
> > > function proj_trans_generic() and parameter string in PROJ format 
> > > (+
> > > style) and I'm a bit confused about unit conversions. My reference 
> > > for the syntax is 
> > > https://proj.org/operations/conversions/unitconvert.html
> > >
> > > For the forward problem I write
> > >
> > > C = proj_context_create();
> > > projection = proj_create(C,param);
> > >
> > proj_trans_generic(projection,PJ_FWD,lon,sizeof(double),nElem,lat,si
> > zeof(d
> > ouble),nElem,NULL,0,0,NULL,0,0);
> > >
> > > I've used the param string
> > >
> > > '+proj=pipeline +step +proj=unitconvert +xy_in=deg +step +proj=utm
> > > +lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_out=km'
> > >
> > > which means that the input coordinates are in degrees and the 
> > > output in kilometers. All works right. The results are the same if 
> > > I pass the input coordinates in radians and I use the param string
> > >
> > > '+proj=pipeline +step +proj=utm +lon_0=3w +ellps=GRS80 +step
> > > +proj=unitconvert +xy_out=km'
> > >
> > > The problem comes when I try to do the inverse step. The procedure 
> > > is the
> > same:
> > >
> > > C = proj_context_create();
> > > projection = proj_create(C,param);
> > >
> > proj_trans_generic(projection,PJ_INV,x,sizeof(double),nElem,y,sizeof
> > (doubl
> > e),nElem,NULL,0,0,NULL,0,0);
> > >
> > > In the input xoordinates are in meters and I use the param string
> > >
> > > '+proj=utm +lon_0=3w +ellps=GRS80'
> > >
> > > The resulting longtude and latitude are correct and the units are 
> > > radians. But if I use the param string
> > >
> > > '+proj=pipeline +step +proj=utm +lon_0=3w +ellps=GRS80 +step
> > > +proj=unitconvert +xy_out=deg'
> > >
> > > The output is totally wrong. I expect degrees, but the values have 
> > > no sense. Also, if I use the input X and Y in kilometers ans the 
> > > param string is
> > >
> > > '+proj=pipeline +step +proj=unitconvert +xy_in=km +step +proj=utm
> > > +lon_0=3w +ellps=GRS80'
> > >
> > > the result is wrong again.
> > >
> > > I suppose I'm doing something wrong with unit conversion, but I 
> > > can not
> > find it
> > >
> > > Can someone help me?
> > >
> > > Thanks
> > >
> > > --
> > > *****************************************
> > > José Luis García Pallero
> > > jgpallero at gmail.com
> > > (o<
> > > / / \
> > > V_/_
> > > Use Debian GNU/Linux and enjoy!
> > > *****************************************
> >
> >
> >
> > --
> > *****************************************
> > José Luis García Pallero
> > jgpallero at gmail.com
> > (o<
> > / / \
> > V_/_
> > Use Debian GNU/Linux and enjoy!
> > *****************************************



--
*****************************************
José Luis García Pallero
jgpallero at gmail.com
(o<
/ / \
V_/_
Use Debian GNU/Linux and enjoy!
*****************************************
_______________________________________________
PROJ mailing list
PROJ at lists.osgeo.org
https://lists.osgeo.org/mailman/listinfo/proj

From kristianevers at gmail.com  Wed May 20 11:28:16 2020
From: kristianevers at gmail.com (Kristian Evers)
Date: Wed, 20 May 2020 20:28:16 +0200
Subject: [PROJ] About unit conversion
In-Reply-To: <CAFemY3ZKUvDpgZZjrY4mFX+aeOTUR-wNsmVHsjJChk4=F3aXFQ@mail.gmail.com>
References: <CAFemY3b0LABXmSSTk2r6YnsRsuC9G+OEZ=smrw8A0hRpc3uj_w@mail.gmail.com>
 <CAFemY3Z5RS+GikzLC0kYQmD0v2pDFY82i5DJe1s+d3jDFkEXDw@mail.gmail.com>
 <8100b13c03ef47f1ac26db48ce6f62fc@sdfe.dk>
 <CAFemY3ZuFqybZ6drR6UjZ=geVefRZ15GqdtNX3XOHHZwbVWSbg@mail.gmail.com>
 <AM6P192MB0470CD2E05579C78917F7B4CEFB60@AM6P192MB0470.EURP192.PROD.OUTLOOK.COM>
 <CAFemY3ZKUvDpgZZjrY4mFX+aeOTUR-wNsmVHsjJChk4=F3aXFQ@mail.gmail.com>
Message-ID: <AC3C9C92-120D-4BC3-982B-5F815B019519@gmail.com>

I’ve look at all the pipeline definitions in the attached code. Below are my comments for each of them.
I agree with Jochem, you seem to be passing linear coordinates to a projection that expects angular
coordinates. Looking back, I see that my comments about the unitconvert steps were not the cause of
your problems. Had you been using different units it could have been the case - it is always better to
be explicit here. 

"+proj=utm +lon_0=3w +ellps=GRS80”

	No problems here in either directions.

"+proj=pipeline +step +proj=utm +lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_out=km

	No problems here in either directions, but could benefit from a added +xy_in=m in the unitconvert step.

"+proj=pipeline +step +proj=unitconvert +xy_in=deg +step +proj=utm +lon_0=3w +ellps=GRS80”

	Same as above, clarify uniconvert step be adding +xy_out=rad

"+proj=pipeline +step +proj=unitconvert +xy_in=deg +step +proj=utm +lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_out=km”

	Clarify both unitconvert steps by adding xy_out=rad to the first and +xy_in=m to the second

"+proj=utm +lon_0=3w +ellps=GRS80”

	No problems here

"+proj=pipeline +step +proj=unitconvert +xy_in=km +step +proj=utm +lon_0=3w +ellps=GRS80”

	Again, clarify unitconvert step by adding xy_out=m

"+proj=pipeline +step +proj=utm +lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_out=deg”

	This is nonsense, projected coordinates from UTM can’t be converted to degrees. 
	Probably missing a +inv in the utm step. If that is the case, clarify unitconvert step with +xy_in=rad

"+proj=pipeline +step +proj=unitconvert +xy_in=km +step +proj=utm +lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_out=deg”

	Also nonsense, passing km to the UTM projection is not possible, UTM want’s radians as input. Probably again missing a +inv
	in the utm step. Clarify unitconvert steps by stating both input and output units.


/Kristian


> On 20 May 2020, at 19:30, José Luis García Pallero <jgpallero at gmail.com> wrote:
> 
> El mié., 20 may. 2020 a las 19:24, Lesparre, Jochem
> (<Jochem.Lesparre at kadaster.nl <mailto:Jochem.Lesparre at kadaster.nl>>) escribió:
>> 
>> I just had a quick look, but to me it looks like you are trying to convert between angles and distances?
>> 
>> +proj=utm gives angular results that can be converted to deg, rad or maybe gon, but NOT to m, km of ft! This is such a fundamental part of how PROJ works, that it is probably not explained in the documentation.
>> 
>> If I mis understood, sorry for the confusion.
> 
> I'm trying to perform first the forward step in the projection, i.e.,
> from geodetic (angular) coordinates to projected (linear) ones. This
> step works without problems whatever the unit combinations I use
> (radians to meters, radians to kilometers, degrees to meters or
> degrees to kilometers). The problem is with the inverse step , i.e.,
> from projected (linear) coordinates to geodetic (angular) ones. I want
> to use the output coordinates of the forward step as input for the
> inverse step. The only combination it works is from meters to radians.
> Whatever other combination fails. Attached to this message
> (https://lists.osgeo.org/pipermail/proj/2020-May/009648.html <https://lists.osgeo.org/pipermail/proj/2020-May/009648.html>) I sent a
> C source code with an example showing what I want to do
> 
> Cheers
> 
>> Kind regards, Jochem
>> 
>> 
>> -----Original Message-----
>> From: PROJ <proj-bounces at lists.osgeo.org> On Behalf Of José Luis García Pallero
>> Sent: woensdag 20 mei 2020 18:34
>> To: Kristian Evers <kreve at sdfe.dk>
>> Cc: proj at lists.osgeo.org
>> Subject: Re: [PROJ] About unit conversion
>> 
>> El mié., 20 may. 2020 a las 11:00, Kristian Evers (<kreve at sdfe.dk>) escribió:
>>> 
>>> I see that you don't specify the input units in your unitconvert
>>> steps. Try adding a
>>> +xy_in parameter to your unitconvert steps and see if that fixes the problem.
>>> When you only specify of of either +xy_in or +xy_out the operation
>>> becomes somewhat uni-directional which is why not all of your pipelines works in reverse.
>>> 
>>> See https://proj.org/operations/conversions/unitconvert.html for more.
>> 
>> Thank you for your answer, Kristian, but I can't understand why my program fails. Clearly, for FWD and input in radians and output in meters all works without any unitconversion. Also for INV step with meters as input and radians as output, i.e., using only "+proj=utm
>> +lon_0=3w +ellps=GRS80" as parameters string is enough. Also for any
>> combination in the FWD step all works.
>> 
>> For example using "+proj=pipeline +step +proj=unitconvert +xy_in=deg
>> +step +proj=utm +lon_0=3w +ellps=GRS80 +step +proj=unitconvert
>> +xy_out=km" accepts as input degrees and returns kilometers. But I
>> cant understand why in this case for the INV step the parameters string "+proj=pipeline +step +proj=unitconvert +xy_in=km +step
>> +proj=utm +lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_out=deg"
>> is incorrect. I've tested several combinations and none of them works:
>> 
>> "+proj=utm +lon_0=3w +ellps=GRS80" -> wrong results "+proj=pipeline +step +proj=unitconvert +xy_in=km +step +proj=utm
>> +lon_0=3w +ellps=GRS80" -> wrong results
>> "+proj=pipeline +step +proj=unitconvert +xy_in=km +xy_out=m +step
>> +proj=utm +lon_0=3w +ellps=GRS80" -> wrong results (same numeric value
>> as before)
>> "+proj=pipeline +step +proj=unitconvert +xy_in=km +xy_out=deg +step
>> +proj=utm +lon_0=3w +ellps=GRS80" -> proj_create: Error -59
>> (inconsistent unit type between input and output): Pipeline: Bad step
>> definition: proj=unitconvert (inconsistent unit type between input and
>> output)
>> "+proj=pipeline +step +proj=utm +lon_0=3w +ellps=GRS80 +step
>> +proj=unitconvert +xy_in=km +xy_out=deg" -> proj_create: Error -59
>> (inconsistent unit type between input and output): Pipeline: Bad step
>> definition: proj=unitconvert (inconsistent unit type between input and
>> output)
>> "+proj=pipeline +step +proj=unitconvert +xy_out=deg +step +proj=utm
>> +lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_in=km" -> wrong
>> results
>> "+proj=pipeline +step +proj=unitconvert +xy_in=km +step +proj=utm
>> +lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_out=deg" -> wrong
>> results
>> 
>> I can't understand the way as unitconvert works, neither reading https://proj.org/operations/conversions/unitconvert.html
>> 
>> For only one conversion (km to radians or meters to degrees) the problem is only again with the INV step
>> 
>> Thanks
>> 
>> 
>> 
>> 
>> 
>>> 
>>> /Kristian
>>> 
>>>> -----Original Message-----
>>>> From: PROJ <proj-bounces at lists.osgeo.org> On Behalf Of José Luis
>>>> García Pallero
>>>> Sent: 19. maj 2020 10:59
>>>> To: proj at lists.osgeo.org
>>>> Subject: Re: [PROJ] About unit conversion
>>>> 
>>>> I've written a small program in order to illustrate my last mail.
>>>> Attached (and pasted at the bottom of the message) I send the code.
>>>> The results are
>>>> 
>>>> Original data -> lon: -6.00000, lat: 43.00000 (degrees) -> lon:
>>>> -0.1047197551, lat: 0.7504915784 (radians)
>>>> 
>>>> rad to m  -> X= 255466.981, Y=4765182.933 (+proj=utm +lon_0=3w
>>>> +ellps=GRS80)
>>>> rad to km -> X=    255.467, Y=   4765.183 (+proj=pipeline +step
>>>> +proj=utm +lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_out=km)
>>>> deg to m  -> X= 255466.981, Y=4765182.933 (+proj=pipeline +step
>>>> +proj=unitconvert +xy_in=deg +step +proj=utm +lon_0=3w +ellps=GRS80)
>>>> deg to km -> X=    255.467, Y=   4765.183 (+proj=pipeline +step
>>>> +proj=unitconvert +xy_in=deg +step +proj=utm +lon_0=3w +ellps=GRS80
>>>> +step +proj=unitconvert +xy_out=km)
>>>> 
>>>> m  to rad -> lon=-0.1047197551, lat= 0.7504915784 (+proj=utm
>>>> +lon_0=3w
>>>> +ellps=GRS80)
>>>> km to rad -> lon=-0.0001306633, lat= 0.0000007501 (+proj=pipeline
>>>> +step +proj=unitconvert +xy_in=km +step +proj=utm +lon_0=3w
>>>> +ellps=GRS80)
>>>> m  to deg -> lon=-0.1300126568, lat= 0.0130928532 (+proj=pipeline
>>>> +step +proj=utm +lon_0=3w +ellps=GRS80 +step +proj=unitconvert
>>>> +xy_out=deg)
>>>> km to deg -> lon=-0.0001307025, lat= 0.0000000131 (+proj=pipeline
>>>> +step +proj=unitconvert +xy_in=km +step +proj=utm +lon_0=3w
>>>> +ellps=GRS80 +step +proj=unitconvert +xy_out=deg)
>>>> 
>>>> As you can see, the only right INV conversion is the
>>>> meters_to_radians one. All other combinations produce all different
>>>> results, but all combinations for the FWD step are right. Im using
>>>> PROJ 7.0.1 from the Debian Sid repositories
>>>> 
>>>> ***********************
>>>> 
>>>> #include<stdio.h>
>>>> #include<stdlib.h>
>>>> #include<math.h>
>>>> #include<proj.h>
>>>> #define CONST_PI (3.14159265358979323846264338328) int main() {
>>>>    double lond1=-6.0,latd1=43.0,lond2=lond1,latd2=latd1;
>>>>    double
>>>> lonr1=lond1*CONST_PI/180.0,latr1=latd1*CONST_PI/180.0,lonr2=lonr1,la
>>>> tr2
>>>> =latr1;
>>>>    char param_rad_to_m[]="+proj=utm +lon_0=3w +ellps=GRS80";
>>>>    char param_rad_to_km[]="+proj=pipeline +step +proj=utm +lon_0=3w
>>>> +ellps=GRS80 +step +proj=unitconvert +xy_out=km";
>>>>    char param_deg_to_m[]="+proj=pipeline +step +proj=unitconvert
>>>> +xy_in=deg +step +proj=utm +lon_0=3w +ellps=GRS80";
>>>>    char param_deg_to_km[]="+proj=pipeline +step +proj=unitconvert
>>>> +xy_in=deg +step +proj=utm +lon_0=3w +ellps=GRS80 +step
>>>> +proj=unitconvert +xy_out=km";
>>>>    char param_m_to_rad[]="+proj=utm +lon_0=3w +ellps=GRS80";
>>>>    char param_km_to_rad[]="+proj=pipeline +step +proj=unitconvert
>>>> +xy_in=km +step +proj=utm +lon_0=3w +ellps=GRS80";
>>>>    char param_m_to_deg[]="+proj=pipeline +step +proj=utm +lon_0=3w
>>>> +ellps=GRS80 +step +proj=unitconvert +xy_out=deg";
>>>>    char param_km_to_deg[]="+proj=pipeline +step +proj=unitconvert
>>>> +xy_in=km +step +proj=utm +lon_0=3w +ellps=GRS80 +step
>>>> +proj=unitconvert +xy_out=deg";
>>>>    PJ_CONTEXT *C=proj_context_create();
>>>>    PJ *proj=NULL;
>>>>    size_t ld=sizeof(double);
>>>> 
>>>>    //Display original data
>>>>    printf("Original data -> lon: %.5lf, lat: %.5lf (degrees) -> lon:
>>>> %.10lf, lat: %.10lf (radians)\n\n",
>>>>           lond1,latd1,lonr1,latr1);
>>>>    //FWD, radiands to meters
>>>>    proj = proj_create(C,param_rad_to_m);
>>>> 
>>>> proj_trans_generic(proj,PJ_FWD,&lonr1,ld,1,&latr1,ld,1,NULL,0,0,NULL,0,0);
>>>>    printf("rad to m  -> X=%11.3lf, Y=%11.3lf
>>>> (%s)\n",lonr1,latr1,param_rad_to_m);
>>>>    proj_destroy(proj);
>>>>    //FWD, radiands to kilometers
>>>>    proj = proj_create(C,param_rad_to_km);
>>>> 
>>>> proj_trans_generic(proj,PJ_FWD,&lonr2,ld,1,&latr2,ld,1,NULL,0,0,NULL,0,0);
>>>>    printf("rad to km -> X=%11.3lf, Y=%11.3lf
>>>> (%s)\n",lonr2,latr2,param_rad_to_km);
>>>>    proj_destroy(proj);
>>>>    //FWD, degrees to meters
>>>>    proj = proj_create(C,param_deg_to_m);
>>>> 
>>>> proj_trans_generic(proj,PJ_FWD,&lond1,ld,1,&latd1,ld,1,NULL,0,0,NULL,0,0);
>>>>    printf("deg to m  -> X=%11.3lf, Y=%11.3lf
>>>> (%s)\n",lond1,latd1,param_deg_to_m);
>>>>    proj_destroy(proj);
>>>>    //FWD, degrees to kilometers
>>>>    proj = proj_create(C,param_deg_to_km);
>>>> 
>>>> proj_trans_generic(proj,PJ_FWD,&lond2,ld,1,&latd2,ld,1,NULL,0,0,NULL,0,0);
>>>>    printf("deg to km -> X=%11.3lf, Y=%11.3lf
>>>> (%s)\n\n",lond2,latd2,param_deg_to_km);
>>>>    proj_destroy(proj);
>>>>    //INV, meters to radians
>>>>    proj = proj_create(C,param_m_to_rad);
>>>>    proj_trans_generic(proj,PJ_INV,&lonr1,ld,1,&latr1,ld,1,NULL,0,0,NULL,0,0);
>>>>    printf("m  to rad -> lon=%13.10lf, lat=%13.10lf
>>>> (%s)\n",lonr1,latr1,param_m_to_rad);
>>>>    proj_destroy(proj);
>>>>    //INV, kilometers to radians
>>>>    proj = proj_create(C,param_km_to_rad);
>>>>    proj_trans_generic(proj,PJ_INV,&lonr2,ld,1,&latr2,ld,1,NULL,0,0,NULL,0,0);
>>>>    printf("km to rad -> lon=%13.10lf, lat=%13.10lf
>>>> (%s)\n",lonr2,latr2,param_km_to_rad);
>>>>    proj_destroy(proj);
>>>>    //INV, meters to degrees
>>>>    proj = proj_create(C,param_m_to_deg);
>>>> 
>>>> proj_trans_generic(proj,PJ_INV,&lond1,ld,1,&latd1,ld,1,NULL,0,0,NULL,0,0);
>>>>    printf("m  to deg -> lon=%13.10lf, lat=%13.10lf
>>>> (%s)\n",lond1,latd1,param_m_to_deg);
>>>>    proj_destroy(proj);
>>>>    //INV, kilometers to degrees
>>>>    proj = proj_create(C,param_km_to_deg);
>>>> 
>>>> proj_trans_generic(proj,PJ_INV,&lond2,ld,1,&latd2,ld,1,NULL,0,0,NULL,0,0);
>>>>    printf("km to deg -> lon=%13.10lf, lat=%13.10lf
>>>> (%s)\n",lond2,latd2,param_km_to_deg);
>>>>    proj_destroy(proj);
>>>>    proj_context_destroy(C);
>>>>    return 0;
>>>> }
>>>> 
>>>> El lun., 18 may. 2020 a las 23:03, José Luis García Pallero
>>>> (<jgpallero at gmail.com>) escribió:
>>>>> 
>>>>> Hello:
>>>>> 
>>>>> I'm trying to do dome projections (forward and inverse) using the
>>>>> function proj_trans_generic() and parameter string in PROJ format
>>>>> (+
>>>>> style) and I'm a bit confused about unit conversions. My reference
>>>>> for the syntax is
>>>>> https://proj.org/operations/conversions/unitconvert.html
>>>>> 
>>>>> For the forward problem I write
>>>>> 
>>>>> C = proj_context_create();
>>>>> projection = proj_create(C,param);
>>>>> 
>>>> proj_trans_generic(projection,PJ_FWD,lon,sizeof(double),nElem,lat,si
>>>> zeof(d
>>>> ouble),nElem,NULL,0,0,NULL,0,0);
>>>>> 
>>>>> I've used the param string
>>>>> 
>>>>> '+proj=pipeline +step +proj=unitconvert +xy_in=deg +step +proj=utm
>>>>> +lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_out=km'
>>>>> 
>>>>> which means that the input coordinates are in degrees and the
>>>>> output in kilometers. All works right. The results are the same if
>>>>> I pass the input coordinates in radians and I use the param string
>>>>> 
>>>>> '+proj=pipeline +step +proj=utm +lon_0=3w +ellps=GRS80 +step
>>>>> +proj=unitconvert +xy_out=km'
>>>>> 
>>>>> The problem comes when I try to do the inverse step. The procedure
>>>>> is the
>>>> same:
>>>>> 
>>>>> C = proj_context_create();
>>>>> projection = proj_create(C,param);
>>>>> 
>>>> proj_trans_generic(projection,PJ_INV,x,sizeof(double),nElem,y,sizeof
>>>> (doubl
>>>> e),nElem,NULL,0,0,NULL,0,0);
>>>>> 
>>>>> In the input xoordinates are in meters and I use the param string
>>>>> 
>>>>> '+proj=utm +lon_0=3w +ellps=GRS80'
>>>>> 
>>>>> The resulting longtude and latitude are correct and the units are
>>>>> radians. But if I use the param string
>>>>> 
>>>>> '+proj=pipeline +step +proj=utm +lon_0=3w +ellps=GRS80 +step
>>>>> +proj=unitconvert +xy_out=deg'
>>>>> 
>>>>> The output is totally wrong. I expect degrees, but the values have
>>>>> no sense. Also, if I use the input X and Y in kilometers ans the
>>>>> param string is
>>>>> 
>>>>> '+proj=pipeline +step +proj=unitconvert +xy_in=km +step +proj=utm
>>>>> +lon_0=3w +ellps=GRS80'
>>>>> 
>>>>> the result is wrong again.
>>>>> 
>>>>> I suppose I'm doing something wrong with unit conversion, but I
>>>>> can not
>>>> find it
>>>>> 
>>>>> Can someone help me?
>>>>> 
>>>>> Thanks
>>>>> 
>>>>> --
>>>>> *****************************************
>>>>> José Luis García Pallero
>>>>> jgpallero at gmail.com
>>>>> (o<
>>>>> / / \
>>>>> V_/_
>>>>> Use Debian GNU/Linux and enjoy!
>>>>> *****************************************
>>>> 
>>>> 
>>>> 
>>>> --
>>>> *****************************************
>>>> José Luis García Pallero
>>>> jgpallero at gmail.com
>>>> (o<
>>>> / / \
>>>> V_/_
>>>> Use Debian GNU/Linux and enjoy!
>>>> *****************************************
>> 
>> 
>> 
>> --
>> *****************************************
>> José Luis García Pallero
>> jgpallero at gmail.com
>> (o<
>> / / \
>> V_/_
>> Use Debian GNU/Linux and enjoy!
>> *****************************************
>> _______________________________________________
>> PROJ mailing list
>> PROJ at lists.osgeo.org
>> https://lists.osgeo.org/mailman/listinfo/proj
> 
> 
> 
> -- 
> *****************************************
> José Luis García Pallero
> jgpallero at gmail.com <mailto:jgpallero at gmail.com>
> (o<
> / / \
> V_/_
> Use Debian GNU/Linux and enjoy!
> *****************************************
> _______________________________________________
> PROJ mailing list
> PROJ at lists.osgeo.org <mailto:PROJ at lists.osgeo.org>
> https://lists.osgeo.org/mailman/listinfo/proj <https://lists.osgeo.org/mailman/listinfo/proj>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20200520/1ea17929/attachment-0001.html>

From jgpallero at gmail.com  Wed May 20 15:31:53 2020
From: jgpallero at gmail.com (=?UTF-8?Q?Jos=C3=A9_Luis_Garc=C3=ADa_Pallero?=)
Date: Thu, 21 May 2020 00:31:53 +0200
Subject: [PROJ] About unit conversion
In-Reply-To: <AC3C9C92-120D-4BC3-982B-5F815B019519@gmail.com>
References: <CAFemY3b0LABXmSSTk2r6YnsRsuC9G+OEZ=smrw8A0hRpc3uj_w@mail.gmail.com>
 <CAFemY3Z5RS+GikzLC0kYQmD0v2pDFY82i5DJe1s+d3jDFkEXDw@mail.gmail.com>
 <8100b13c03ef47f1ac26db48ce6f62fc@sdfe.dk>
 <CAFemY3ZuFqybZ6drR6UjZ=geVefRZ15GqdtNX3XOHHZwbVWSbg@mail.gmail.com>
 <AM6P192MB0470CD2E05579C78917F7B4CEFB60@AM6P192MB0470.EURP192.PROD.OUTLOOK.COM>
 <CAFemY3ZKUvDpgZZjrY4mFX+aeOTUR-wNsmVHsjJChk4=F3aXFQ@mail.gmail.com>
 <AC3C9C92-120D-4BC3-982B-5F815B019519@gmail.com>
Message-ID: <CAFemY3aKXFW279Xnz-DoFbd4U9nFgM8Qpjr1EXTn=img934Mdw@mail.gmail.com>

El mié., 20 may. 2020 a las 20:28, Kristian Evers
(<kristianevers at gmail.com>) escribió:
>
> I’ve look at all the pipeline definitions in the attached code. Below are my comments for each of them.
> I agree with Jochem, you seem to be passing linear coordinates to a projection that expects angular
> coordinates. Looking back, I see that my comments about the unitconvert steps were not the cause of
> your problems. Had you been using different units it could have been the case - it is always better to
> be explicit here.

Thank you for your answer. I've applied your suggestions and I've
obtained correct results. But, excuse me, I can't understand how the
pipeline and unitconvert works. I've read several times
https://proj.org/operations/conversions/unitconvert.html and analysed
the parameters strings you suggested and I can't figure out the
structure. Yes, I think I understand that the same parameters string
has to be used for both, the forward and the inverse steps, but I
don't know how actually works

For example, for the FWD degrees to km, and then INV km to degrees the string

"+proj=pipeline +step +proj=unitconvert +xy_in=deg +xy_out=rad +step
+proj=utm +lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_in=m
+xy_out=km"

does the job correctly. Buy why? I understand that the first
+xy_in=deg refers to the input coordinates in the FWD step (degrees)
and the second +xy_out=km refers to the output coordinates also for
the FWD step (km). This works. But how PROJ knows the units for the
INV step? The first +xy_out=rad says that output are in radians, and
output angular values means INV step and after my INV step I can see
degrees on my screen, not radians. Also, the second +xy_in=m says that
input are meters, and input linear values means also INV step, but in
my INV step I pass km to the function
proj_trans_generic(proj,PJ_INV...)

Thanks

> "+proj=utm +lon_0=3w +ellps=GRS80”
>
> No problems here in either directions.
>
> "+proj=pipeline +step +proj=utm +lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_out=km
>
> No problems here in either directions, but could benefit from a added +xy_in=m in the unitconvert step.
>
> "+proj=pipeline +step +proj=unitconvert +xy_in=deg +step +proj=utm +lon_0=3w +ellps=GRS80”
>
> Same as above, clarify uniconvert step be adding +xy_out=rad
>
> "+proj=pipeline +step +proj=unitconvert +xy_in=deg +step +proj=utm +lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_out=km”
>
> Clarify both unitconvert steps by adding xy_out=rad to the first and +xy_in=m to the second
>
> "+proj=utm +lon_0=3w +ellps=GRS80”
>
> No problems here
>
> "+proj=pipeline +step +proj=unitconvert +xy_in=km +step +proj=utm +lon_0=3w +ellps=GRS80”
>
> Again, clarify unitconvert step by adding xy_out=m
>
> "+proj=pipeline +step +proj=utm +lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_out=deg”
>
> This is nonsense, projected coordinates from UTM can’t be converted to degrees.
> Probably missing a +inv in the utm step. If that is the case, clarify unitconvert step with +xy_in=rad
>
> "+proj=pipeline +step +proj=unitconvert +xy_in=km +step +proj=utm +lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_out=deg”
>
> Also nonsense, passing km to the UTM projection is not possible, UTM want’s radians as input. Probably again missing a +inv
> in the utm step. Clarify unitconvert steps by stating both input and output units.
>
>
> /Kristian
>
>
> On 20 May 2020, at 19:30, José Luis García Pallero <jgpallero at gmail.com> wrote:
>
> El mié., 20 may. 2020 a las 19:24, Lesparre, Jochem
> (<Jochem.Lesparre at kadaster.nl>) escribió:
>
>
> I just had a quick look, but to me it looks like you are trying to convert between angles and distances?
>
> +proj=utm gives angular results that can be converted to deg, rad or maybe gon, but NOT to m, km of ft! This is such a fundamental part of how PROJ works, that it is probably not explained in the documentation.
>
> If I mis understood, sorry for the confusion.
>
>
> I'm trying to perform first the forward step in the projection, i.e.,
> from geodetic (angular) coordinates to projected (linear) ones. This
> step works without problems whatever the unit combinations I use
> (radians to meters, radians to kilometers, degrees to meters or
> degrees to kilometers). The problem is with the inverse step , i.e.,
> from projected (linear) coordinates to geodetic (angular) ones. I want
> to use the output coordinates of the forward step as input for the
> inverse step. The only combination it works is from meters to radians.
> Whatever other combination fails. Attached to this message
> (https://lists.osgeo.org/pipermail/proj/2020-May/009648.html) I sent a
> C source code with an example showing what I want to do
>
> Cheers
>
> Kind regards, Jochem
>
>
> -----Original Message-----
> From: PROJ <proj-bounces at lists.osgeo.org> On Behalf Of José Luis García Pallero
> Sent: woensdag 20 mei 2020 18:34
> To: Kristian Evers <kreve at sdfe.dk>
> Cc: proj at lists.osgeo.org
> Subject: Re: [PROJ] About unit conversion
>
> El mié., 20 may. 2020 a las 11:00, Kristian Evers (<kreve at sdfe.dk>) escribió:
>
>
> I see that you don't specify the input units in your unitconvert
> steps. Try adding a
> +xy_in parameter to your unitconvert steps and see if that fixes the problem.
> When you only specify of of either +xy_in or +xy_out the operation
> becomes somewhat uni-directional which is why not all of your pipelines works in reverse.
>
> See https://proj.org/operations/conversions/unitconvert.html for more.
>
>
> Thank you for your answer, Kristian, but I can't understand why my program fails. Clearly, for FWD and input in radians and output in meters all works without any unitconversion. Also for INV step with meters as input and radians as output, i.e., using only "+proj=utm
> +lon_0=3w +ellps=GRS80" as parameters string is enough. Also for any
> combination in the FWD step all works.
>
> For example using "+proj=pipeline +step +proj=unitconvert +xy_in=deg
> +step +proj=utm +lon_0=3w +ellps=GRS80 +step +proj=unitconvert
> +xy_out=km" accepts as input degrees and returns kilometers. But I
> cant understand why in this case for the INV step the parameters string "+proj=pipeline +step +proj=unitconvert +xy_in=km +step
> +proj=utm +lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_out=deg"
> is incorrect. I've tested several combinations and none of them works:
>
> "+proj=utm +lon_0=3w +ellps=GRS80" -> wrong results "+proj=pipeline +step +proj=unitconvert +xy_in=km +step +proj=utm
> +lon_0=3w +ellps=GRS80" -> wrong results
> "+proj=pipeline +step +proj=unitconvert +xy_in=km +xy_out=m +step
> +proj=utm +lon_0=3w +ellps=GRS80" -> wrong results (same numeric value
> as before)
> "+proj=pipeline +step +proj=unitconvert +xy_in=km +xy_out=deg +step
> +proj=utm +lon_0=3w +ellps=GRS80" -> proj_create: Error -59
> (inconsistent unit type between input and output): Pipeline: Bad step
> definition: proj=unitconvert (inconsistent unit type between input and
> output)
> "+proj=pipeline +step +proj=utm +lon_0=3w +ellps=GRS80 +step
> +proj=unitconvert +xy_in=km +xy_out=deg" -> proj_create: Error -59
> (inconsistent unit type between input and output): Pipeline: Bad step
> definition: proj=unitconvert (inconsistent unit type between input and
> output)
> "+proj=pipeline +step +proj=unitconvert +xy_out=deg +step +proj=utm
> +lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_in=km" -> wrong
> results
> "+proj=pipeline +step +proj=unitconvert +xy_in=km +step +proj=utm
> +lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_out=deg" -> wrong
> results
>
> I can't understand the way as unitconvert works, neither reading https://proj.org/operations/conversions/unitconvert.html
>
> For only one conversion (km to radians or meters to degrees) the problem is only again with the INV step
>
> Thanks
>
>
>
>
>
>
> /Kristian
>
> -----Original Message-----
> From: PROJ <proj-bounces at lists.osgeo.org> On Behalf Of José Luis
> García Pallero
> Sent: 19. maj 2020 10:59
> To: proj at lists.osgeo.org
> Subject: Re: [PROJ] About unit conversion
>
> I've written a small program in order to illustrate my last mail.
> Attached (and pasted at the bottom of the message) I send the code.
> The results are
>
> Original data -> lon: -6.00000, lat: 43.00000 (degrees) -> lon:
> -0.1047197551, lat: 0.7504915784 (radians)
>
> rad to m  -> X= 255466.981, Y=4765182.933 (+proj=utm +lon_0=3w
> +ellps=GRS80)
> rad to km -> X=    255.467, Y=   4765.183 (+proj=pipeline +step
> +proj=utm +lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_out=km)
> deg to m  -> X= 255466.981, Y=4765182.933 (+proj=pipeline +step
> +proj=unitconvert +xy_in=deg +step +proj=utm +lon_0=3w +ellps=GRS80)
> deg to km -> X=    255.467, Y=   4765.183 (+proj=pipeline +step
> +proj=unitconvert +xy_in=deg +step +proj=utm +lon_0=3w +ellps=GRS80
> +step +proj=unitconvert +xy_out=km)
>
> m  to rad -> lon=-0.1047197551, lat= 0.7504915784 (+proj=utm
> +lon_0=3w
> +ellps=GRS80)
> km to rad -> lon=-0.0001306633, lat= 0.0000007501 (+proj=pipeline
> +step +proj=unitconvert +xy_in=km +step +proj=utm +lon_0=3w
> +ellps=GRS80)
> m  to deg -> lon=-0.1300126568, lat= 0.0130928532 (+proj=pipeline
> +step +proj=utm +lon_0=3w +ellps=GRS80 +step +proj=unitconvert
> +xy_out=deg)
> km to deg -> lon=-0.0001307025, lat= 0.0000000131 (+proj=pipeline
> +step +proj=unitconvert +xy_in=km +step +proj=utm +lon_0=3w
> +ellps=GRS80 +step +proj=unitconvert +xy_out=deg)
>
> As you can see, the only right INV conversion is the
> meters_to_radians one. All other combinations produce all different
> results, but all combinations for the FWD step are right. Im using
> PROJ 7.0.1 from the Debian Sid repositories
>
> ***********************
>
> #include<stdio.h>
> #include<stdlib.h>
> #include<math.h>
> #include<proj.h>
> #define CONST_PI (3.14159265358979323846264338328) int main() {
>    double lond1=-6.0,latd1=43.0,lond2=lond1,latd2=latd1;
>    double
> lonr1=lond1*CONST_PI/180.0,latr1=latd1*CONST_PI/180.0,lonr2=lonr1,la
> tr2
> =latr1;
>    char param_rad_to_m[]="+proj=utm +lon_0=3w +ellps=GRS80";
>    char param_rad_to_km[]="+proj=pipeline +step +proj=utm +lon_0=3w
> +ellps=GRS80 +step +proj=unitconvert +xy_out=km";
>    char param_deg_to_m[]="+proj=pipeline +step +proj=unitconvert
> +xy_in=deg +step +proj=utm +lon_0=3w +ellps=GRS80";
>    char param_deg_to_km[]="+proj=pipeline +step +proj=unitconvert
> +xy_in=deg +step +proj=utm +lon_0=3w +ellps=GRS80 +step
> +proj=unitconvert +xy_out=km";
>    char param_m_to_rad[]="+proj=utm +lon_0=3w +ellps=GRS80";
>    char param_km_to_rad[]="+proj=pipeline +step +proj=unitconvert
> +xy_in=km +step +proj=utm +lon_0=3w +ellps=GRS80";
>    char param_m_to_deg[]="+proj=pipeline +step +proj=utm +lon_0=3w
> +ellps=GRS80 +step +proj=unitconvert +xy_out=deg";
>    char param_km_to_deg[]="+proj=pipeline +step +proj=unitconvert
> +xy_in=km +step +proj=utm +lon_0=3w +ellps=GRS80 +step
> +proj=unitconvert +xy_out=deg";
>    PJ_CONTEXT *C=proj_context_create();
>    PJ *proj=NULL;
>    size_t ld=sizeof(double);
>
>    //Display original data
>    printf("Original data -> lon: %.5lf, lat: %.5lf (degrees) -> lon:
> %.10lf, lat: %.10lf (radians)\n\n",
>           lond1,latd1,lonr1,latr1);
>    //FWD, radiands to meters
>    proj = proj_create(C,param_rad_to_m);
>
> proj_trans_generic(proj,PJ_FWD,&lonr1,ld,1,&latr1,ld,1,NULL,0,0,NULL,0,0);
>    printf("rad to m  -> X=%11.3lf, Y=%11.3lf
> (%s)\n",lonr1,latr1,param_rad_to_m);
>    proj_destroy(proj);
>    //FWD, radiands to kilometers
>    proj = proj_create(C,param_rad_to_km);
>
> proj_trans_generic(proj,PJ_FWD,&lonr2,ld,1,&latr2,ld,1,NULL,0,0,NULL,0,0);
>    printf("rad to km -> X=%11.3lf, Y=%11.3lf
> (%s)\n",lonr2,latr2,param_rad_to_km);
>    proj_destroy(proj);
>    //FWD, degrees to meters
>    proj = proj_create(C,param_deg_to_m);
>
> proj_trans_generic(proj,PJ_FWD,&lond1,ld,1,&latd1,ld,1,NULL,0,0,NULL,0,0);
>    printf("deg to m  -> X=%11.3lf, Y=%11.3lf
> (%s)\n",lond1,latd1,param_deg_to_m);
>    proj_destroy(proj);
>    //FWD, degrees to kilometers
>    proj = proj_create(C,param_deg_to_km);
>
> proj_trans_generic(proj,PJ_FWD,&lond2,ld,1,&latd2,ld,1,NULL,0,0,NULL,0,0);
>    printf("deg to km -> X=%11.3lf, Y=%11.3lf
> (%s)\n\n",lond2,latd2,param_deg_to_km);
>    proj_destroy(proj);
>    //INV, meters to radians
>    proj = proj_create(C,param_m_to_rad);
>    proj_trans_generic(proj,PJ_INV,&lonr1,ld,1,&latr1,ld,1,NULL,0,0,NULL,0,0);
>    printf("m  to rad -> lon=%13.10lf, lat=%13.10lf
> (%s)\n",lonr1,latr1,param_m_to_rad);
>    proj_destroy(proj);
>    //INV, kilometers to radians
>    proj = proj_create(C,param_km_to_rad);
>    proj_trans_generic(proj,PJ_INV,&lonr2,ld,1,&latr2,ld,1,NULL,0,0,NULL,0,0);
>    printf("km to rad -> lon=%13.10lf, lat=%13.10lf
> (%s)\n",lonr2,latr2,param_km_to_rad);
>    proj_destroy(proj);
>    //INV, meters to degrees
>    proj = proj_create(C,param_m_to_deg);
>
> proj_trans_generic(proj,PJ_INV,&lond1,ld,1,&latd1,ld,1,NULL,0,0,NULL,0,0);
>    printf("m  to deg -> lon=%13.10lf, lat=%13.10lf
> (%s)\n",lond1,latd1,param_m_to_deg);
>    proj_destroy(proj);
>    //INV, kilometers to degrees
>    proj = proj_create(C,param_km_to_deg);
>
> proj_trans_generic(proj,PJ_INV,&lond2,ld,1,&latd2,ld,1,NULL,0,0,NULL,0,0);
>    printf("km to deg -> lon=%13.10lf, lat=%13.10lf
> (%s)\n",lond2,latd2,param_km_to_deg);
>    proj_destroy(proj);
>    proj_context_destroy(C);
>    return 0;
> }
>
> El lun., 18 may. 2020 a las 23:03, José Luis García Pallero
> (<jgpallero at gmail.com>) escribió:
>
>
> Hello:
>
> I'm trying to do dome projections (forward and inverse) using the
> function proj_trans_generic() and parameter string in PROJ format
> (+
> style) and I'm a bit confused about unit conversions. My reference
> for the syntax is
> https://proj.org/operations/conversions/unitconvert.html
>
> For the forward problem I write
>
> C = proj_context_create();
> projection = proj_create(C,param);
>
> proj_trans_generic(projection,PJ_FWD,lon,sizeof(double),nElem,lat,si
> zeof(d
> ouble),nElem,NULL,0,0,NULL,0,0);
>
>
> I've used the param string
>
> '+proj=pipeline +step +proj=unitconvert +xy_in=deg +step +proj=utm
> +lon_0=3w +ellps=GRS80 +step +proj=unitconvert +xy_out=km'
>
> which means that the input coordinates are in degrees and the
> output in kilometers. All works right. The results are the same if
> I pass the input coordinates in radians and I use the param string
>
> '+proj=pipeline +step +proj=utm +lon_0=3w +ellps=GRS80 +step
> +proj=unitconvert +xy_out=km'
>
> The problem comes when I try to do the inverse step. The procedure
> is the
>
> same:
>
>
> C = proj_context_create();
> projection = proj_create(C,param);
>
> proj_trans_generic(projection,PJ_INV,x,sizeof(double),nElem,y,sizeof
> (doubl
> e),nElem,NULL,0,0,NULL,0,0);
>
>
> In the input xoordinates are in meters and I use the param string
>
> '+proj=utm +lon_0=3w +ellps=GRS80'
>
> The resulting longtude and latitude are correct and the units are
> radians. But if I use the param string
>
> '+proj=pipeline +step +proj=utm +lon_0=3w +ellps=GRS80 +step
> +proj=unitconvert +xy_out=deg'
>
> The output is totally wrong. I expect degrees, but the values have
> no sense. Also, if I use the input X and Y in kilometers ans the
> param string is
>
> '+proj=pipeline +step +proj=unitconvert +xy_in=km +step +proj=utm
> +lon_0=3w +ellps=GRS80'
>
> the result is wrong again.
>
> I suppose I'm doing something wrong with unit conversion, but I
> can not
>
> find it
>
>
> Can someone help me?
>
> Thanks
>
> --
> *****************************************
> José Luis García Pallero
> jgpallero at gmail.com
> (o<
> / / \
> V_/_
> Use Debian GNU/Linux and enjoy!
> *****************************************
>
>
>
>
> --
> *****************************************
> José Luis García Pallero
> jgpallero at gmail.com
> (o<
> / / \
> V_/_
> Use Debian GNU/Linux and enjoy!
> *****************************************
>
>
>
>
> --
> *****************************************
> José Luis García Pallero
> jgpallero at gmail.com
> (o<
> / / \
> V_/_
> Use Debian GNU/Linux and enjoy!
> *****************************************
> _______________________________________________
> PROJ mailing list
> PROJ at lists.osgeo.org
> https://lists.osgeo.org/mailman/listinfo/proj
>
>
>
>
> --
> *****************************************
> José Luis García Pallero
> jgpallero at gmail.com
> (o<
> / / \
> V_/_
> Use Debian GNU/Linux and enjoy!
> *****************************************
> _______________________________________________
> PROJ mailing list
> PROJ at lists.osgeo.org
> https://lists.osgeo.org/mailman/listinfo/proj
>
>


--
*****************************************
José Luis García Pallero
jgpallero at gmail.com
(o<
/ / \
V_/_
Use Debian GNU/Linux and enjoy!
*****************************************

From ccrook at linz.govt.nz  Thu May 28 17:33:14 2020
From: ccrook at linz.govt.nz (Chris Crook)
Date: Fri, 29 May 2020 00:33:14 +0000
Subject: [PROJ] Confusion using cct with helmert transformation.
Message-ID: <A87E66F06E86F14B857F2EB047CDF932315F5C31@prdassexch01.ad.linz.govt.nz>

Hi All

I'm just having some trouble understanding what cct is doing.  I'm attempting to do a helmert transformation corresponding to  EPSG coordinate operation 9082.   http://www.epsg-registry.org/report.htm?type=selection&entity=urn:ogc:def:coordinateOperation:EPSG::9082&reportDetail=long&title=&reportDetail=long&title=&reportDetail=long&style=urn:uuid:report-style:default-with-urn&style_name=OGP%20Default%20With%20Urn&title=9082&r=63

The command I am running is

cct -vvv -t 2016.5 -d 9 +proj=helmert +ellps=GRS80 +convention=coordinate_frame +t_epoch=2000.0 +x=0.00480 +y=0.00209 +z=-0.01767 +rx=-0.00016508 +ry=0.000226897 +rz=0.00011984 +s=0.00140901 +dx=0.00079 +dy=-0.00060 +dz=-0.00134 +drx=-0.00001347 +dry=0.00001514 +drz=0.00001973 +ds=-0.00010201 testcct.in

The input file testcct.in just contains one coordinate, 173 -41 0.

It appears to run properly, but gives a significantly wrong answer.

173.017834864  -41.007810362  -0.039779677     2016.5000 (I was expecting  173.00000030  -41.00000025     0.010 2016.5, give or take the rotation convention which I'm not sure I've got the right way around).

The verbose output shows that it is actually doing two transformations.

pj_open_lib(proj.db): call fopen(/home/ccrook/projects_git/proj/build2/data/proj.db) - succeeded
pj_open_lib(proj.ini): call fopen(/home/ccrook/projects_git/proj/data/proj.ini) - succeeded
pj_ellipsoid - final: a=6378137.000 f=1/298.257, errno=0
pj_ellipsoid - final:    ellps=GRS80
Helmert parameters:
x=   0.00480  y=   0.00209  z=  -0.01767
rx= -0.00017  ry=  0.00023  rz=  0.00012
s=   0.00141  exact=0  convention=coordinate_frame
dx=  0.00079  dy= -0.00060  dz= -0.00134
drx=-0.00000  dry= 0.00000  drz= 0.00000
ds= -0.00010  t_epoch=2000.00000
Transformation parameters for observation t_obs=0 (t_epoch=2000):
x: -1.5752
y: 1.20209
z: 2.66233
s: 2.05429e-07
rx: 1.29808e-07
ry: -1.45702e-07
rz: -1.90726e-07
theta: 0
Rotation Matrix:
  |      1  -1.90726e-07   1.45702e-07 |
  |  1.90726e-07       1   1.29808e-07 |
  | -1.45702e-07  -1.29808e-07       1 |
Final: proj=helmert ellps=GRS80 convention=coordinate_frame t_epoch=2000.0 x=0.00480 y=0.00209 z=-0.01767 rx=-0.00016508 ry=0.000226897 rz=0.00011984 s=0.00140901 dx=0.00079 dy=-0.00060 dz=-0.00134 drx=-0.00001347 dry=0.00001514 drz=0.00001973 ds=-0.00010201 argc=25 pargc=18
Transformation parameters for observation t_obs=2016.5 (t_epoch=2000):
x: 0.017835
y: -0.00781
z: -0.03978
s: -2.74155e-10
rx: -1.87785e-09
ry: 2.31114e-09
rz: 2.15929e-09
theta: 0
Rotation Matrix:
  |      1   2.15929e-09  -2.31114e-09 |
  | -2.15929e-09       1  -1.87785e-09 |
  |  2.31114e-09   1.87785e-09       1 |
173.017834864  -41.007810362  -0.039779677     2016.5000

The second one is the one I am expecting from my command line.  But the I don't understand where the first one (x: -1.5752 ...) is coming from, and how to stop cct from doing it.

Can anyone help please?

________________________________

This message contains information, which may be in confidence and may be subject to legal privilege. If you are not the intended recipient, you must not peruse, use, disseminate, distribute or copy this message. If you have received this message in error, please notify us immediately (Phone 0800 665 463 or info at linz.govt.nz) and destroy the original message. LINZ accepts no responsibility for changes to this email, or for any attachments, after its transmission from LINZ. Thank You.

From even.rouault at spatialys.com  Fri May 29 04:53:49 2020
From: even.rouault at spatialys.com (Even Rouault)
Date: Fri, 29 May 2020 13:53:49 +0200
Subject: [PROJ] Confusion using cct with helmert transformation.
In-Reply-To: <A87E66F06E86F14B857F2EB047CDF932315F5C31@prdassexch01.ad.linz.govt.nz>
References: <A87E66F06E86F14B857F2EB047CDF932315F5C31@prdassexch01.ad.linz.govt.nz>
Message-ID: <2433828.c1g5NmiY7Y@even-i700>

Chris,

> I'm just having some trouble understanding what cct is doing.  I'm
> attempting to do a helmert transformation corresponding to  EPSG coordinate
> operation 9082.  
> http://www.epsg-registry.org/report.htm?type=selection&entity=urn:ogc:def:c
> oordinateOperation:EPSG::9082&reportDetail=long&title=&reportDetail=long&tit
> le=&reportDetail=long&style=urn:uuid:report-style:default-with-urn&style_nam
> e=OGP%20Default%20With%20Urn&title=9082&r=63
> 
> The command I am running is
> 
> cct -vvv -t 2016.5 -d 9 +proj=helmert +ellps=GRS80
> +convention=coordinate_frame +t_epoch=2000.0 +x=0.00480 +y=0.00209
> +z=-0.01767 +rx=-0.00016508 +ry=0.000226897 +rz=0.00011984 +s=0.00140901
> +dx=0.00079 +dy=-0.00060 +dz=-0.00134 +drx=-0.00001347 +dry=0.00001514
> +drz=0.00001973 +ds=-0.00010201 testcct.in
> 
> The input file testcct.in just contains one coordinate, 173 -41 0.

+proj=helmert operates in the cartesian/geocentric coordinate space, so you can't directly 
provide / get geographic coordinates into/from it. You need to create a pipeline with a "+step 
+proj=cart +ellps=GRS80" before +proj=helmert and a "+step +inv +proj=cart +ellps=GRS80" 
after

Even

-- 
Spatialys - Geospatial professional services
http://www.spatialys.com
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://lists.osgeo.org/pipermail/proj/attachments/20200529/dc5d343c/attachment.html>

