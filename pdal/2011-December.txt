From hobu.inc at gmail.com  Fri Dec  9 14:34:08 2011
From: hobu.inc at gmail.com (Howard Butler)
Date: Fri Dec  9 18:43:12 2011
Subject: [pdal] Re: Gist notes
In-Reply-To: <021901ccb6a5$b15fdad0$141f9070$@flaxen.com>
References: <021901ccb6a5$b15fdad0$141f9070$@flaxen.com>
Message-ID: <56E2AD0D-D76C-4D93-8EAC-EBE597DD4392@gmail.com>

Putting this discussion on the PDAL list if anyone cares.  We're discussing a proposal to change how Schema work with Stage and PointBuffer.  In short, Stage will no longer have a Schema, and only a PointBuffer will have a Schema.  Stage will advertise dimensions it consumes or produces, and PointBuffer is left to compose them into a Schema however it wishes.

https://gist.github.com/1406139


On Dec 9, 2011, at 1:06 PM, Michael P. Gerlek wrote:

> The gist document on Dimensions makes more sense to me now, thanks...  Here's my comments:
> 
> Line 35:  note sure what "nonunique type/name" means -- or is this referring to the case where you have a "before" and "after" version of a field that gets modified, such that you'd use the guid to distinguish (lines 65-67)?

A ScalingFilter might take a las.X and scale it to scale.X.  Their type/name are both the same, X, and they can be distinguished by both their different GUID and different fully qualified names.  A call to schema.getDimension("X") is going to throw an exception because there's two of them.  They need to call schema.getDimension("las.X") (or schema.getDimension(las_x_guid)) to fetch the one they want.

> 
> Line 41, 42: when you say "to read" do we also mean "to write"?

yes. You cannot use free-standing dimensions to interact with a PointBuffer.  You need to fetch references from the buffer.getSchema() and pass them into getField/setField to operate.

> 
> Line 47-48: not sure I understand this about "casting only happens" if the sizes are different.  What about int32 and float32?

good point.  I'll fix this if the type or size is different.  If the signing is different, however, I'll leave it alone.  Maybe you *wanted* that :)

> 
> Lines 53-55: let's find another word instead of "default"?

Agreed.

> 
> Line 67: yes, good idea
> 
> Line 72: mm, okay, I'll modify my expression parser to support periods (".") in variable names?


And GUID strings. I expect the natural way in nearly every case is to use the fully qualified dimension name, but I can craft artificial situations where you could potentially have two equal fully qualified names. The GUID thing would allow someone to version dimensions for specific PDAL versions.  I plan to use these inside of XMLSchema instances in addition to the fully qualified name in case some driver needs to change its behavior for a specific dimension.

For example, if the PDAL QFIT driver mis-interpreted qfit.X in a specific version, another subsequent version could compare the XMLSchema GUID of that qfit.X to its current one and potentially smooth things over. The GUIDs allow us to precisely say  "I want the X dimension from the drivers.las.Reader stage with guid XXXX" if we wanted to. In *most cases*, however, we only care about schema.getDimension("X").

Howard
From mpg at flaxen.com  Fri Dec  9 14:50:38 2011
From: mpg at flaxen.com (Michael P. Gerlek)
Date: Fri Dec  9 19:00:29 2011
Subject: [pdal] RE: Gist notes
In-Reply-To: <56E2AD0D-D76C-4D93-8EAC-EBE597DD4392@gmail.com>
References: <021901ccb6a5$b15fdad0$141f9070$@flaxen.com>
	<56E2AD0D-D76C-4D93-8EAC-EBE597DD4392@gmail.com>
Message-ID: <022e01ccb6ab$d47e1f80$7d7a5e80$@flaxen.com>

Syntactically, what does a GUID look like to you?

a. 3F2504E0-4F89-11D3-9A0C-0305E82C3301
b. {3F2504E0-4F89-11D3-9A0C-0305E82C3301}
c. urn:uuid:3F2504E0-4F89-11D3-9A0C-0305E82C3301
d. other?

_mpg


-----Original Message-----
From: Howard Butler [mailto:hobu.inc@gmail.com] 
Sent: Friday, December 09, 2011 11:34 AM
To: mpg@flaxen.com
Cc: pdal@lists.osgeo.org
Subject: Re: Gist notes

Putting this discussion on the PDAL list if anyone cares.  We're discussing a proposal to change how Schema work with Stage and PointBuffer.  In short, Stage will no longer have a Schema, and only a PointBuffer will have a Schema.  Stage will advertise dimensions it consumes or produces, and PointBuffer is left to compose them into a Schema however it wishes.

https://gist.github.com/1406139


On Dec 9, 2011, at 1:06 PM, Michael P. Gerlek wrote:

> The gist document on Dimensions makes more sense to me now, thanks...  Here's my comments:
> 
> Line 35:  note sure what "nonunique type/name" means -- or is this referring to the case where you have a "before" and "after" version of a field that gets modified, such that you'd use the guid to distinguish (lines 65-67)?

A ScalingFilter might take a las.X and scale it to scale.X.  Their type/name are both the same, X, and they can be distinguished by both their different GUID and different fully qualified names.  A call to schema.getDimension("X") is going to throw an exception because there's two of them.  They need to call schema.getDimension("las.X") (or schema.getDimension(las_x_guid)) to fetch the one they want.

> 
> Line 41, 42: when you say "to read" do we also mean "to write"?

yes. You cannot use free-standing dimensions to interact with a PointBuffer.  You need to fetch references from the buffer.getSchema() and pass them into getField/setField to operate.

> 
> Line 47-48: not sure I understand this about "casting only happens" if the sizes are different.  What about int32 and float32?

good point.  I'll fix this if the type or size is different.  If the signing is different, however, I'll leave it alone.  Maybe you *wanted* that :)

> 
> Lines 53-55: let's find another word instead of "default"?

Agreed.

> 
> Line 67: yes, good idea
> 
> Line 72: mm, okay, I'll modify my expression parser to support periods (".") in variable names?


And GUID strings. I expect the natural way in nearly every case is to use the fully qualified dimension name, but I can craft artificial situations where you could potentially have two equal fully qualified names. The GUID thing would allow someone to version dimensions for specific PDAL versions.  I plan to use these inside of XMLSchema instances in addition to the fully qualified name in case some driver needs to change its behavior for a specific dimension.

For example, if the PDAL QFIT driver mis-interpreted qfit.X in a specific version, another subsequent version could compare the XMLSchema GUID of that qfit.X to its current one and potentially smooth things over. The GUIDs allow us to precisely say  "I want the X dimension from the drivers.las.Reader stage with guid XXXX" if we wanted to. In *most cases*, however, we only care about schema.getDimension("X").

Howard=

From hobu.inc at gmail.com  Fri Dec  9 14:58:08 2011
From: hobu.inc at gmail.com (Howard Butler)
Date: Fri Dec  9 19:08:26 2011
Subject: [pdal] Re: Gist notes
In-Reply-To: <022e01ccb6ab$d47e1f80$7d7a5e80$@flaxen.com>
References: <021901ccb6a5$b15fdad0$141f9070$@flaxen.com>
	<56E2AD0D-D76C-4D93-8EAC-EBE597DD4392@gmail.com>
	<022e01ccb6ab$d47e1f80$7d7a5e80$@flaxen.com>
Message-ID: <EE50851E-2E51-496C-94BC-10F82E2E6F7D@gmail.com>

Whatever the boost::uuids::string_generator constructor can take in? :)

I don't have a strong preference, and to be honest rather hate GUIDs, but I cannot think of something more universally supported that's better.  If I had to choose, I'd choose a) because that's how Python works with them.

On Dec 9, 2011, at 1:50 PM, Michael P. Gerlek wrote:

> Syntactically, what does a GUID look like to you?
> 
> a. 3F2504E0-4F89-11D3-9A0C-0305E82C3301
> b. {3F2504E0-4F89-11D3-9A0C-0305E82C3301}
> c. urn:uuid:3F2504E0-4F89-11D3-9A0C-0305E82C3301
> d. other?
> 
> _mpg
> 
> 
> -----Original Message-----
> From: Howard Butler [mailto:hobu.inc@gmail.com] 
> Sent: Friday, December 09, 2011 11:34 AM
> To: mpg@flaxen.com
> Cc: pdal@lists.osgeo.org
> Subject: Re: Gist notes
> 
> Putting this discussion on the PDAL list if anyone cares.  We're discussing a proposal to change how Schema work with Stage and PointBuffer.  In short, Stage will no longer have a Schema, and only a PointBuffer will have a Schema.  Stage will advertise dimensions it consumes or produces, and PointBuffer is left to compose them into a Schema however it wishes.
> 
> https://gist.github.com/1406139
> 
> 
> On Dec 9, 2011, at 1:06 PM, Michael P. Gerlek wrote:
> 
>> The gist document on Dimensions makes more sense to me now, thanks...  Here's my comments:
>> 
>> Line 35:  note sure what "nonunique type/name" means -- or is this referring to the case where you have a "before" and "after" version of a field that gets modified, such that you'd use the guid to distinguish (lines 65-67)?
> 
> A ScalingFilter might take a las.X and scale it to scale.X.  Their type/name are both the same, X, and they can be distinguished by both their different GUID and different fully qualified names.  A call to schema.getDimension("X") is going to throw an exception because there's two of them.  They need to call schema.getDimension("las.X") (or schema.getDimension(las_x_guid)) to fetch the one they want.
> 
>> 
>> Line 41, 42: when you say "to read" do we also mean "to write"?
> 
> yes. You cannot use free-standing dimensions to interact with a PointBuffer.  You need to fetch references from the buffer.getSchema() and pass them into getField/setField to operate.
> 
>> 
>> Line 47-48: not sure I understand this about "casting only happens" if the sizes are different.  What about int32 and float32?
> 
> good point.  I'll fix this if the type or size is different.  If the signing is different, however, I'll leave it alone.  Maybe you *wanted* that :)
> 
>> 
>> Lines 53-55: let's find another word instead of "default"?
> 
> Agreed.
> 
>> 
>> Line 67: yes, good idea
>> 
>> Line 72: mm, okay, I'll modify my expression parser to support periods (".") in variable names?
> 
> 
> And GUID strings. I expect the natural way in nearly every case is to use the fully qualified dimension name, but I can craft artificial situations where you could potentially have two equal fully qualified names. The GUID thing would allow someone to version dimensions for specific PDAL versions.  I plan to use these inside of XMLSchema instances in addition to the fully qualified name in case some driver needs to change its behavior for a specific dimension.
> 
> For example, if the PDAL QFIT driver mis-interpreted qfit.X in a specific version, another subsequent version could compare the XMLSchema GUID of that qfit.X to its current one and potentially smooth things over. The GUIDs allow us to precisely say  "I want the X dimension from the drivers.las.Reader stage with guid XXXX" if we wanted to. In *most cases*, however, we only care about schema.getDimension("X").
> 
> Howard=
> 

From mateusz at loskot.net  Fri Dec  9 15:28:34 2011
From: mateusz at loskot.net (=?UTF-8?Q?Mateusz_=C5=81oskot?=)
Date: Fri Dec  9 19:40:28 2011
Subject: [pdal] RE: Gist notes
In-Reply-To: <022e01ccb6ab$d47e1f80$7d7a5e80$@flaxen.com>
References: <021901ccb6a5$b15fdad0$141f9070$@flaxen.com>
	<56E2AD0D-D76C-4D93-8EAC-EBE597DD4392@gmail.com>
	<022e01ccb6ab$d47e1f80$7d7a5e80$@flaxen.com>
Message-ID: <CABUeae9qckhU=E+d8H=dOmyO_F=abt8VDdouv2wFbDMpm4aaXQ@mail.gmail.com>

On 9 December 2011 19:50, Michael P. Gerlek <mpg@flaxen.com> wrote:
> Syntactically, what does a GUID look like to you?
>
> a. 3F2504E0-4F89-11D3-9A0C-0305E82C3301
> b. {3F2504E0-4F89-11D3-9A0C-0305E82C3301}
> c. urn:uuid:3F2504E0-4F89-11D3-9A0C-0305E82C3301
> d. other?

GUID is 128-bit integer number.
The a-c are just possible textual representations of GUID.

Best regards,
-- 
Mateusz Loskot, http://mateusz.loskot.net
Charter Member of OSGeo, http://osgeo.org
Member of ACCU, http://accu.org
From mpg at flaxen.com  Fri Dec  9 15:34:24 2011
From: mpg at flaxen.com (Michael P. Gerlek)
Date: Fri Dec  9 19:46:34 2011
Subject: [pdal] RE: Gist notes
In-Reply-To: <CABUeae9qckhU=E+d8H=dOmyO_F=abt8VDdouv2wFbDMpm4aaXQ@mail.gmail.com>
References: <021901ccb6a5$b15fdad0$141f9070$@flaxen.com>	<56E2AD0D-D76C-4D93-8EAC-EBE597DD4392@gmail.com>	<022e01ccb6ab$d47e1f80$7d7a5e80$@flaxen.com>
	<CABUeae9qckhU=E+d8H=dOmyO_F=abt8VDdouv2wFbDMpm4aaXQ@mail.gmail.com>
Message-ID: <023301ccb6b1$f1e69970$d5b3cc50$@flaxen.com>

Right, but I've got an little language I've written for writing "pdal filter expressions" and I'm wondering what's the best representation in that language to use for a GUID.

Syntactically and lexically, a guid string of form (a) looks like a mashup of a hex constant, a variable name identifier, and an arithmetic expression (subtraction).  So I'm thinking of preceeding it with a "$" or putting it in {}'s or some such.
 
_mpg


-----Original Message-----
From: Mateusz ?oskot [mailto:mateusz@loskot.net] 
Sent: Friday, December 09, 2011 12:29 PM
To: mpg@flaxen.com
Cc: Howard Butler; pdal@lists.osgeo.org
Subject: Re: [pdal] RE: Gist notes

On 9 December 2011 19:50, Michael P. Gerlek <mpg@flaxen.com> wrote:
> Syntactically, what does a GUID look like to you?
>
> a. 3F2504E0-4F89-11D3-9A0C-0305E82C3301
> b. {3F2504E0-4F89-11D3-9A0C-0305E82C3301}
> c. urn:uuid:3F2504E0-4F89-11D3-9A0C-0305E82C3301
> d. other?

GUID is 128-bit integer number.
The a-c are just possible textual representations of GUID.

Best regards,
--
Mateusz Loskot, http://mateusz.loskot.net Charter Member of OSGeo, http://osgeo.org Member of ACCU, http://accu.org

From mateusz at loskot.net  Fri Dec  9 15:44:16 2011
From: mateusz at loskot.net (=?UTF-8?Q?Mateusz_=C5=81oskot?=)
Date: Fri Dec  9 19:56:59 2011
Subject: [pdal] RE: Gist notes
In-Reply-To: <023301ccb6b1$f1e69970$d5b3cc50$@flaxen.com>
References: <021901ccb6a5$b15fdad0$141f9070$@flaxen.com>
	<56E2AD0D-D76C-4D93-8EAC-EBE597DD4392@gmail.com>
	<022e01ccb6ab$d47e1f80$7d7a5e80$@flaxen.com>
	<CABUeae9qckhU=E+d8H=dOmyO_F=abt8VDdouv2wFbDMpm4aaXQ@mail.gmail.com>
	<023301ccb6b1$f1e69970$d5b3cc50$@flaxen.com>
Message-ID: <CABUeae_Rm-kbak4+xDeknofZr5wQf-1wGOt0LAyth79EzaSehw@mail.gmail.com>

2011/12/9 Michael P. Gerlek <mpg@flaxen.com>:
> Right, but I've got an little language I've written for writing "pdal filter expressions"
> and I'm wondering what's the best representation in that language to use for a GUID.

AFAIU, you need some form of "quoting" for GUID to recognize it.
Then, I'd go for {} as it is a well recognized convention, if not standard:

http://en.wikipedia.org/wiki/Globally_unique_identifier#Text_encoding

> Syntactically and lexically, a guid string of form (a) looks like a mashup of a hex constant,
> a variable name identifier, and an arithmetic expression (subtraction).
> So I'm thinking of preceeding it with a "$" or putting it in {}'s or some such.

IMO, a DSL should recognise this kind of things without any special
and artificial delimiters.

My 2 cents.

Best regards,
-- 
Mateusz Loskot, http://mateusz.loskot.net
Charter Member of OSGeo, http://osgeo.org
Member of ACCU, http://accu.org
From mpg at flaxen.com  Fri Dec  9 15:55:47 2011
From: mpg at flaxen.com (Michael P. Gerlek)
Date: Fri Dec  9 20:09:08 2011
Subject: [pdal] RE: Gist notes
In-Reply-To: <CABUeae_Rm-kbak4+xDeknofZr5wQf-1wGOt0LAyth79EzaSehw@mail.gmail.com>
References: <021901ccb6a5$b15fdad0$141f9070$@flaxen.com>	<56E2AD0D-D76C-4D93-8EAC-EBE597DD4392@gmail.com>	<022e01ccb6ab$d47e1f80$7d7a5e80$@flaxen.com>	<CABUeae9qckhU=E+d8H=dOmyO_F=abt8VDdouv2wFbDMpm4aaXQ@mail.gmail.com>	<023301ccb6b1$f1e69970$d5b3cc50$@flaxen.com>
	<CABUeae_Rm-kbak4+xDeknofZr5wQf-1wGOt0LAyth79EzaSehw@mail.gmail.com>
Message-ID: <023401ccb6b4$ee0f7260$ca2e5720$@flaxen.com>

> IMO, a DSL should recognise this kind of things without any special and artificial delimiters.

Ideally, yes, but as a practical matter, this string:

	30250400-4089-1103-9000-030508203301

without any annotation or delimiter is ambiguous: it could be a guid, or it could be an arithmetic expression of the form "a-b-c-d-e".

I'll figure something out...

_mpg


From mateusz at loskot.net  Fri Dec  9 16:08:34 2011
From: mateusz at loskot.net (=?UTF-8?Q?Mateusz_=C5=81oskot?=)
Date: Fri Dec  9 20:22:33 2011
Subject: [pdal] RE: Gist notes
In-Reply-To: <023401ccb6b4$ee0f7260$ca2e5720$@flaxen.com>
References: <021901ccb6a5$b15fdad0$141f9070$@flaxen.com>
	<56E2AD0D-D76C-4D93-8EAC-EBE597DD4392@gmail.com>
	<022e01ccb6ab$d47e1f80$7d7a5e80$@flaxen.com>
	<CABUeae9qckhU=E+d8H=dOmyO_F=abt8VDdouv2wFbDMpm4aaXQ@mail.gmail.com>
	<023301ccb6b1$f1e69970$d5b3cc50$@flaxen.com>
	<CABUeae_Rm-kbak4+xDeknofZr5wQf-1wGOt0LAyth79EzaSehw@mail.gmail.com>
	<023401ccb6b4$ee0f7260$ca2e5720$@flaxen.com>
Message-ID: <CABUeae8aARfPGa1YJTfcAs5MEQQsD07N4mL_Re9PVJB_Hw0Nwg@mail.gmail.com>

2011/12/9 Michael P. Gerlek <mpg@flaxen.com>:
>> IMO, a DSL should recognise this kind of things without any special and artificial delimiters.
>
> Ideally, yes, but as a practical matter, this string:
>
> ? ? ? ?30250400-4089-1103-9000-030508203301
>
> without any annotation or delimiter is ambiguous: it could be a guid,
> or it could be an arithmetic expression of the form "a-b-c-d-e".

You could expect

SELECT from FROM from WHERE where = 0;

but grammar of DSL will handle that, and recognize if from, where are
reserved keywords, or allowed names (e.g. if DSL is case-sensitive).

Best regards,
-- 
Mateusz Loskot, http://mateusz.loskot.net
Charter Member of OSGeo, http://osgeo.org
Member of ACCU, http://accu.org
From mateusz at loskot.net  Fri Dec  9 21:21:40 2011
From: mateusz at loskot.net (=?UTF-8?Q?Mateusz_=C5=81oskot?=)
Date: Sat Dec 10 01:52:14 2011
Subject: [pdal] RE: Gist notes
In-Reply-To: <023801ccb6b7$c1751d10$445f5730$@flaxen.com>
References: <021901ccb6a5$b15fdad0$141f9070$@flaxen.com>
	<56E2AD0D-D76C-4D93-8EAC-EBE597DD4392@gmail.com>
	<022e01ccb6ab$d47e1f80$7d7a5e80$@flaxen.com>
	<CABUeae9qckhU=E+d8H=dOmyO_F=abt8VDdouv2wFbDMpm4aaXQ@mail.gmail.com>
	<023301ccb6b1$f1e69970$d5b3cc50$@flaxen.com>
	<CABUeae_Rm-kbak4+xDeknofZr5wQf-1wGOt0LAyth79EzaSehw@mail.gmail.com>
	<023401ccb6b4$ee0f7260$ca2e5720$@flaxen.com>
	<CABUeae8aARfPGa1YJTfcAs5MEQQsD07N4mL_Re9PVJB_Hw0Nwg@mail.gmail.com>
	<023801ccb6b7$c1751d10$445f5730$@flaxen.com>
Message-ID: <CABUeae-6e0V_2Z3AYpAcVe9OopQ4RjUOABOKrGRxW6L-HR+_YQ@mail.gmail.com>

2011/12/9 Michael P. Gerlek <mpg@flaxen.com>:
> I should explain that my language allows for statements of the form
>
> ? ? ? ?Field1 = Field2 + 10
>
> In Howard's case, the variable name "Field2" would be replaced by a GUID string.
> Without any annotation, the expression would then be ambiguous.

Even fstab file on Linux annotate UUID for drives.
However, with proper grammar, ambiguity drops to none and flexibility increases:

I've just given a quick stab at some PDAL expressions grammar using
Boost.Spirit:

https://github.com/mloskot/boost-spirit-workshop/blob/master/pdal_expressions.cpp

Certainly, it is not very useful at the moment as it only
parses/validates input.
But semantic evaluation can be added without problems (apart from the
Spirit learning curve).
See calc_utree.cpp example in the same repo.

Best regards,
-- 
Mateusz Loskot, http://mateusz.loskot.net
Charter Member of OSGeo, http://osgeo.org
Member of ACCU, http://accu.org
From mateusz at loskot.net  Sat Dec 10 18:10:52 2011
From: mateusz at loskot.net (=?UTF-8?Q?Mateusz_=C5=81oskot?=)
Date: Sat Dec 10 23:51:29 2011
Subject: [pdal] RE: Gist notes
In-Reply-To: <026001ccb6e4$f69488f0$e3bd9ad0$@flaxen.com>
References: <021901ccb6a5$b15fdad0$141f9070$@flaxen.com>
	<56E2AD0D-D76C-4D93-8EAC-EBE597DD4392@gmail.com>
	<022e01ccb6ab$d47e1f80$7d7a5e80$@flaxen.com>
	<CABUeae9qckhU=E+d8H=dOmyO_F=abt8VDdouv2wFbDMpm4aaXQ@mail.gmail.com>
	<023301ccb6b1$f1e69970$d5b3cc50$@flaxen.com>
	<CABUeae_Rm-kbak4+xDeknofZr5wQf-1wGOt0LAyth79EzaSehw@mail.gmail.com>
	<023401ccb6b4$ee0f7260$ca2e5720$@flaxen.com>
	<CABUeae8aARfPGa1YJTfcAs5MEQQsD07N4mL_Re9PVJB_Hw0Nwg@mail.gmail.com>
	<023801ccb6b7$c1751d10$445f5730$@flaxen.com>
	<CABUeae-6e0V_2Z3AYpAcVe9OopQ4RjUOABOKrGRxW6L-HR+_YQ@mail.gmail.com>
	<026001ccb6e4$f69488f0$e3bd9ad0$@flaxen.com>
Message-ID: <CABUeae-QMuORgR_jwzyToi7F6_MSUujfxZdTWgba0rVBFXcdkA@mail.gmail.com>

2011/12/10 Michael P. Gerlek <mpg@flaxen.com>:
> You had seemed to be originally saying that a proper DSL didn't need annotations for guids,
>but you are using {}'s here, so I'm not sure what you're original post meant now.

Yes, I suggested it is possible, but without knowing what is the
actual grammar of PDAL expressions.
GUID in hex-based textual format has data parts separated by '-' which
may be ambiguous
or it may not. For example, it depends if grammar is white-space
sensitive, where are GUIDs acceptable.

For example:

If white spaces are mandatory, it is possible to parse this without
any problems:

Field1 = 3F2504E0-4F89-11D3-9A0C-0305E82C3301 + 10

but in this case it is very difficult if not impossible to avoid ambiguities:

Field1=3F2504E0-4F89-11D3-9A0C-0305E82C3301+9F740E48-F56E-4105-900E-93B8E6E5ADCC-Field2*10-123

That's why {} delimiters solve the problem. For parser grammar, it is
a very simple addition.

IMHO, Boost.Spirit, ANTLR or any other good parser parser is always
superior than hand-written processors.

Best regards,
-- 
Mateusz Loskot, http://mateusz.loskot.net
Charter Member of OSGeo, http://osgeo.org
Member of ACCU, http://accu.org
From mateusz at loskot.net  Tue Dec 13 06:53:08 2011
From: mateusz at loskot.net (=?UTF-8?Q?Mateusz_=C5=81oskot?=)
Date: Tue Dec 13 15:56:12 2011
Subject: [pdal] RE: Gist notes
In-Reply-To: <CABUeae-QMuORgR_jwzyToi7F6_MSUujfxZdTWgba0rVBFXcdkA@mail.gmail.com>
References: <021901ccb6a5$b15fdad0$141f9070$@flaxen.com>
	<56E2AD0D-D76C-4D93-8EAC-EBE597DD4392@gmail.com>
	<022e01ccb6ab$d47e1f80$7d7a5e80$@flaxen.com>
	<CABUeae9qckhU=E+d8H=dOmyO_F=abt8VDdouv2wFbDMpm4aaXQ@mail.gmail.com>
	<023301ccb6b1$f1e69970$d5b3cc50$@flaxen.com>
	<CABUeae_Rm-kbak4+xDeknofZr5wQf-1wGOt0LAyth79EzaSehw@mail.gmail.com>
	<023401ccb6b4$ee0f7260$ca2e5720$@flaxen.com>
	<CABUeae8aARfPGa1YJTfcAs5MEQQsD07N4mL_Re9PVJB_Hw0Nwg@mail.gmail.com>
	<023801ccb6b7$c1751d10$445f5730$@flaxen.com>
	<CABUeae-6e0V_2Z3AYpAcVe9OopQ4RjUOABOKrGRxW6L-HR+_YQ@mail.gmail.com>
	<026001ccb6e4$f69488f0$e3bd9ad0$@flaxen.com>
	<CABUeae-QMuORgR_jwzyToi7F6_MSUujfxZdTWgba0rVBFXcdkA@mail.gmail.com>
Message-ID: <CABUeae-yST2_oANNbmVNgMUG2D+NNKCGc1FhmoH7Ema5KR1C3Q@mail.gmail.com>

2011/12/10 Mateusz ?oskot <mateusz@loskot.net>:
> 2011/12/10 Michael P. Gerlek <mpg@flaxen.com>:
>> You had seemed to be originally saying that a proper DSL didn't need annotations for guids,
>>but you are using {}'s here, so I'm not sure what you're original post meant now.
>
> Yes, I suggested it is possible, but without knowing what is the
> actual grammar of PDAL expressions.
> GUID in hex-based textual format has data parts separated by '-' which
> may be ambiguous or it may not.

Being curious about this use case, I have discussed use of GUID in
grammar on Spirit list

http://thread.gmane.org/gmane.comp.parsers.spirit.general/24192

Best regards,
-- 
Mateusz Loskot, http://mateusz.loskot.net
From mpg at flaxen.com  Wed Dec 14 12:21:35 2011
From: mpg at flaxen.com (Michael P. Gerlek)
Date: Wed Dec 14 12:22:28 2011
Subject: [pdal] RE: Gist notes
In-Reply-To: <CABUeae-QMuORgR_jwzyToi7F6_MSUujfxZdTWgba0rVBFXcdkA@mail.gmail.com>
References: <021901ccb6a5$b15fdad0$141f9070$@flaxen.com>	<56E2AD0D-D76C-4D93-8EAC-EBE597DD4392@gmail.com>	<022e01ccb6ab$d47e1f80$7d7a5e80$@flaxen.com>	<CABUeae9qckhU=E+d8H=dOmyO_F=abt8VDdouv2wFbDMpm4aaXQ@mail.gmail.com>	<023301ccb6b1$f1e69970$d5b3cc50$@flaxen.com>	<CABUeae_Rm-kbak4+xDeknofZr5wQf-1wGOt0LAyth79EzaSehw@mail.gmail.com>	<023401ccb6b4$ee0f7260$ca2e5720$@flaxen.com>	<CABUeae8aARfPGa1YJTfcAs5MEQQsD07N4mL_Re9PVJB_Hw0Nwg@mail.gmail.com>	<023801ccb6b7$c1751d10$445f5730$@flaxen.com>	<CABUeae-6e0V_2Z3AYpAcVe9OopQ4RjUOABOKrGRxW6L-HR+_YQ@mail.gmail.com>	<026001ccb6e4$f69488f0$e3bd9ad0$@flaxen.com>
	<CABUeae-QMuORgR_jwzyToi7F6_MSUujfxZdTWgba0rVBFXcdkA@mail.gmail.com>
Message-ID: <05fe01ccba84$d6abe260$8403a720$@flaxen.com>

> IMHO, Boost.Spirit, ANTLR or any other good parser parser is always
> superior than hand-written processors.

I already wrote the parser a couple weeks ago, using Qi  (and it does more than just expressions).

It was an unpleasant learning curve, though, for someone with my level of C++/Boost experience...  Indeed, if it wasn?t for the very strong benefit of not having to add another tool to the PDAL build dependency chain, I would not have used it.

-mpg


From mateusz at loskot.net  Wed Dec 14 15:08:16 2011
From: mateusz at loskot.net (=?UTF-8?Q?Mateusz_=C5=81oskot?=)
Date: Wed Dec 14 15:09:02 2011
Subject: [pdal] RE: Gist notes
In-Reply-To: <05fe01ccba84$d6abe260$8403a720$@flaxen.com>
References: <021901ccb6a5$b15fdad0$141f9070$@flaxen.com>
	<56E2AD0D-D76C-4D93-8EAC-EBE597DD4392@gmail.com>
	<022e01ccb6ab$d47e1f80$7d7a5e80$@flaxen.com>
	<CABUeae9qckhU=E+d8H=dOmyO_F=abt8VDdouv2wFbDMpm4aaXQ@mail.gmail.com>
	<023301ccb6b1$f1e69970$d5b3cc50$@flaxen.com>
	<CABUeae_Rm-kbak4+xDeknofZr5wQf-1wGOt0LAyth79EzaSehw@mail.gmail.com>
	<023401ccb6b4$ee0f7260$ca2e5720$@flaxen.com>
	<CABUeae8aARfPGa1YJTfcAs5MEQQsD07N4mL_Re9PVJB_Hw0Nwg@mail.gmail.com>
	<023801ccb6b7$c1751d10$445f5730$@flaxen.com>
	<CABUeae-6e0V_2Z3AYpAcVe9OopQ4RjUOABOKrGRxW6L-HR+_YQ@mail.gmail.com>
	<026001ccb6e4$f69488f0$e3bd9ad0$@flaxen.com>
	<CABUeae-QMuORgR_jwzyToi7F6_MSUujfxZdTWgba0rVBFXcdkA@mail.gmail.com>
	<05fe01ccba84$d6abe260$8403a720$@flaxen.com>
Message-ID: <CABUeae8ssOx3LcP987MQmBzh-YVWPro7Ma60ugbOdLB92DGsVw@mail.gmail.com>

2011/12/14 Michael P. Gerlek <mpg@flaxen.com>:
>> IMHO, Boost.Spirit, ANTLR or any other good parser parser is always
>> superior than hand-written processors.
>
> I already wrote the parser a couple weeks ago, using Qi ?(and it does more than just expressions).
>
> It was an unpleasant learning curve, though, for someone with my level of C++/Boost experience...
> Indeed, if it wasn?t for the very strong benefit of not having to add another tool to the PDAL
> build dependency chain, I would not have used it.

Understood.

Best regards,
-- 
Mateusz Loskot, http://mateusz.loskot.net
Charter Member of OSGeo, http://osgeo.org
Member of ACCU, http://accu.org
From mpg at flaxen.com  Wed Dec 14 15:09:06 2011
From: mpg at flaxen.com (Michael P. Gerlek)
Date: Wed Dec 14 15:10:10 2011
Subject: [pdal] RE: Gist notes
In-Reply-To: <CABUeae8ssOx3LcP987MQmBzh-YVWPro7Ma60ugbOdLB92DGsVw@mail.gmail.com>
References: <021901ccb6a5$b15fdad0$141f9070$@flaxen.com>	<56E2AD0D-D76C-4D93-8EAC-EBE597DD4392@gmail.com>	<022e01ccb6ab$d47e1f80$7d7a5e80$@flaxen.com>	<CABUeae9qckhU=E+d8H=dOmyO_F=abt8VDdouv2wFbDMpm4aaXQ@mail.gmail.com>	<023301ccb6b1$f1e69970$d5b3cc50$@flaxen.com>	<CABUeae_Rm-kbak4+xDeknofZr5wQf-1wGOt0LAyth79EzaSehw@mail.gmail.com>	<023401ccb6b4$ee0f7260$ca2e5720$@flaxen.com>	<CABUeae8aARfPGa1YJTfcAs5MEQQsD07N4mL_Re9PVJB_Hw0Nwg@mail.gmail.com>	<023801ccb6b7$c1751d10$445f5730$@flaxen.com>	<CABUeae-6e0V_2Z3AYpAcVe9OopQ4RjUOABOKrGRxW6L-HR+_YQ@mail.gmail.com>	<026001ccb6e4$f69488f0$e3bd9ad0$@flaxen.com>	<CABUeae-QMuORgR_jwzyToi7F6_MSUujfxZdTWgba0rVBFXcdkA@mail.gmail.com>	<05fe01ccba84$d6abe260$8403a720$@flaxen.com>
	<CABUeae8ssOx3LcP987MQmBzh-YVWPro7Ma60ugbOdLB92DGsVw@mail.gmail.com>
Message-ID: <065e01ccba9c$3d6efc50$b84cf4f0$@flaxen.com>

Or to put it another way: "Just because you CAN do something clever with template metaprogramming doesn't mean you SHOULD."

:-)

-mpg


> -----Original Message-----
> From: Mateusz ?oskot [mailto:mateusz@loskot.net]
> Sent: Wednesday, December 14, 2011 12:08 PM
> To: mpg@flaxen.com
> Cc: pdal@lists.osgeo.org
> Subject: Re: [pdal] RE: Gist notes
> 
> 2011/12/14 Michael P. Gerlek <mpg@flaxen.com>:
> >> IMHO, Boost.Spirit, ANTLR or any other good parser parser is always
> >> superior than hand-written processors.
> >
> > I already wrote the parser a couple weeks ago, using Qi  (and it does more than just expressions).
> >
> > It was an unpleasant learning curve, though, for someone with my level of C++/Boost experience...
> > Indeed, if it wasn?t for the very strong benefit of not having to add another tool to the PDAL
> > build dependency chain, I would not have used it.
> 
> Understood.
> 
> Best regards,
> --
> Mateusz Loskot, http://mateusz.loskot.net
> Charter Member of OSGeo, http://osgeo.org
> Member of ACCU, http://accu.org

From mateusz at loskot.net  Wed Dec 14 15:22:51 2011
From: mateusz at loskot.net (=?UTF-8?Q?Mateusz_=C5=81oskot?=)
Date: Wed Dec 14 15:23:30 2011
Subject: [pdal] RE: Gist notes
In-Reply-To: <065e01ccba9c$3d6efc50$b84cf4f0$@flaxen.com>
References: <021901ccb6a5$b15fdad0$141f9070$@flaxen.com>
	<56E2AD0D-D76C-4D93-8EAC-EBE597DD4392@gmail.com>
	<022e01ccb6ab$d47e1f80$7d7a5e80$@flaxen.com>
	<CABUeae9qckhU=E+d8H=dOmyO_F=abt8VDdouv2wFbDMpm4aaXQ@mail.gmail.com>
	<023301ccb6b1$f1e69970$d5b3cc50$@flaxen.com>
	<CABUeae_Rm-kbak4+xDeknofZr5wQf-1wGOt0LAyth79EzaSehw@mail.gmail.com>
	<023401ccb6b4$ee0f7260$ca2e5720$@flaxen.com>
	<CABUeae8aARfPGa1YJTfcAs5MEQQsD07N4mL_Re9PVJB_Hw0Nwg@mail.gmail.com>
	<023801ccb6b7$c1751d10$445f5730$@flaxen.com>
	<CABUeae-6e0V_2Z3AYpAcVe9OopQ4RjUOABOKrGRxW6L-HR+_YQ@mail.gmail.com>
	<026001ccb6e4$f69488f0$e3bd9ad0$@flaxen.com>
	<CABUeae-QMuORgR_jwzyToi7F6_MSUujfxZdTWgba0rVBFXcdkA@mail.gmail.com>
	<05fe01ccba84$d6abe260$8403a720$@flaxen.com>
	<CABUeae8ssOx3LcP987MQmBzh-YVWPro7Ma60ugbOdLB92DGsVw@mail.gmail.com>
	<065e01ccba9c$3d6efc50$b84cf4f0$@flaxen.com>
Message-ID: <CABUeae-PXw1Zmo9VrRn8Sv=9GkLMOWsT1CGV4X79koujoVRp6w@mail.gmail.com>

2011/12/14 Michael P. Gerlek <mpg@flaxen.com>:
> Or to put it another way: "Just because you CAN do something clever with template
> metaprogramming doesn't mean you SHOULD."
>
> :-)

Agreed, but this is not about MPL but about using parser/generator for DSL.
Unfortunately, there are only few sensible choices here in C++.

Best regards,
-- 
Mateusz Loskot, http://mateusz.loskot.net
Charter Member of OSGeo, http://osgeo.org
Member of ACCU, http://accu.org
From hobu.inc at gmail.com  Mon Dec 19 12:50:43 2011
From: hobu.inc at gmail.com (Howard Butler)
Date: Mon Dec 19 12:51:02 2011
Subject: [pdal] Scaling filter and asking for dimensions
Message-ID: <06740672-AC23-49F8-A990-1A6421CD4981@gmail.com>

Michael,

Consider the following scenario of a filter to arbitrarily scale data takes in options that define a from- and a to- dimension -- for example taking the X dimension for scale-0.001 to scale-0.01, but keeping its datatype the same.  This scenario means touching the raw data to reapply the scaling, and you want to be able to address both X dimensions because one may be more precise than the other (if the scaling were to cause things to overflow, for example).

Using the old schema/dimension semantics, having two dimensions with the same type on a Schema didn't work very well (you couldn't select for a specific one). For the scaling filter, it was up to the filter to make sure to stuff its output into "the only" X_i32 dimension on the schema if you wanted the data that were scaled by the filter to be written into the Writer.  The Scaling filter worked because it added data that were X_f64 in type, and the writer disregarded them.  

Using the new semantics I'm working on in the dimension_types branch, a Stage can now ask the Schema for the "X" dimension,  the "filters.scale.X", or "drivers.las.X" dimensions on a Schema -- that is, the Schema can have two dimensions named 'X' on it, but they can be discriminated by their namespace (and/or guid which is available underneath for global addressability).  Having two 'X' dimensions with the same name and namespace is still the same problem as before, however.

We also have the problem of how to tell the writer which 'X' dimension it should be using.  As I have things currently implemented, schema.getDimension("X") is going to return the first 'X' dimension it comes across.  How should we be able to tell writers while writing/constructing a pipeline, "Hey, use filters.scale.X for your X dimension instead of drivers.las.X"?  We need some kind of mapping that the user can specify "For your 'X' dimension, use 'filters.scale.X'".  The new Scaling filter I've implemented can arbitrarily scale any dimension, so it is not sufficient for us to specify this just in terms of the X, Y, and Z dimensions of the LAS writer.  

My idea to resolve this is to simply have a convention where the Writer/Filter/Reader look up-pipeline for all namespaces ahead of it, and default to using those in preference to dimensions that have namespaces that are down-pipeline relative to it. It would involve adding two methods to StageBase to return a vector of up-pipeline and down-pipeline namespaces, and using this information to inform schema.getDimension invocations.

There may be instances where you would want to override this behavior, and I'm not sure of a clean way to do so, yet. Maybe there's a StageBase option to ask to turn off the namespace-aware dimension finding for a specific Stage.  

This email was FYI to see if it causes any thoughts about the subject to come to mind. I will continue trudging ahead in dimension_types and implement something like this.

Howard
From hobu.inc at gmail.com  Wed Dec 21 11:07:39 2011
From: hobu.inc at gmail.com (Howard Butler)
Date: Wed Dec 21 11:08:01 2011
Subject: [pdal] dimension_types branch merge
Message-ID: <AFC459E4-76D7-4547-801A-AE5817FA0119@gmail.com>

Michael,

I have merged my dimension_types work back into the main branch.  I suspect that I broke all of the SWIG-based stuff in the process, as I didn't make any updates to sync that with the effort.

All tests currently passing on my Snow Leopard system, but on my Lion system with boost 1.47, I get the following error:

> [  1%] Building CXX object src/CMakeFiles/pdal.dir/plang/AstUtils.cpp.o
> /Users/hobu/dev/git/pdal/src/plang/AstUtils.cpp: In static member function 'static pdal::plang::DataType pdal::plang::AstUtils::inferType(pdal::plang::variant_t)':
> /Users/hobu/dev/git/pdal/src/plang/AstUtils.cpp:62: error: no matching function for call to 'apply_visitor(pdal::plang::AstUtils::inferType(pdal::plang::variant_t)::my_visitor, pdal::plang::variant_t&)'

The long and the short of my dimension_types work up to this point is that PointBuffer::getField and setField now require a Dimension const& *from the PointBuffer's Schema* to do their business. We no longer operate based on explicit dimension positions (this is now managed by the Schema for the Dimension). The other items I was discussing are partially complete, but I reached a point where continuing to keep things up to date with the master branch was going to get quite hairy.

I will continue development on the master branch to implement the removal of Stage::getSchema and friends. Hopefully this work will be done by the end of the year.

Howard
From hobu.inc at gmail.com  Wed Dec 21 11:53:42 2011
From: hobu.inc at gmail.com (Howard Butler)
Date: Wed Dec 21 11:54:14 2011
Subject: [pdal] Re: dimension_types branch merge
In-Reply-To: <AFC459E4-76D7-4547-801A-AE5817FA0119@gmail.com>
References: <AFC459E4-76D7-4547-801A-AE5817FA0119@gmail.com>
Message-ID: <F30CB64D-8E87-4740-AFBA-20E926CB6496@gmail.com>


On Dec 21, 2011, at 10:07 AM, Howard Butler wrote:
> 
>> [  1%] Building CXX object src/CMakeFiles/pdal.dir/plang/AstUtils.cpp.o
>> /Users/hobu/dev/git/pdal/src/plang/AstUtils.cpp: In static member function 'static pdal::plang::DataType pdal::plang::AstUtils::inferType(pdal::plang::variant_t)':
>> /Users/hobu/dev/git/pdal/src/plang/AstUtils.cpp:62: error: no matching function for call to 'apply_visitor(pdal::plang::AstUtils::inferType(pdal::plang::variant_t)::my_visitor, pdal::plang::variant_t&)'

Weirdly, this compiles with the following warnings on clang:

> /Users/hobu/dev/git/pdal/src/plang/AstUtils.cpp:62:12: warning: template argument uses local type 'pdal::plang::AstUtils::my_visitor' [-Wlocal-type-template-args]
>     return ::boost::apply_visitor(my_visitor(), value);
>            ^~
> /Users/hobu/dev/git/pdal/src/plang/AstUtils.cpp:367:13: warning: enumeration values 'NodeType_VariableUse', 'NodeType_VariableDef', and 'NodeType_Program' not handled in
>       switch [-Wswitch-enum]
>     switch (nodetype)
>             ^
> /Users/hobu/dev/git/pdal/src/plang/AstUtils.cpp:163:41: warning: comparing floating point with == or != is unsafe [-Wfloat-equal]
>     case NodeType_Equal:     dst = left == right; break;
>                                    ~~~~ ^  ~~~~~
> /Users/hobu/dev/git/pdal/src/plang/AstUtils.cpp:270:32: note: in instantiation of function template specialization 'pdal::plang::do_equality<float>' requested here
>         case DataType_Float32: do_equality<float>(leftValue, rightValue, dstValue, nodetype); break;
>                                ^
> /Users/hobu/dev/git/pdal/src/plang/AstUtils.cpp:164:41: warning: comparing floating point with == or != is unsafe [-Wfloat-equal]
>     case NodeType_NotEqual:  dst = left != right; break;
>                                    ~~~~ ^  ~~~~~
> /Users/hobu/dev/git/pdal/src/plang/AstUtils.cpp:163:41: warning: comparing floating point with == or != is unsafe [-Wfloat-equal]
>     case NodeType_Equal:     dst = left == right; break;
>                                    ~~~~ ^  ~~~~~
> /Users/hobu/dev/git/pdal/src/plang/AstUtils.cpp:271:32: note: in instantiation of function template specialization 'pdal::plang::do_equality<double>' requested here
>         case DataType_Float64: do_equality<double>(leftValue, rightValue, dstValue, nodetype); break;
>                                


Howard
From mpg at flaxen.com  Wed Dec 21 12:48:00 2011
From: mpg at flaxen.com (Michael Gerlek)
Date: Wed Dec 21 12:48:17 2011
Subject: [pdal] Re: dimension_types branch merge
In-Reply-To: <F30CB64D-8E87-4740-AFBA-20E926CB6496@gmail.com>
References: <AFC459E4-76D7-4547-801A-AE5817FA0119@gmail.com>
	<F30CB64D-8E87-4740-AFBA-20E926CB6496@gmail.com>
Message-ID: <7624718850044215336@unknownmsgid>

(I'm trying to get a wifi connection to look into this now.)

.mpg

On Dec 21, 2011, at 9:53 AM, Howard Butler <hobu.inc@gmail.com> wrote:

>
> On Dec 21, 2011, at 10:07 AM, Howard Butler wrote:
>>
>>> [  1%] Building CXX object src/CMakeFiles/pdal.dir/plang/AstUtils.cpp.o
>>> /Users/hobu/dev/git/pdal/src/plang/AstUtils.cpp: In static member function 'static pdal::plang::DataType pdal::plang::AstUtils::inferType(pdal::plang::variant_t)':
>>> /Users/hobu/dev/git/pdal/src/plang/AstUtils.cpp:62: error: no matching function for call to 'apply_visitor(pdal::plang::AstUtils::inferType(pdal::plang::variant_t)::my_visitor, pdal::plang::variant_t&)'
>
> Weirdly, this compiles with the following warnings on clang:
>
>> /Users/hobu/dev/git/pdal/src/plang/AstUtils.cpp:62:12: warning: template argument uses local type 'pdal::plang::AstUtils::my_visitor' [-Wlocal-type-template-args]
>>    return ::boost::apply_visitor(my_visitor(), value);
>>           ^~
>> /Users/hobu/dev/git/pdal/src/plang/AstUtils.cpp:367:13: warning: enumeration values 'NodeType_VariableUse', 'NodeType_VariableDef', and 'NodeType_Program' not handled in
>>      switch [-Wswitch-enum]
>>    switch (nodetype)
>>            ^
>> /Users/hobu/dev/git/pdal/src/plang/AstUtils.cpp:163:41: warning: comparing floating point with == or != is unsafe [-Wfloat-equal]
>>    case NodeType_Equal:     dst = left == right; break;
>>                                   ~~~~ ^  ~~~~~
>> /Users/hobu/dev/git/pdal/src/plang/AstUtils.cpp:270:32: note: in instantiation of function template specialization 'pdal::plang::do_equality<float>' requested here
>>        case DataType_Float32: do_equality<float>(leftValue, rightValue, dstValue, nodetype); break;
>>                               ^
>> /Users/hobu/dev/git/pdal/src/plang/AstUtils.cpp:164:41: warning: comparing floating point with == or != is unsafe [-Wfloat-equal]
>>    case NodeType_NotEqual:  dst = left != right; break;
>>                                   ~~~~ ^  ~~~~~
>> /Users/hobu/dev/git/pdal/src/plang/AstUtils.cpp:163:41: warning: comparing floating point with == or != is unsafe [-Wfloat-equal]
>>    case NodeType_Equal:     dst = left == right; break;
>>                                   ~~~~ ^  ~~~~~
>> /Users/hobu/dev/git/pdal/src/plang/AstUtils.cpp:271:32: note: in instantiation of function template specialization 'pdal::plang::do_equality<double>' requested here
>>        case DataType_Float64: do_equality<double>(leftValue, rightValue, dstValue, nodetype); break;
>>
>
>
> Howard_______________________________________________
> pdal mailing list
> pdal@lists.osgeo.org
> http://lists.osgeo.org/mailman/listinfo/pdal
From hobu.inc at gmail.com  Wed Dec 21 12:49:17 2011
From: hobu.inc at gmail.com (Howard Butler)
Date: Wed Dec 21 12:49:37 2011
Subject: [pdal] Re: dimension_types branch merge
In-Reply-To: <7624718850044215336@unknownmsgid>
References: <AFC459E4-76D7-4547-801A-AE5817FA0119@gmail.com>
	<F30CB64D-8E87-4740-AFBA-20E926CB6496@gmail.com>
	<7624718850044215336@unknownmsgid>
Message-ID: <5D87C6AD-48C0-462B-9E30-D33EE543C105@gmail.com>

I think I have everything cured.  Please take a look at the commits from this morning on github if you want a synopsis.  

I checked the compilation on msvc10 too.  lots of warnings that are my fault. Will get them later this afternoon.

Howard

 
On Dec 21, 2011, at 11:48 AM, Michael Gerlek wrote:

> (I'm trying to get a wifi connection to look into this now.)
> 
> .mpg
> 
> On Dec 21, 2011, at 9:53 AM, Howard Butler <hobu.inc@gmail.com> wrote:
> 
>> 
>> On Dec 21, 2011, at 10:07 AM, Howard Butler wrote:
>>> 
>>>> [  1%] Building CXX object src/CMakeFiles/pdal.dir/plang/AstUtils.cpp.o
>>>> /Users/hobu/dev/git/pdal/src/plang/AstUtils.cpp: In static member function 'static pdal::plang::DataType pdal::plang::AstUtils::inferType(pdal::plang::variant_t)':
>>>> /Users/hobu/dev/git/pdal/src/plang/AstUtils.cpp:62: error: no matching function for call to 'apply_visitor(pdal::plang::AstUtils::inferType(pdal::plang::variant_t)::my_visitor, pdal::plang::variant_t&)'
>> 
>> Weirdly, this compiles with the following warnings on clang:
>> 
>>> /Users/hobu/dev/git/pdal/src/plang/AstUtils.cpp:62:12: warning: template argument uses local type 'pdal::plang::AstUtils::my_visitor' [-Wlocal-type-template-args]
>>>   return ::boost::apply_visitor(my_visitor(), value);
>>>          ^~
>>> /Users/hobu/dev/git/pdal/src/plang/AstUtils.cpp:367:13: warning: enumeration values 'NodeType_VariableUse', 'NodeType_VariableDef', and 'NodeType_Program' not handled in
>>>     switch [-Wswitch-enum]
>>>   switch (nodetype)
>>>           ^
>>> /Users/hobu/dev/git/pdal/src/plang/AstUtils.cpp:163:41: warning: comparing floating point with == or != is unsafe [-Wfloat-equal]
>>>   case NodeType_Equal:     dst = left == right; break;
>>>                                  ~~~~ ^  ~~~~~
>>> /Users/hobu/dev/git/pdal/src/plang/AstUtils.cpp:270:32: note: in instantiation of function template specialization 'pdal::plang::do_equality<float>' requested here
>>>       case DataType_Float32: do_equality<float>(leftValue, rightValue, dstValue, nodetype); break;
>>>                              ^
>>> /Users/hobu/dev/git/pdal/src/plang/AstUtils.cpp:164:41: warning: comparing floating point with == or != is unsafe [-Wfloat-equal]
>>>   case NodeType_NotEqual:  dst = left != right; break;
>>>                                  ~~~~ ^  ~~~~~
>>> /Users/hobu/dev/git/pdal/src/plang/AstUtils.cpp:163:41: warning: comparing floating point with == or != is unsafe [-Wfloat-equal]
>>>   case NodeType_Equal:     dst = left == right; break;
>>>                                  ~~~~ ^  ~~~~~
>>> /Users/hobu/dev/git/pdal/src/plang/AstUtils.cpp:271:32: note: in instantiation of function template specialization 'pdal::plang::do_equality<double>' requested here
>>>       case DataType_Float64: do_equality<double>(leftValue, rightValue, dstValue, nodetype); break;
>>> 
>> 
>> 
>> Howard_______________________________________________
>> pdal mailing list
>> pdal@lists.osgeo.org
>> http://lists.osgeo.org/mailman/listinfo/pdal

From mateusz at loskot.net  Thu Dec 22 19:49:55 2011
From: mateusz at loskot.net (=?UTF-8?Q?Mateusz_=C5=81oskot?=)
Date: Thu Dec 22 19:50:29 2011
Subject: [pdal] Fwd: [Boost-users] Using boost::uuids::uuid as a map index
In-Reply-To: <1324573945.19498.140661014890045@webmail.messagingengine.com>
References: <011c01ccb757$e6f42720$b4dc7560$@raisedbar.net>
	<CAOU91OMV=KwBxKpvG38TmfhB0P+YEMpUM3kqjxO_ZSL6niL=Qg@mail.gmail.com>
	<1324573945.19498.140661014890045@webmail.messagingengine.com>
Message-ID: <CABUeae8yka0AnmCpi2H647NYc9tmcDo5Ewy=-xD_PQzRTr30yw@mail.gmail.com>

Hi,

PDAL/libLAS make use of GUID/UUID, so I think the post attached
may be of interest here:


---------- Forwarded message ----------
From: Andy Tompkins <atompkins@fastmail.fm>
Date: 22 December 2011 17:12
Subject: Re: [Boost-users] Using boost::uuids::uuid as a map index
To: "boost.org" <boost-users@lists.boost.org>


On Sun, Dec 11, 2011, at 12:22 AM, Klaim - Jo?l Lamotte wrote:

Hi,

On Sat, Dec 10, 2011 at 17:22, Tim Burgess <tim@raisedbar.net> wrote:

All look-ups within the map based on the UUID then fail, as adding the
object to the map is essentially a copy operation and UUID is non-copyable,
so new unique identifiers were generated. ?I then tried:

Std::map <boost::uuids::uuid *, myClass*> myMap;


AFAIK uuid is copyable as it's a POD.


Correct, boost::uuids::uuid is copyable, it is a POD.

It can be used as the key in an std::map. ?I have created a simple
test for this and checked it into trunk
(http://svn.boost.org/svn/boost/trunk/libs/uuid/test/test_uuid_in_map.cpp).
?It passes. ?I have also attached the file.

I'm not sure where the problem is with your code. ?Could you provide a
more complete example?


However, I don't know about this problem but I remember having failed
to make uuid a key of map (I don't remember the reason).

If that can help you, I'm using a workaround to allow this : I convert
the uuid to std::string (using the generator function) and use it in
my whole application to allow finding by uuid from maps. That's
obviously more expensive but it works fine.


Jo?l Lamotte




Regards,
Andy.

_______________________________________________
Boost-users mailing list
Boost-users@lists.boost.org
http://lists.boost.org/mailman/listinfo.cgi/boost-users


-- 
Mateusz Loskot, http://mateusz.loskot.net
Charter Member of OSGeo, http://osgeo.org
Member of ACCU, http://accu.org
-------------- next part --------------
//  (C) Copyright Andy Tompkins 2011. Permission to copy, use, modify, sell and
//  distribute this software is granted provided this copyright notice appears
//  in all copies. This software is provided "as is" without express or implied
//  warranty, and with no claim as to its suitability for any purpose.

// Distributed under the Boost Software License, Version 1.0. (See
// accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

// libs/uuid/test/test_uuid_in_map.cpp  -------------------------------//

#include <boost/uuid/uuid.hpp>
#include <boost/uuid/uuid_generators.hpp>
#include <map>

#include <boost/detail/lightweight_test.hpp>

int main(int, char*[])
{
    boost::uuids::random_generator gen;

    boost::uuids::uuid u1 = gen();
    boost::uuids::uuid u2 = gen();
    boost::uuids::uuid u3 = gen();

    std::map<boost::uuids::uuid, int> uuid_map;
    uuid_map[u1] = 1;
    uuid_map[u2] = 2;
    uuid_map[u3] = 3;

    BOOST_TEST_EQ(1, uuid_map[u1]);
    BOOST_TEST_EQ(2, uuid_map[u2]);
    BOOST_TEST_EQ(3, uuid_map[u3]);

    return boost::report_errors();
}
