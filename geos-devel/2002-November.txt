From ybychkov at direct.ca  Mon Nov  4 17:18:59 2002
From: ybychkov at direct.ca (Yury A. Bychkov)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] GEOS Report (November 1, 2002)
Message-ID: <003001c28450$2d3e8f80$de354d18@yury>

Hi Everyone,

Current status:
1. WKTReader related classes were changed to make the XMLTester less fragile.
2. Tests of the code on a VERY BIG starfish-shaped geometry (10, 100, 1000 and
10000 nodes) had somewhat unusual results. 10, 100 and 1000 node test gave the
time very close to Java version, however 10000 node test took an extremely long
time to finish.

Things to do:
Try to solve the above problem.

Yury




From nhv at cape.com  Tue Nov  5 17:56:51 2002
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] Performance of GEOS
References: <5A94289A9268514C8D6C0F1FF44BA0270A2B5C@venus.VividSolutions.com>
Message-ID: <094301c2851e$a1daa850$8b37ba8c@sfdev3>

Martin Davis writes:
>
> Good idea about adding the performance code to the archive - we'll do that.

Any time frame for this ??

The reason I am asking is I have an experimental version
of GEOS from which I have removed all of the pure virtual
classes and quite a few virtual methods which I would like 
to test against a 'known' data set

Norman




From mbdavis at VividSolutions.com  Tue Nov  5 17:59:28 2002
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] Performance of GEOS
Message-ID: <5A94289A9268514C8D6C0F1FF44BA0270FD38C@venus.VividSolutions.com>

Yury, can you upload the sine star test classes?

Norman, what's the thought behind removing the virtual functions?  Improving performance?  Simplifying code?  I'm just asking, because at this point GEOS performance seems slower than it should be, and it would be nice to start getting thoughts on how to improve it.

Martin Davis, Senior Technical Specialist
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


> -----Original Message-----
> From: Norman Vine [mailto:nhv@cape.com]
> Sent: Tuesday, November 05, 2002 2:57 PM
> To: geos-devel@geos.refractions.net
> Subject: Re: [geos-devel] Performance of GEOS
> 
> 
> Martin Davis writes:
> >
> > Good idea about adding the performance code to the archive 
> - we'll do that.
> 
> Any time frame for this ??
> 
> The reason I am asking is I have an experimental version
> of GEOS from which I have removed all of the pure virtual
> classes and quite a few virtual methods which I would like 
> to test against a 'known' data set
> 
> Norman
> 
> 
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
> 


From nhv at cape.com  Tue Nov  5 18:04:55 2002
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] Performance of GEOS
References: <5A94289A9268514C8D6C0F1FF44BA0270FD38C@venus.VividSolutions.com>
Message-ID: <095001c2851f$c1fae180$8b37ba8c@sfdev3>

Martin Davis
> 
> Norman, what's the thought behind removing the virtual functions?  

Yup :-)

Norman



From mbdavis at VividSolutions.com  Tue Nov  5 18:12:09 2002
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] Performance of GEOS
Message-ID: <5A94289A9268514C8D6C0F1FF44BA0270FD38D@venus.VividSolutions.com>

Ok, let us know what you find out.

Martin Davis, Senior Technical Specialist
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


> -----Original Message-----
> From: Norman Vine [mailto:nhv@cape.com]
> Sent: Tuesday, November 05, 2002 3:05 PM
> To: geos-devel@geos.refractions.net
> Subject: Re: [geos-devel] Performance of GEOS
> 
> 
> Martin Davis
> > 
> > Norman, what's the thought behind removing the virtual functions?  
> 
> Yup :-)
> 
> Norman
> 
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
> 


From nhv at cape.com  Tue Nov  5 18:13:46 2002
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] Performance of GEOS
References: <5A94289A9268514C8D6C0F1FF44BA0270FD38C@venus.VividSolutions.com>
Message-ID: <095d01c28520$fec1da00$8b37ba8c@sfdev3>

Martin Davis writes:
> 
> Norman, what's the thought behind removing the virtual functions?  

Sorry I snipped to much the first time

> Improving performance?  Simplifying code?

Yes to both !

I suspect that it is the combination of Pure Virtuals and a lack of 
judicous inlining that is killing performance

Norman




 



From ybychkov at direct.ca  Tue Nov  5 18:15:19 2002
From: ybychkov at direct.ca (Yury A. Bychkov)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] Performance of GEOS
References: <5A94289A9268514C8D6C0F1FF44BA0270FD38C@venus.VividSolutions.com>
Message-ID: <005e01c28521$57d2c140$de354d18@yury>

> Yury, can you upload the sine star test classes?
Done. The test classes are in 'bigtest' directory.

Yury





From nhv at cape.com  Tue Nov  5 18:45:31 2002
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] Performance of GEOS
References: <5A94289A9268514C8D6C0F1FF44BA0270FD38C@venus.VividSolutions.com> <005e01c28521$57d2c140$de354d18@yury>
Message-ID: <098801c28525$6e53b920$8b37ba8c@sfdev3>

Yury A. Bychkov writes:
>
> Done. The test classes are in 'bigtest' directory.

Thanks :-)

FYI I have a problem with 

Coordinate EdgeEndStar::getCoordinate(){
 vector<EdgeEnd*>::iterator it=getIterator();
 if (it==NULL) return Coordinate::getNull();
 EdgeEnd *e=*it;
 return e->getCoordinate();
}

So I have been using

Coordinate EdgeEndStar::getCoordinate(){
    if (getEdges()->size() == 0 )
        return Coordinate::getNull();
 vector<EdgeEnd*>::iterator it=getIterator();
 EdgeEnd *e=*it;
 return e->getCoordinate();
}

I think that this is what is intended

I also need to change  
string WKTWriter::createFormatter(PrecisionModel precisionModel) {

  decimalPlaces = 1 + (int) ceil(log(precisionModel.getScale())/log(10));
to
  decimalPlaces = 1 + (int) ceil(log(precisionModel.getScale())/log(10.0));


Norman





Norman




From nhv at cape.com  Wed Nov  6 00:54:07 2002
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] Performance of GEOS
References: <5A94289A9268514C8D6C0F1FF44BA0270FD38D@venus.VividSolutions.com>
Message-ID: <000801c28558$ed307f70$4a37ba8c@sfdev3>

Martin Davis writes:

> Ok, let us know what you find out.

A little better - but not what I was hoping for

This is on a 733mhz PIII
Cygwin gcc 3.2

Norman

Code as in CVS

n Pts: 1000   Executed in 1000
# overlapping MCs: 44
# segment intersection tests: 4
n Pts: 2000   Executed in 4000
# overlapping MCs: 44
# segment intersection tests: 7
n Pts: 3000   Executed in 10000
# overlapping MCs: 44
# segment intersection tests: 4
n Pts: 4000   Executed in 22000
# overlapping MCs: 44
# segment intersection tests: 5
n Pts: 5000   Executed in 92000
# overlapping MCs: 44
# segment intersection tests: 7
n Pts: 6000   Executed in 156000
# overlapping MCs: 44
# segment intersection tests: 6
n Pts: 7000   Executed in 224000
# overlapping MCs: 44
# segment intersection tests: 4
n Pts: 8000   Executed in 315000

< manually stopped test before completion >


My test  code with no pure virtuals and inlined code

n Pts: 1000   Executed in 0
# overlapping MCs: 44
# segment intersection tests: 4
n Pts: 2000   Executed in 2000
# overlapping MCs: 44
# segment intersection tests: 7
n Pts: 3000   Executed in 4000
# overlapping MCs: 44
# segment intersection tests: 4
n Pts: 4000   Executed in 8000
# overlapping MCs: 44
# segment intersection tests: 5
n Pts: 5000   Executed in 16000
# overlapping MCs: 44
# segment intersection tests: 7
n Pts: 6000   Executed in 64000
# overlapping MCs: 44
# segment intersection tests: 6
n Pts: 7000   Executed in 110000
# overlapping MCs: 44
# segment intersection tests: 4
n Pts: 8000   Executed in 148000
# overlapping MCs: 44
# segment intersection tests: 5
n Pts: 9000   Executed in 194000
# overlapping MCs: 44
# segment intersection tests: 5
n Pts: 10000   Executed in 255000




From pramsey at refractions.net  Wed Nov  6 12:25:25 2002
From: pramsey at refractions.net (Paul Ramsey)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] Performance of GEOS
References: <5A94289A9268514C8D6C0F1FF44BA0270FD38D@venus.VividSolutions.com> <000801c28558$ed307f70$4a37ba8c@sfdev3>
Message-ID: <3DC95085.5070101@refractions.net>

I dunno, a factor of two in the worst case isn't *so* bad. Martin, 
should the times be increasing exponentially as the vertices increase 
linearly (is that what JTS does too)?

Norman Vine wrote:
> Martin Davis writes:
> 
> 
>>Ok, let us know what you find out.
> 
> 
> A little better - but not what I was hoping for
> 
> This is on a 733mhz PIII
> Cygwin gcc 3.2
> 
> Norman
> 
> Code as in CVS
> 
> n Pts: 1000   Executed in 1000
> # overlapping MCs: 44
> # segment intersection tests: 4
> n Pts: 2000   Executed in 4000
> # overlapping MCs: 44
> # segment intersection tests: 7
> n Pts: 3000   Executed in 10000
> # overlapping MCs: 44
> # segment intersection tests: 4
> n Pts: 4000   Executed in 22000
> # overlapping MCs: 44
> # segment intersection tests: 5
> n Pts: 5000   Executed in 92000
> # overlapping MCs: 44
> # segment intersection tests: 7
> n Pts: 6000   Executed in 156000
> # overlapping MCs: 44
> # segment intersection tests: 6
> n Pts: 7000   Executed in 224000
> # overlapping MCs: 44
> # segment intersection tests: 4
> n Pts: 8000   Executed in 315000
> 
> < manually stopped test before completion >
> 
> 
> My test  code with no pure virtuals and inlined code
> 
> n Pts: 1000   Executed in 0
> # overlapping MCs: 44
> # segment intersection tests: 4
> n Pts: 2000   Executed in 2000
> # overlapping MCs: 44
> # segment intersection tests: 7
> n Pts: 3000   Executed in 4000
> # overlapping MCs: 44
> # segment intersection tests: 4
> n Pts: 4000   Executed in 8000
> # overlapping MCs: 44
> # segment intersection tests: 5
> n Pts: 5000   Executed in 16000
> # overlapping MCs: 44
> # segment intersection tests: 7
> n Pts: 6000   Executed in 64000
> # overlapping MCs: 44
> # segment intersection tests: 6
> n Pts: 7000   Executed in 110000
> # overlapping MCs: 44
> # segment intersection tests: 4
> n Pts: 8000   Executed in 148000
> # overlapping MCs: 44
> # segment intersection tests: 5
> n Pts: 9000   Executed in 194000
> # overlapping MCs: 44
> # segment intersection tests: 5
> n Pts: 10000   Executed in 255000
> 
> 
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
> 


-- 
       __
      /
      | Paul Ramsey
      | Refractions Research
      | Email: pramsey@refractions.net
      | Phone: (250) 885-0632
      \_



From mbdavis at VividSolutions.com  Wed Nov  6 16:30:54 2002
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] Performance of GEOS compared to JTS
Message-ID: <5A94289A9268514C8D6C0F1FF44BA02701DD4A@venus.VividSolutions.com>

JTS actually exhibits *sub-linear* performance for this test.  (See test output below).  The reason for this is is that the indexing used in intersection detection drastically reduces the number of attempts to only check for intersections close to where the geometrys actually interact.  So, while the number of segments in one of the geometrys increases, the number of actual intersections is relatively constant.  

Not sure why the GEOS code doesn't do the same thing, though.  The metrics for the segment intersection test counts look ok - they hardly change, which is what you'd expect, since the number of locations where the geometries intersect doesn't change.  My suspicion is that the poor performance is due to memory allocation - there are quite a few places where small objects are allocated, in proportion to the total number of segments.  I think there's two ways of improving this: (a) use value objects instead of allocating memory in some cases (e.g. in the sweep line index) and (b) allocate memory in larger chunks and use sub-allocation.

One thing that might prove whether memory allocation is causing this symptom is to run the code on Linux and see whether the performance is different (since Linux may have a better - or worse! - memory allocator).

Metrics from JTS test:

# overlapping MCs: 34
# segment intersection tests: 38
n Pts: 10   Executed in 20 ms

# overlapping MCs: 40
# segment intersection tests: 26
n Pts: 100   Executed in 20 ms

# overlapping MCs: 44
# segment intersection tests: 7
n Pts: 1000   Executed in 80 ms

# overlapping MCs: 44
# segment intersection tests: 5
n Pts: 10000   Executed in 180 ms


Martin Davis, Senior Technical Specialist
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


> -----Original Message-----
> From: Paul Ramsey [mailto:pramsey@refractions.net]
> Sent: Wednesday, November 06, 2002 9:25 AM
> To: geos-devel@geos.refractions.net
> Subject: Re: [geos-devel] Performance of GEOS
> 
> 
> I dunno, a factor of two in the worst case isn't *so* bad. Martin, 
> should the times be increasing exponentially as the vertices increase 
> linearly (is that what JTS does too)?
> 
> Norman Vine wrote:
> > Martin Davis writes:
> > 
> > 
> >>Ok, let us know what you find out.
> > 
> > 
> > A little better - but not what I was hoping for
> > 
> > This is on a 733mhz PIII
> > Cygwin gcc 3.2
> > 
> > Norman
> > 
> > Code as in CVS
> > 
> > n Pts: 1000   Executed in 1000
> > # overlapping MCs: 44
> > # segment intersection tests: 4
> > n Pts: 2000   Executed in 4000
> > # overlapping MCs: 44
> > # segment intersection tests: 7
> > n Pts: 3000   Executed in 10000
> > # overlapping MCs: 44
> > # segment intersection tests: 4
> > n Pts: 4000   Executed in 22000
> > # overlapping MCs: 44
> > # segment intersection tests: 5
> > n Pts: 5000   Executed in 92000
> > # overlapping MCs: 44
> > # segment intersection tests: 7
> > n Pts: 6000   Executed in 156000
> > # overlapping MCs: 44
> > # segment intersection tests: 6
> > n Pts: 7000   Executed in 224000
> > # overlapping MCs: 44
> > # segment intersection tests: 4
> > n Pts: 8000   Executed in 315000
> > 
> > < manually stopped test before completion >
> > 
> > 
> > My test  code with no pure virtuals and inlined code
> > 
> > n Pts: 1000   Executed in 0
> > # overlapping MCs: 44
> > # segment intersection tests: 4
> > n Pts: 2000   Executed in 2000
> > # overlapping MCs: 44
> > # segment intersection tests: 7
> > n Pts: 3000   Executed in 4000
> > # overlapping MCs: 44
> > # segment intersection tests: 4
> > n Pts: 4000   Executed in 8000
> > # overlapping MCs: 44
> > # segment intersection tests: 5
> > n Pts: 5000   Executed in 16000
> > # overlapping MCs: 44
> > # segment intersection tests: 7
> > n Pts: 6000   Executed in 64000
> > # overlapping MCs: 44
> > # segment intersection tests: 6
> > n Pts: 7000   Executed in 110000
> > # overlapping MCs: 44
> > # segment intersection tests: 4
> > n Pts: 8000   Executed in 148000
> > # overlapping MCs: 44
> > # segment intersection tests: 5
> > n Pts: 9000   Executed in 194000
> > # overlapping MCs: 44
> > # segment intersection tests: 5
> > n Pts: 10000   Executed in 255000
> > 
> > 
> > 
> > _______________________________________________
> > geos-devel mailing list
> > geos-devel@geos.refractions.net
> > http://geos.refractions.net/mailman/listinfo/geos-devel
> > 
> 
> 
> -- 
>        __
>       /
>       | Paul Ramsey
>       | Refractions Research
>       | Email: pramsey@refractions.net
>       | Phone: (250) 885-0632
>       \_
> 
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
> 


From pramsey at refractions.net  Wed Nov  6 17:21:50 2002
From: pramsey at refractions.net (Paul Ramsey)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] Performance of GEOS compared to JTS
References: <5A94289A9268514C8D6C0F1FF44BA02701DD4A@venus.VividSolutions.com>
Message-ID: <3DC995FE.1090106@refractions.net>

Here are the results from Linux. Processor is AMD Athlon 1900+ (1666.785Mz)

# overlapping MCs: 36
# segment intersection tests: 39
n Pts: 10   Executed in 0
# overlapping MCs: 40
# segment intersection tests: 26
n Pts: 100   Executed in 0
# overlapping MCs: 44
# segment intersection tests: 7
n Pts: 1000   Executed in 1000
# overlapping MCs: 44
# segment intersection tests: 4
n Pts: 2000   Executed in 3000
# overlapping MCs: 44
# segment intersection tests: 7
n Pts: 3000   Executed in 10000
# overlapping MCs: 44
# segment intersection tests: 4
n Pts: 4000   Executed in 17000
# overlapping MCs: 44
# segment intersection tests: 5
n Pts: 5000   Executed in 82000
# overlapping MCs: 44
# segment intersection tests: 7
n Pts: 6000   Executed in 127000
# overlapping MCs: 44
# segment intersection tests: 6
n Pts: 7000   Executed in 174000


Martin Davis wrote:
 > JTS actually exhibits *sub-linear* performance for this test.  (See
 > test output below).  The reason for this is is that the indexing used
 > in intersection detection drastically reduces the number of attempts
 > to only check for intersections close to where the geometrys actually
 > interact.  So, while the number of segments in one of the geometrys
 > increases, the number of actual intersections is relatively constant.
 >
 >
 > Not sure why the GEOS code doesn't do the same thing, though.  The
 > metrics for the segment intersection test counts look ok - they
 > hardly change, which is what you'd expect, since the number of
 > locations where the geometries intersect doesn't change.  My
 > suspicion is that the poor performance is due to memory allocation -
 > there are quite a few places where small objects are allocated, in
 > proportion to the total number of segments.  I think there's two ways
 > of improving this: (a) use value objects instead of allocating memory
 > in some cases (e.g. in the sweep line index) and (b) allocate memory
 > in larger chunks and use sub-allocation.
 >
 > One thing that might prove whether memory allocation is causing this
 > symptom is to run the code on Linux and see whether the performance
 > is different (since Linux may have a better - or worse! - memory
 > allocator).
 >
 > Metrics from JTS test:
 >
 > # overlapping MCs: 34 # segment intersection tests: 38 n Pts: 10
 > Executed in 20 ms
 >
 > # overlapping MCs: 40 # segment intersection tests: 26 n Pts: 100
 > Executed in 20 ms
 >
 > # overlapping MCs: 44 # segment intersection tests: 7 n Pts: 1000
 > Executed in 80 ms
 >
 > # overlapping MCs: 44 # segment intersection tests: 5 n Pts: 10000
 > Executed in 180 ms
 >
 >
 > Martin Davis, Senior Technical Specialist Vivid Solutions Inc. Suite
 > #1A-2328 Government Street   Victoria, B.C.   V8T 5G5 Phone: (250)
 > 385 6040    Fax: (250) 385 6046 EMail: mbdavis@vividsolutions.com
 > Web: www.vividsolutions.com
 >
 >
 >
 >> -----Original Message----- From: Paul Ramsey
 >> [mailto:pramsey@refractions.net] Sent: Wednesday, November 06, 2002
 >> 9:25 AM To: geos-devel@geos.refractions.net Subject: Re:
 >> [geos-devel] Performance of GEOS
 >>
 >>
 >> I dunno, a factor of two in the worst case isn't *so* bad. Martin,
 >>  should the times be increasing exponentially as the vertices
 >> increase linearly (is that what JTS does too)?
 >>
 >> Norman Vine wrote:
 >>
 >>> Martin Davis writes:
 >>>
 >>>
 >>>
 >>>> Ok, let us know what you find out.
 >>>
 >>>
 >>> A little better - but not what I was hoping for
 >>>
 >>> This is on a 733mhz PIII Cygwin gcc 3.2
 >>>
 >>> Norman
 >>>
 >>> Code as in CVS
 >>>
 >>> n Pts: 1000   Executed in 1000 # overlapping MCs: 44 # segment
 >>> intersection tests: 4 n Pts: 2000   Executed in 4000 #
 >>> overlapping MCs: 44 # segment intersection tests: 7 n Pts: 3000
 >>> Executed in 10000 # overlapping MCs: 44 # segment intersection
 >>> tests: 4 n Pts: 4000   Executed in 22000 # overlapping MCs: 44 #
 >>> segment intersection tests: 5 n Pts: 5000   Executed in 92000 #
 >>> overlapping MCs: 44 # segment intersection tests: 7 n Pts: 6000
 >>> Executed in 156000 # overlapping MCs: 44 # segment intersection
 >>> tests: 6 n Pts: 7000   Executed in 224000 # overlapping MCs: 44 #
 >>> segment intersection tests: 4 n Pts: 8000   Executed in 315000
 >>>
 >>> < manually stopped test before completion >
 >>>
 >>>
 >>> My test  code with no pure virtuals and inlined code
 >>>
 >>> n Pts: 1000   Executed in 0 # overlapping MCs: 44 # segment
 >>> intersection tests: 4 n Pts: 2000   Executed in 2000 #
 >>> overlapping MCs: 44 # segment intersection tests: 7 n Pts: 3000
 >>> Executed in 4000 # overlapping MCs: 44 # segment intersection
 >>> tests: 4 n Pts: 4000   Executed in 8000 # overlapping MCs: 44 #
 >>> segment intersection tests: 5 n Pts: 5000   Executed in 16000 #
 >>> overlapping MCs: 44 # segment intersection tests: 7 n Pts: 6000
 >>> Executed in 64000 # overlapping MCs: 44 # segment intersection
 >>> tests: 6 n Pts: 7000   Executed in 110000 # overlapping MCs: 44 #
 >>> segment intersection tests: 4 n Pts: 8000   Executed in 148000 #
 >>> overlapping MCs: 44 # segment intersection tests: 5 n Pts: 9000
 >>> Executed in 194000 # overlapping MCs: 44 # segment intersection
 >>> tests: 5 n Pts: 10000   Executed in 255000
 >>>
 >>>

-- 
       __
      /
      | Paul Ramsey
      | Refractions Research
      | Email: pramsey@refractions.net
      | Phone: (250) 885-0632
      \_



From mbdavis at VividSolutions.com  Wed Nov  6 17:25:03 2002
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] Performance of GEOS compared to JTS
Message-ID: <5A94289A9268514C8D6C0F1FF44BA0270FD39E@venus.VividSolutions.com>

hmm, not looking too good.  It's showing super-linear performance also.  

I guess we're going to have to wait for Yury to report back on what he finds once he's had an in-depth look at what's going on.

Martin Davis, Senior Technical Specialist
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


> -----Original Message-----
> From: Paul Ramsey [mailto:pramsey@refractions.net]
> Sent: Wednesday, November 06, 2002 2:22 PM
> To: geos-devel@geos.refractions.net
> Subject: Re: [geos-devel] Performance of GEOS compared to JTS
> 
> 
> Here are the results from Linux. Processor is AMD Athlon 
> 1900+ (1666.785Mz)
> 
> # overlapping MCs: 36
> # segment intersection tests: 39
> n Pts: 10   Executed in 0
> # overlapping MCs: 40
> # segment intersection tests: 26
> n Pts: 100   Executed in 0
> # overlapping MCs: 44
> # segment intersection tests: 7
> n Pts: 1000   Executed in 1000
> # overlapping MCs: 44
> # segment intersection tests: 4
> n Pts: 2000   Executed in 3000
> # overlapping MCs: 44
> # segment intersection tests: 7
> n Pts: 3000   Executed in 10000
> # overlapping MCs: 44
> # segment intersection tests: 4
> n Pts: 4000   Executed in 17000
> # overlapping MCs: 44
> # segment intersection tests: 5
> n Pts: 5000   Executed in 82000
> # overlapping MCs: 44
> # segment intersection tests: 7
> n Pts: 6000   Executed in 127000
> # overlapping MCs: 44
> # segment intersection tests: 6
> n Pts: 7000   Executed in 174000
> 
> 
> Martin Davis wrote:
>  > JTS actually exhibits *sub-linear* performance for this test.  (See
>  > test output below).  The reason for this is is that the 
> indexing used
>  > in intersection detection drastically reduces the number 
> of attempts
>  > to only check for intersections close to where the 
> geometrys actually
>  > interact.  So, while the number of segments in one of the geometrys
>  > increases, the number of actual intersections is 
> relatively constant.
>  >
>  >
>  > Not sure why the GEOS code doesn't do the same thing, though.  The
>  > metrics for the segment intersection test counts look ok - they
>  > hardly change, which is what you'd expect, since the number of
>  > locations where the geometries intersect doesn't change.  My
>  > suspicion is that the poor performance is due to memory 
> allocation -
>  > there are quite a few places where small objects are allocated, in
>  > proportion to the total number of segments.  I think 
> there's two ways
>  > of improving this: (a) use value objects instead of 
> allocating memory
>  > in some cases (e.g. in the sweep line index) and (b) 
> allocate memory
>  > in larger chunks and use sub-allocation.
>  >
>  > One thing that might prove whether memory allocation is 
> causing this
>  > symptom is to run the code on Linux and see whether the performance
>  > is different (since Linux may have a better - or worse! - memory
>  > allocator).
>  >
>  > Metrics from JTS test:
>  >
>  > # overlapping MCs: 34 # segment intersection tests: 38 n Pts: 10
>  > Executed in 20 ms
>  >
>  > # overlapping MCs: 40 # segment intersection tests: 26 n Pts: 100
>  > Executed in 20 ms
>  >
>  > # overlapping MCs: 44 # segment intersection tests: 7 n Pts: 1000
>  > Executed in 80 ms
>  >
>  > # overlapping MCs: 44 # segment intersection tests: 5 n Pts: 10000
>  > Executed in 180 ms
>  >
>  >
>  > Martin Davis, Senior Technical Specialist Vivid Solutions 
> Inc. Suite
>  > #1A-2328 Government Street   Victoria, B.C.   V8T 5G5 Phone: (250)
>  > 385 6040    Fax: (250) 385 6046 EMail: mbdavis@vividsolutions.com
>  > Web: www.vividsolutions.com
>  >
>  >
>  >
>  >> -----Original Message----- From: Paul Ramsey
>  >> [mailto:pramsey@refractions.net] Sent: Wednesday, 
> November 06, 2002
>  >> 9:25 AM To: geos-devel@geos.refractions.net Subject: Re:
>  >> [geos-devel] Performance of GEOS
>  >>
>  >>
>  >> I dunno, a factor of two in the worst case isn't *so* bad. Martin,
>  >>  should the times be increasing exponentially as the vertices
>  >> increase linearly (is that what JTS does too)?
>  >>
>  >> Norman Vine wrote:
>  >>
>  >>> Martin Davis writes:
>  >>>
>  >>>
>  >>>
>  >>>> Ok, let us know what you find out.
>  >>>
>  >>>
>  >>> A little better - but not what I was hoping for
>  >>>
>  >>> This is on a 733mhz PIII Cygwin gcc 3.2
>  >>>
>  >>> Norman
>  >>>
>  >>> Code as in CVS
>  >>>
>  >>> n Pts: 1000   Executed in 1000 # overlapping MCs: 44 # segment
>  >>> intersection tests: 4 n Pts: 2000   Executed in 4000 #
>  >>> overlapping MCs: 44 # segment intersection tests: 7 n Pts: 3000
>  >>> Executed in 10000 # overlapping MCs: 44 # segment intersection
>  >>> tests: 4 n Pts: 4000   Executed in 22000 # overlapping MCs: 44 #
>  >>> segment intersection tests: 5 n Pts: 5000   Executed in 92000 #
>  >>> overlapping MCs: 44 # segment intersection tests: 7 n Pts: 6000
>  >>> Executed in 156000 # overlapping MCs: 44 # segment intersection
>  >>> tests: 6 n Pts: 7000   Executed in 224000 # overlapping MCs: 44 #
>  >>> segment intersection tests: 4 n Pts: 8000   Executed in 315000
>  >>>
>  >>> < manually stopped test before completion >
>  >>>
>  >>>
>  >>> My test  code with no pure virtuals and inlined code
>  >>>
>  >>> n Pts: 1000   Executed in 0 # overlapping MCs: 44 # segment
>  >>> intersection tests: 4 n Pts: 2000   Executed in 2000 #
>  >>> overlapping MCs: 44 # segment intersection tests: 7 n Pts: 3000
>  >>> Executed in 4000 # overlapping MCs: 44 # segment intersection
>  >>> tests: 4 n Pts: 4000   Executed in 8000 # overlapping MCs: 44 #
>  >>> segment intersection tests: 5 n Pts: 5000   Executed in 16000 #
>  >>> overlapping MCs: 44 # segment intersection tests: 7 n Pts: 6000
>  >>> Executed in 64000 # overlapping MCs: 44 # segment intersection
>  >>> tests: 6 n Pts: 7000   Executed in 110000 # overlapping MCs: 44 #
>  >>> segment intersection tests: 4 n Pts: 8000   Executed in 148000 #
>  >>> overlapping MCs: 44 # segment intersection tests: 5 n Pts: 9000
>  >>> Executed in 194000 # overlapping MCs: 44 # segment intersection
>  >>> tests: 5 n Pts: 10000   Executed in 255000
>  >>>
>  >>>
> 
> -- 
>        __
>       /
>       | Paul Ramsey
>       | Refractions Research
>       | Email: pramsey@refractions.net
>       | Phone: (250) 885-0632
>       \_
> 
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
> 


From nhv at cape.com  Thu Nov  7 00:59:03 2002
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] Performance of GEOS compared to JTS
References: <5A94289A9268514C8D6C0F1FF44BA02701DD4A@venus.VividSolutions.com>
Message-ID: <047501c28622$c72361b0$1e37ba8c@sfdev3>

Martin Daviswrites:
>
> JTS actually exhibits *sub-linear* performance for this test.  

I expected linear time, this is even better !
The task now is to discover  what is different between the 'C' code
and the Jave version.
> 
>My suspicion is that the poor performance is due to memory allocation - 

This could easily be the case.
BUT we should profile the code and stop guessing.

Cygwin has a 'poor' gprof implementtion so maybe one of the 
Linux users could configure GEOS with 

% CXXFLAGS="-O2 -g -pg" ./configure
make clean
make

run a 10000 pt test 
then run gprof so we had some REAL timings to look at

> 
>(since Linux may have a better - or worse! - memory allocator).

Cygwin and Linux actually use the same malloc subsystem
This is worth trying with MSVC too

 
> 
> Metrics from JTS test:
> 
> # overlapping MCs: 34
> # segment intersection tests: 38
> n Pts: 10   Executed in 20 ms
> 
> # overlapping MCs: 40
> # segment intersection tests: 26
> n Pts: 100   Executed in 20 ms
> 
> # overlapping MCs: 44
> # segment intersection tests: 7
> n Pts: 1000   Executed in 80 ms
> 
> # overlapping MCs: 44
> # segment intersection tests: 5
> n Pts: 10000   Executed in 180 ms

Ah this is MUCH better
It almost makes me think that somehow the
C code is missing an early reject somewhere
in the translation and turning this into a O(N**2)
instead of an O(N) operation

A profiling test should point to the offending loop

Norman




From nhv at cape.com  Thu Nov  7 01:01:44 2002
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] Performance of GEOS compared to JTS
References: <5A94289A9268514C8D6C0F1FF44BA0270FD39E@venus.VividSolutions.com>
Message-ID: <047a01c28623$2738dad0$1e37ba8c@sfdev3>

Martin Davis
>
> hmm, not looking too good.  It's showing super-linear performance also.  
> 
> I guess we're going to have to wait for Yury to report back on what he finds once he's had an in-depth look at what's going on.

Here is the link to the Cygwin/Linux Memory allocator
http://gee.cs.oswego.edu/dl/html/malloc.html

FWIW - I have had VERY good luck using this with MSVC

Norman



From ybychkov at direct.ca  Fri Nov  8 14:51:07 2002
From: ybychkov at direct.ca (Yury A. Bychkov)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] Performance of GEOS compared to JTS (Report, Nov. 8)
References: <5A94289A9268514C8D6C0F1FF44BA02701DD4A@venus.VividSolutions.com>
 <3DC995FE.1090106@refractions.net>
Message-ID: <002801c28760$30c19b80$de354d18@yury>

Success !!!

I found a good profiler for Windows (VTune from Intel) and tracked down some of
the problems that caused bad performance. They were mostly linked with copying
and destroying vectors of Coordinates. I've fixed the worst of them and now
GEOS's performance is drastically improved (though it is still slower then JTS).
New version has been committed to the CVS.

Results:
# overlapping MCs: 36
# segment intersection tests: 39
n Pts: 10  Executed in     10 ms.
# overlapping MCs: 40
# segment intersection tests: 26
n Pts: 100  Executed in     10 ms.
# overlapping MCs: 44
# segment intersection tests: 7
n Pts: 1000  Executed in     90 ms.
# overlapping MCs: 44
# segment intersection tests: 4
n Pts: 2000  Executed in    100 ms.
# overlapping MCs: 44
# segment intersection tests: 7
n Pts: 3000  Executed in    220 ms.
# overlapping MCs: 44
# segment intersection tests: 4
n Pts: 4000  Executed in    271 ms.
# overlapping MCs: 44
# segment intersection tests: 5
n Pts: 5000  Executed in    330 ms.
# overlapping MCs: 44
# segment intersection tests: 7
n Pts: 6000  Executed in    381 ms.
# overlapping MCs: 44
# segment intersection tests: 6
n Pts: 7000  Executed in    470 ms.
# overlapping MCs: 44
# segment intersection tests: 4
n Pts: 8000  Executed in    460 ms.
# overlapping MCs: 44
# segment intersection tests: 5
n Pts: 9000  Executed in    581 ms.
# overlapping MCs: 44
# segment intersection tests: 5
n Pts: 10000  Executed in    681 ms.


Yury




From ybychkov at direct.ca  Fri Nov  8 14:53:40 2002
From: ybychkov at direct.ca (Yury A. Bychkov)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] Note:  Performance of GEOS compared to JTS (Report, Nov. 8)
Message-ID: <003101c28760$89b97c80$de354d18@yury>

Forgot to add to the last message:
The PC on which I am running it is quite old (P2-450), so someone should try it
on a modern one.
----- Original Message -----
From: "Yury A. Bychkov" <ybychkov@direct.ca>
To: <geos-devel@geos.refractions.net>
Sent: Friday, November 08, 2002 11:51 AM
Subject: Performance of GEOS compared to JTS (Report, Nov. 8)


> Success !!!
>
> I found a good profiler for Windows (VTune from Intel) and tracked down some
of
> the problems that caused bad performance. They were mostly linked with copying
> and destroying vectors of Coordinates. I've fixed the worst of them and now
> GEOS's performance is drastically improved (though it is still slower then
JTS).
> New version has been committed to the CVS.
>
> Results:
> # overlapping MCs: 36
> # segment intersection tests: 39
> n Pts: 10  Executed in     10 ms.
> # overlapping MCs: 40
> # segment intersection tests: 26
> n Pts: 100  Executed in     10 ms.
> # overlapping MCs: 44
> # segment intersection tests: 7
> n Pts: 1000  Executed in     90 ms.
> # overlapping MCs: 44
> # segment intersection tests: 4
> n Pts: 2000  Executed in    100 ms.
> # overlapping MCs: 44
> # segment intersection tests: 7
> n Pts: 3000  Executed in    220 ms.
> # overlapping MCs: 44
> # segment intersection tests: 4
> n Pts: 4000  Executed in    271 ms.
> # overlapping MCs: 44
> # segment intersection tests: 5
> n Pts: 5000  Executed in    330 ms.
> # overlapping MCs: 44
> # segment intersection tests: 7
> n Pts: 6000  Executed in    381 ms.
> # overlapping MCs: 44
> # segment intersection tests: 6
> n Pts: 7000  Executed in    470 ms.
> # overlapping MCs: 44
> # segment intersection tests: 4
> n Pts: 8000  Executed in    460 ms.
> # overlapping MCs: 44
> # segment intersection tests: 5
> n Pts: 9000  Executed in    581 ms.
> # overlapping MCs: 44
> # segment intersection tests: 5
> n Pts: 10000  Executed in    681 ms.
>
>
> Yury
>




From mbdavis at VividSolutions.com  Fri Nov  8 15:51:01 2002
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] Performance of GEOS compared to JTS (Report, Nov. 8)
Message-ID: <5A94289A9268514C8D6C0F1FF44BA0270FD3D0@venus.VividSolutions.com>

Excellent work, Yury.  

But we're not done yet....  I can't see any reason why GEOS should be *slower* than JTS!  (I assume this comparison is made on the same hardware configuration...)  Perhaps we need to do some more memory management tuning ...  Better put your nifty vtune profiler to work before it timebombs.

Martin Davis, Senior Technical Specialist
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


> -----Original Message-----
> From: Yury A. Bychkov [mailto:ybychkov@direct.ca]
> Sent: Friday, November 08, 2002 11:51 AM
> To: geos-devel@geos.refractions.net
> Subject: [geos-devel] Performance of GEOS compared to JTS 
> (Report, Nov.
> 8)
> 
> 
> Success !!!
> 
> I found a good profiler for Windows (VTune from Intel) and 
> tracked down some of
> the problems that caused bad performance. They were mostly 
> linked with copying
> and destroying vectors of Coordinates. I've fixed the worst 
> of them and now
> GEOS's performance is drastically improved (though it is 
> still slower then JTS).
> New version has been committed to the CVS.
> 
> Results:
> # overlapping MCs: 36
> # segment intersection tests: 39
> n Pts: 10  Executed in     10 ms.
> # overlapping MCs: 40
> # segment intersection tests: 26
> n Pts: 100  Executed in     10 ms.
> # overlapping MCs: 44
> # segment intersection tests: 7
> n Pts: 1000  Executed in     90 ms.
> # overlapping MCs: 44
> # segment intersection tests: 4
> n Pts: 2000  Executed in    100 ms.
> # overlapping MCs: 44
> # segment intersection tests: 7
> n Pts: 3000  Executed in    220 ms.
> # overlapping MCs: 44
> # segment intersection tests: 4
> n Pts: 4000  Executed in    271 ms.
> # overlapping MCs: 44
> # segment intersection tests: 5
> n Pts: 5000  Executed in    330 ms.
> # overlapping MCs: 44
> # segment intersection tests: 7
> n Pts: 6000  Executed in    381 ms.
> # overlapping MCs: 44
> # segment intersection tests: 6
> n Pts: 7000  Executed in    470 ms.
> # overlapping MCs: 44
> # segment intersection tests: 4
> n Pts: 8000  Executed in    460 ms.
> # overlapping MCs: 44
> # segment intersection tests: 5
> n Pts: 9000  Executed in    581 ms.
> # overlapping MCs: 44
> # segment intersection tests: 5
> n Pts: 10000  Executed in    681 ms.
> 
> 
> Yury
> 
> 
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
> 


From pramsey at refractions.net  Fri Nov  8 16:07:58 2002
From: pramsey at refractions.net (Paul Ramsey)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] Performance of GEOS compared to JTS (Report, Nov. 8)
In-Reply-To: <5A94289A9268514C8D6C0F1FF44BA0270FD3D0@venus.VividSolutions.com>
References: <5A94289A9268514C8D6C0F1FF44BA0270FD3D0@venus.VividSolutions.com>
Message-ID: <1036789678.3dcc27ae674e6@www>

Here are the Linux tests again... Yury, you have to explicitly include stdio.h 
in the tester in order to get printf under GNU...

# overlapping MCs: 44
# segment intersection tests: 7
n Pts: 1000  Executed in     10 ms.
# overlapping MCs: 44
# segment intersection tests: 4
n Pts: 2000  Executed in     30 ms.
# overlapping MCs: 44
# segment intersection tests: 4
n Pts: 4000  Executed in     70 ms.
# overlapping MCs: 44
# segment intersection tests: 4
n Pts: 8000  Executed in    160 ms.
# overlapping MCs: 44
# segment intersection tests: 4
n Pts: 16000  Executed in    330 ms.
# overlapping MCs: 44
# segment intersection tests: 4
n Pts: 32000  Executed in    660 ms.
# overlapping MCs: 44
# segment intersection tests: 4
n Pts: 64000  Executed in   1300 ms.
# overlapping MCs: 44
# segment intersection tests: 4
n Pts: 128000  Executed in   2600 ms.


Quoting Martin Davis <mbdavis@VividSolutions.com>:

> Excellent work, Yury.
> 
> But we're not done yet....  I can't see any reason why GEOS should be
> *slower* than JTS!  (I assume this comparison is made on the same hardware
> configuration...)  Perhaps we need to do some more memory management tuning
> ...  Better put your nifty vtune profiler to work before it timebombs.
> 
> Martin Davis, Senior Technical Specialist
> Vivid Solutions Inc.
> Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
> Phone: (250) 385 6040    Fax: (250) 385 6046
> EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com
> 
> 
> > -----Original Message-----
> > From: Yury A. Bychkov [mailto:ybychkov@direct.ca]
> > Sent: Friday, November 08, 2002 11:51 AM
> > To: geos-devel@geos.refractions.net
> > Subject: [geos-devel] Performance of GEOS compared to JTS
> > (Report, Nov.
> > 8)
> >
> >
> > Success !!!
> >
> > I found a good profiler for Windows (VTune from Intel) and
> > tracked down some of
> > the problems that caused bad performance. They were mostly
> > linked with copying
> > and destroying vectors of Coordinates. I've fixed the worst
> > of them and now
> > GEOS's performance is drastically improved (though it is
> > still slower then JTS).
> > New version has been committed to the CVS.
> >
> > Results:
> > # overlapping MCs: 36
> > # segment intersection tests: 39
> > n Pts: 10  Executed in     10 ms.
> > # overlapping MCs: 40
> > # segment intersection tests: 26
> > n Pts: 100  Executed in     10 ms.
> > # overlapping MCs: 44
> > # segment intersection tests: 7
> > n Pts: 1000  Executed in     90 ms.
> > # overlapping MCs: 44
> > # segment intersection tests: 4
> > n Pts: 2000  Executed in    100 ms.
> > # overlapping MCs: 44
> > # segment intersection tests: 7
> > n Pts: 3000  Executed in    220 ms.
> > # overlapping MCs: 44
> > # segment intersection tests: 4
> > n Pts: 4000  Executed in    271 ms.
> > # overlapping MCs: 44
> > # segment intersection tests: 5
> > n Pts: 5000  Executed in    330 ms.
> > # overlapping MCs: 44
> > # segment intersection tests: 7
> > n Pts: 6000  Executed in    381 ms.
> > # overlapping MCs: 44
> > # segment intersection tests: 6
> > n Pts: 7000  Executed in    470 ms.
> > # overlapping MCs: 44
> > # segment intersection tests: 4
> > n Pts: 8000  Executed in    460 ms.
> > # overlapping MCs: 44
> > # segment intersection tests: 5
> > n Pts: 9000  Executed in    581 ms.
> > # overlapping MCs: 44
> > # segment intersection tests: 5
> > n Pts: 10000  Executed in    681 ms.
> >
> >
> > Yury
> >
> >
> >
> > _______________________________________________
> > geos-devel mailing list
> > geos-devel@geos.refractions.net
> > http://geos.refractions.net/mailman/listinfo/geos-devel
> >
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
> 
> 




-------------------------------------------------
This mail sent through IMP: http://horde.org/imp/



From nhv at cape.com  Fri Nov  8 18:04:26 2002
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] Performance of GEOS compared to JTS (Report, Nov. 8)
References: <5A94289A9268514C8D6C0F1FF44BA0270FD3D0@venus.VividSolutions.com>
Message-ID: <016601c2877b$31374c70$0100a8c0@sfdev3>

Martin Davis writes:

> Excellent work, Yury.  

Yes Indeed excellent !  

n Pts: 100000  Executed in   2655 ms.
n Pts: 200000  Executed in   5277 ms.
n Pts: 500000  Executed in  13199 ms.
n Pts: 1000000  Executed in  25766 ms.

 O(N)  !
 
> But we're not done yet....  

 :-))




From dblasby at refractions.net  Fri Nov  8 19:43:49 2002
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] Adding Relate() to PostGIS
References: <5A94289A9268514C8D6C0F1FF44BA0270FD3D0@venus.VividSolutions.com> <016601c2877b$31374c70$0100a8c0@sfdev3>
Message-ID: <3DCC5A45.447B0F74@refractions.net>

I've started working on putting the GEOS functionality into PostGIS.

I'm at an early stage, but I've figured out (hopefully) how to do all
the wrappings, compilings, and linking to write the wrappers.

I'll start working on the PostGIS Geometry -> GEOS geometry monday....

dave



From mbdavis at VividSolutions.com  Fri Nov  8 19:47:44 2002
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] Performance of GEOS compared to JTS (Report, Nov. 8)
Message-ID: <5A94289A9268514C8D6C0F1FF44BA02701DD4E@venus.VividSolutions.com>

Good stuff....  

Some coments:

- With further thought, I've realized that technically this test should exhibit linear performance in both JTS and GEOS (since the code has to *at least* scan all the points of the geometries!).  GEOS now certainly shows this.  It remains to be determined why JTS appears to be better than linear!   Ultimately I think JTS will show linear time, with big enough geometries.  I'll change my test to scale up by multiples of two like Pauls, and we'll see what happens [by the way, we should all use the same test sizes, for ease of comparison].  I think there must be something in the GEOS code that is sensitive to the number of coordinates and that dominates the performance, so that it's linear from the outset.  

I would still expect that the C++ code should be absolutely faster than Java - so we still have some sleuthing to do.

Another test would be to have *both* geometries increasing in size - this will stress the indexing a bit more.  I'll do something here and post the results (and code, for Yury to port).

Martin Davis, Senior Technical Specialist
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


> -----Original Message-----
> From: Paul Ramsey [mailto:pramsey@refractions.net]
> Sent: Friday, November 08, 2002 1:08 PM
> To: geos-devel@geos.refractions.net
> Subject: RE: [geos-devel] Performance of GEOS compared to JTS (Report,
> Nov. 8)
> 
> 
> Here are the Linux tests again... Yury, you have to 
> explicitly include stdio.h 
> in the tester in order to get printf under GNU...
> 
> # overlapping MCs: 44
> # segment intersection tests: 7
> n Pts: 1000  Executed in     10 ms.
> # overlapping MCs: 44
> # segment intersection tests: 4
> n Pts: 2000  Executed in     30 ms.
> # overlapping MCs: 44
> # segment intersection tests: 4
> n Pts: 4000  Executed in     70 ms.
> # overlapping MCs: 44
> # segment intersection tests: 4
> n Pts: 8000  Executed in    160 ms.
> # overlapping MCs: 44
> # segment intersection tests: 4
> n Pts: 16000  Executed in    330 ms.
> # overlapping MCs: 44
> # segment intersection tests: 4
> n Pts: 32000  Executed in    660 ms.
> # overlapping MCs: 44
> # segment intersection tests: 4
> n Pts: 64000  Executed in   1300 ms.
> # overlapping MCs: 44
> # segment intersection tests: 4
> n Pts: 128000  Executed in   2600 ms.
> 
> 
> Quoting Martin Davis <mbdavis@VividSolutions.com>:
> 
> > Excellent work, Yury.
> > 
> > But we're not done yet....  I can't see any reason why GEOS 
> should be
> > *slower* than JTS!  (I assume this comparison is made on 
> the same hardware
> > configuration...)  Perhaps we need to do some more memory 
> management tuning
> > ...  Better put your nifty vtune profiler to work before it 
> timebombs.
> > 
> > Martin Davis, Senior Technical Specialist
> > Vivid Solutions Inc.
> > Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
> > Phone: (250) 385 6040    Fax: (250) 385 6046
> > EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com
> > 
> > 
> > > -----Original Message-----
> > > From: Yury A. Bychkov [mailto:ybychkov@direct.ca]
> > > Sent: Friday, November 08, 2002 11:51 AM
> > > To: geos-devel@geos.refractions.net
> > > Subject: [geos-devel] Performance of GEOS compared to JTS
> > > (Report, Nov.
> > > 8)
> > >
> > >
> > > Success !!!
> > >
> > > I found a good profiler for Windows (VTune from Intel) and
> > > tracked down some of
> > > the problems that caused bad performance. They were mostly
> > > linked with copying
> > > and destroying vectors of Coordinates. I've fixed the worst
> > > of them and now
> > > GEOS's performance is drastically improved (though it is
> > > still slower then JTS).
> > > New version has been committed to the CVS.
> > >
> > > Results:
> > > # overlapping MCs: 36
> > > # segment intersection tests: 39
> > > n Pts: 10  Executed in     10 ms.
> > > # overlapping MCs: 40
> > > # segment intersection tests: 26
> > > n Pts: 100  Executed in     10 ms.
> > > # overlapping MCs: 44
> > > # segment intersection tests: 7
> > > n Pts: 1000  Executed in     90 ms.
> > > # overlapping MCs: 44
> > > # segment intersection tests: 4
> > > n Pts: 2000  Executed in    100 ms.
> > > # overlapping MCs: 44
> > > # segment intersection tests: 7
> > > n Pts: 3000  Executed in    220 ms.
> > > # overlapping MCs: 44
> > > # segment intersection tests: 4
> > > n Pts: 4000  Executed in    271 ms.
> > > # overlapping MCs: 44
> > > # segment intersection tests: 5
> > > n Pts: 5000  Executed in    330 ms.
> > > # overlapping MCs: 44
> > > # segment intersection tests: 7
> > > n Pts: 6000  Executed in    381 ms.
> > > # overlapping MCs: 44
> > > # segment intersection tests: 6
> > > n Pts: 7000  Executed in    470 ms.
> > > # overlapping MCs: 44
> > > # segment intersection tests: 4
> > > n Pts: 8000  Executed in    460 ms.
> > > # overlapping MCs: 44
> > > # segment intersection tests: 5
> > > n Pts: 9000  Executed in    581 ms.
> > > # overlapping MCs: 44
> > > # segment intersection tests: 5
> > > n Pts: 10000  Executed in    681 ms.
> > >
> > >
> > > Yury
> > >
> > >
> > >
> > > _______________________________________________
> > > geos-devel mailing list
> > > geos-devel@geos.refractions.net
> > > http://geos.refractions.net/mailman/listinfo/geos-devel
> > >
> > 
> > _______________________________________________
> > geos-devel mailing list
> > geos-devel@geos.refractions.net
> > http://geos.refractions.net/mailman/listinfo/geos-devel
> > 
> > 
> 
> 
> 
> 
> -------------------------------------------------
> This mail sent through IMP: http://horde.org/imp/
> 
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
> 


From mbdavis at VividSolutions.com  Fri Nov  8 19:55:24 2002
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] Performance of GEOS compared to JTS (Report, Nov. 8)
Message-ID: <5A94289A9268514C8D6C0F1FF44BA0270FD3DD@venus.VividSolutions.com>

For comparison purposes, here's the timings for JTS on the same numbers.  JTS now looks linear, just like GEOS. (I think we just didn't go quite large enough last time).  It's still (a bit) faster than GEOS, though - and I'm running on a 1.1 GHz machine, not a 1.9 GHz box.  Maybe Java's just bettah...  8^)

n Pts: 1000   Executed in 3014 ms
n Pts: 2000   Executed in 91 ms
n Pts: 4000   Executed in 50 ms
n Pts: 8000   Executed in 110 ms
n Pts: 16000   Executed in 210 ms
n Pts: 32000   Executed in 411 ms
n Pts: 64000   Executed in 801 ms
n Pts: 128000   Executed in 2032 ms
n Pts: 256000   Executed in 3545 ms

Martin Davis, Senior Technical Specialist
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


> -----Original Message-----
> From: Paul Ramsey [mailto:pramsey@refractions.net]
> Sent: Friday, November 08, 2002 1:08 PM
> To: geos-devel@geos.refractions.net
> Subject: RE: [geos-devel] Performance of GEOS compared to JTS (Report,
> Nov. 8)
> 
> 
> Here are the Linux tests again... Yury, you have to 
> explicitly include stdio.h 
> in the tester in order to get printf under GNU...
> 
> # overlapping MCs: 44
> # segment intersection tests: 7
> n Pts: 1000  Executed in     10 ms.
> # overlapping MCs: 44
> # segment intersection tests: 4
> n Pts: 2000  Executed in     30 ms.
> # overlapping MCs: 44
> # segment intersection tests: 4
> n Pts: 4000  Executed in     70 ms.
> # overlapping MCs: 44
> # segment intersection tests: 4
> n Pts: 8000  Executed in    160 ms.
> # overlapping MCs: 44
> # segment intersection tests: 4
> n Pts: 16000  Executed in    330 ms.
> # overlapping MCs: 44
> # segment intersection tests: 4
> n Pts: 32000  Executed in    660 ms.
> # overlapping MCs: 44
> # segment intersection tests: 4
> n Pts: 64000  Executed in   1300 ms.
> # overlapping MCs: 44
> # segment intersection tests: 4
> n Pts: 128000  Executed in   2600 ms.
> 
> 
> Quoting Martin Davis <mbdavis@VividSolutions.com>:
> 
> > Excellent work, Yury.
> > 
> > But we're not done yet....  I can't see any reason why GEOS 
> should be
> > *slower* than JTS!  (I assume this comparison is made on 
> the same hardware
> > configuration...)  Perhaps we need to do some more memory 
> management tuning
> > ...  Better put your nifty vtune profiler to work before it 
> timebombs.
> > 
> > Martin Davis, Senior Technical Specialist
> > Vivid Solutions Inc.
> > Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
> > Phone: (250) 385 6040    Fax: (250) 385 6046
> > EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com
> > 
> > 
> > > -----Original Message-----
> > > From: Yury A. Bychkov [mailto:ybychkov@direct.ca]
> > > Sent: Friday, November 08, 2002 11:51 AM
> > > To: geos-devel@geos.refractions.net
> > > Subject: [geos-devel] Performance of GEOS compared to JTS
> > > (Report, Nov.
> > > 8)
> > >
> > >
> > > Success !!!
> > >
> > > I found a good profiler for Windows (VTune from Intel) and
> > > tracked down some of
> > > the problems that caused bad performance. They were mostly
> > > linked with copying
> > > and destroying vectors of Coordinates. I've fixed the worst
> > > of them and now
> > > GEOS's performance is drastically improved (though it is
> > > still slower then JTS).
> > > New version has been committed to the CVS.
> > >
> > > Results:
> > > # overlapping MCs: 36
> > > # segment intersection tests: 39
> > > n Pts: 10  Executed in     10 ms.
> > > # overlapping MCs: 40
> > > # segment intersection tests: 26
> > > n Pts: 100  Executed in     10 ms.
> > > # overlapping MCs: 44
> > > # segment intersection tests: 7
> > > n Pts: 1000  Executed in     90 ms.
> > > # overlapping MCs: 44
> > > # segment intersection tests: 4
> > > n Pts: 2000  Executed in    100 ms.
> > > # overlapping MCs: 44
> > > # segment intersection tests: 7
> > > n Pts: 3000  Executed in    220 ms.
> > > # overlapping MCs: 44
> > > # segment intersection tests: 4
> > > n Pts: 4000  Executed in    271 ms.
> > > # overlapping MCs: 44
> > > # segment intersection tests: 5
> > > n Pts: 5000  Executed in    330 ms.
> > > # overlapping MCs: 44
> > > # segment intersection tests: 7
> > > n Pts: 6000  Executed in    381 ms.
> > > # overlapping MCs: 44
> > > # segment intersection tests: 6
> > > n Pts: 7000  Executed in    470 ms.
> > > # overlapping MCs: 44
> > > # segment intersection tests: 4
> > > n Pts: 8000  Executed in    460 ms.
> > > # overlapping MCs: 44
> > > # segment intersection tests: 5
> > > n Pts: 9000  Executed in    581 ms.
> > > # overlapping MCs: 44
> > > # segment intersection tests: 5
> > > n Pts: 10000  Executed in    681 ms.
> > >
> > >
> > > Yury
> > >
> > >
> > >
> > > _______________________________________________
> > > geos-devel mailing list
> > > geos-devel@geos.refractions.net
> > > http://geos.refractions.net/mailman/listinfo/geos-devel
> > >
> > 
> > _______________________________________________
> > geos-devel mailing list
> > geos-devel@geos.refractions.net
> > http://geos.refractions.net/mailman/listinfo/geos-devel
> > 
> > 
> 
> 
> 
> 
> -------------------------------------------------
> This mail sent through IMP: http://horde.org/imp/
> 
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
> 


From mbdavis at VividSolutions.com  Fri Nov  8 20:16:11 2002
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] New performance test with 2 large geometrys
Message-ID: <5A94289A9268514C8D6C0F1FF44BA02701DD4F@venus.VividSolutions.com>

I tried a slight variation of the original SineStar test (call it SineStarSquared).  It compares two SineStars, each with the same number of points. One sineStar is offset from the other by 50 units in the y direction.    This means that the number of actual intersections is constant.  With the indexing implemented in JTS the expected performance is linear (and this is in fact what happens, I'm happy to say).  (Note that an implementation with poor or no indexing could have time of O(n^2), however.)

Here's the timings.  They're only 50% slower than the original SineStarBox test, which is pretty good.

n Pts: 1000   Executed in 2804 ms
 n Pts: 2000   Executed in 60 ms
 n Pts: 4000   Executed in 120 ms 
n Pts: 8000   Executed in 210 ms 
n Pts: 16000   Executed in 401 ms 
n Pts: 32000   Executed in 661 ms 
n Pts: 64000   Executed in 1421 ms 
n Pts: 128000   Executed in 2644 ms 
n Pts: 256000   Executed in 5307 ms

(Yury: to implement this simply replace the line
    Polygon box = GeometryTestFactory.createBox(fact,0,0,1,100.0);
with
    Polygon box = GeometryTestFactory.createSineStar(fact, 0.0, size/2, size, armLen, nArms, nPts); 
)

Martin Davis, Senior Technical Specialist
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com



From nhv at cape.com  Mon Nov 11 11:56:39 2002
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] Performance of GEOS compared to JTS (Report, Nov. 8)
References: <5A94289A9268514C8D6C0F1FF44BA02701DD4E@venus.VividSolutions.com>
Message-ID: <055301c289a3$4e7aa410$473dba8c@sfdev3>

Martin Davis
> 
> I would still expect that the C++ code should be absolutely faster than Java - 

Me too 

> so we still have some sleuthing to do.

< disclaimer> 
  I know next to nothing about the JAVA 'machine' 
</>

Does JAVA pass somethings by reference automatically 
whereas in C++ you have to explicitly declare this ?

If so this might explain things as there seems to be a LOT 
of information being passed on the stack in GEOS which 
doesn't necessarily need to be.

Norman




From mbdavis at VividSolutions.com  Tue Nov 12 11:57:34 2002
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] Pass by reference in Java and C++
Message-ID: <5A94289A9268514C8D6C0F1FF44BA0270FD3E0@venus.VividSolutions.com>

You got it right, Norman - in Java *everything* is passed by reference, whereas in C++ you get a choice.    I think when Yury did the initial translation of the code he stuck very close to the Java way of doing things, partly because it's hard to know without understanding the code fairly well whether passing-by-reference is needed or not (i.e. sometimes you really do want an alias to a shared object).

It would certainly help for anyone who has time to look at the code and see if there's obvious wins to be had by switching to pass-by-value in particular cases.

Martin Davis, Senior Technical Specialist
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


> -----Original Message-----
> From: Norman Vine [mailto:nhv@cape.com]
> Sent: Monday, November 11, 2002 8:57 AM
> To: geos-devel@geos.refractions.net
> Subject: Re: [geos-devel] Performance of GEOS compared to JTS (Report,
> Nov. 8)
> 
> 
> Martin Davis
> > 
> > I would still expect that the C++ code should be absolutely 
> faster than Java - 
> 
> Me too 
> 
> > so we still have some sleuthing to do.
> 
> < disclaimer> 
>   I know next to nothing about the JAVA 'machine' 
> </>
> 
> Does JAVA pass somethings by reference automatically 
> whereas in C++ you have to explicitly declare this ?
> 
> If so this might explain things as there seems to be a LOT 
> of information being passed on the stack in GEOS which 
> doesn't necessarily need to be.
> 
> Norman
> 
> 
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
> 


From dblasby at refractions.net  Tue Nov 12 13:25:53 2002
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] Pass by reference in Java and C++
References: <5A94289A9268514C8D6C0F1FF44BA0270FD3E0@venus.VividSolutions.com>
Message-ID: <3DD147B1.DD055D2A@refractions.net>

Martin Davis wrote:

> You got it right, Norman - in Java *everything* is passed by reference, whereas in C++ you get a choice.    I think when Yury did the initial translation of the code he stuck very close to the Java way of doing things, partly because it's hard to know without understanding the code fairly well whether passing-by-reference is needed or not (i.e. sometimes you really do want an alias to a shared object).
>
> It would certainly help for anyone who has time to look at the code and see if there's obvious wins to be had by switching to pass-by-value in particular cases.

I'm just starting playing around with creating GEOS "Geometry" objects.  Here's a little snippet of code:

Geometry createGEOSPoint(POINT3D *pt)
{
 Coordinate *c = new Coordinate(pt->x, pt->y, pt->z);

 return geomFactory->createPoint(*c);
}


This causes the Coordinate to be copied (to the createPoint() constructor), and the resulting Geometry to be copied out of the function.  It would be much more efficient to:

Geometry *createGEOSPoint(POINT3D *pt)
{
 Coordinate *c = new Coordinate(pt->x, pt->y, pt->z);

 return geomFactory->createPoint(c);
}

NOTE:   Geometry *createPoint( *Coordinate)
       =>  geomFactory->createPoint() returning a Geometry* and taking a Coordinate*.

Or am I missing something?



Also, the CoordinateList should have a constructor like:

cl = new CoordinateList3D(POINT3D* points, int npoints);
cl = new CoordinateList2D(POINT2D* points, int npoints);

Where POINT3D is a simple {double x,y,z} struct, and POINT2D is a simple {double x, double y}.

I dont really want to take my list of 100,000 points, convert them all to Coordindates, then make a CoordinateList, then a LinearRing, copy the linearRing over to the Polygon creator, then make a copy of the polygon to actually return.  Seems like an lot of work.

Is this the way to actually construct Geometry objects?  Or am I missing something?


dave
ps. For the C/C++ non-programmers - Geometry* means Pointer-to-Geometry.



From dblasby at refractions.net  Tue Nov 12 13:40:13 2002
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] Pass by reference in Java and C++
References: <5A94289A9268514C8D6C0F1FF44BA0270FD3E0@venus.VividSolutions.com> <3DD147B1.DD055D2A@refractions.net>
Message-ID: <3DD14B0D.AF660D38@refractions.net>

I also note that the WKTReader does return Geometry* objects.

dave



From dblasby at refractions.net  Tue Nov 12 14:38:12 2002
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] BUG
References: <5A94289A9268514C8D6C0F1FF44BA0270FD3E0@venus.VividSolutions.com> <3DD147B1.DD055D2A@refractions.net> <3DD14B0D.AF660D38@refractions.net>
Message-ID: <3DD158A4.85D800D2@refractions.net>

This works:

char * f()
{
   WKTReader *r = new WKTReader(GeometryFactory(PrecisionModel(),10));
   Geometry *g;
   string s,ss;
   char *cc;


    s = "POINT(0 0)";

    g =r->read(s);
    ss= g->toString();
    cc= (char *)  ss.c_str();
    return cc;

}

But this doesnt :

char *f()
{
 Coordinate *c = new Coordinate(0,0,0);
 Geometry result;
 string s,ss;
 geomFactory = new GeometryFactory();

 result =  geomFactory->createPoint(*c);  // this works

 s = result.toString();  // crashes here
}

Here's a test program:


#include <stdio.h>

#include <string>
#include <iostream>
#include <fstream>
#include "util.h"
#include "graph.h"
#include "io.h"
#include "opRelate.h"


int main(int argc, char** argv)
{
   Coordinate *c = new Coordinate(0,0,0);
   Geometry result;
   string s,ss;
   GeometryFactory   * geomFactory = new GeometryFactory();

     cout << "make point\n";
     result =  geomFactory->createPoint(*c);  // this works

     cout << "to string\n";
     s = result.toString();  // crashes here

     cout << "done\n";
}

It appears to die in the WKTWriter ...

dave
-------------- next part --------------
An HTML attachment was scrubbed...
URL: http://lists.osgeo.org/pipermail/geos-devel/attachments/20021112/732185a6/attachment.html
From mbdavis at VividSolutions.com  Tue Nov 12 14:57:52 2002
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] Pass by reference in Java and C++
Message-ID: <5A94289A9268514C8D6C0F1FF44BA02701DD52@venus.VividSolutions.com>

Dave has good points here.  Factory methods should do as little copying as possible.  They should expect to be handed object that they can "own", and they will return references to the constructed object which become the caller's responsibility to manage.  If copying is required to avoid unwanted aliasing, the caller is responsible for doing that.

Also, you're right about CoordinateList - the whole idea of having it is so that we can wrapper a client's own point format in a form that GEOS can work with. And after the CoordinateList has been constructed, it should never be copied again - the various factory methods should just wrapper it with the appropriate GEOS types (LinearRing, Polygon, etc).  Note that the destructor for a GEOS Geometry type should destroy any CoordinateList objects that it owns.

Dave, note that it's the caller's responsibility to make his own CoordinateList subtypes to wrapper whatever point format he happens to use.

I think now that we have okay performance we'd better focus on getting the API semantics correct, since they are going to become legacy very quickly.

Martin Davis, Senior Technical Specialist
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


> -----Original Message-----
> From: David Blasby [mailto:dblasby@refractions.net]
> Sent: Tuesday, November 12, 2002 10:26 AM
> To: geos-devel@geos.refractions.net
> Subject: Re: [geos-devel] Pass by reference in Java and C++
> 
> 
> Martin Davis wrote:
> 
> > You got it right, Norman - in Java *everything* is passed 
> by reference, whereas in C++ you get a choice.    I think 
> when Yury did the initial translation of the code he stuck 
> very close to the Java way of doing things, partly because 
> it's hard to know without understanding the code fairly well 
> whether passing-by-reference is needed or not (i.e. sometimes 
> you really do want an alias to a shared object).
> >
> > It would certainly help for anyone who has time to look at 
> the code and see if there's obvious wins to be had by 
> switching to pass-by-value in particular cases.
> 
> I'm just starting playing around with creating GEOS 
> "Geometry" objects.  Here's a little snippet of code:
> 
> Geometry createGEOSPoint(POINT3D *pt)
> {
>  Coordinate *c = new Coordinate(pt->x, pt->y, pt->z);
> 
>  return geomFactory->createPoint(*c);
> }
> 
> 
> This causes the Coordinate to be copied (to the createPoint() 
> constructor), and the resulting Geometry to be copied out of 
> the function.  It would be much more efficient to:
> 
> Geometry *createGEOSPoint(POINT3D *pt)
> {
>  Coordinate *c = new Coordinate(pt->x, pt->y, pt->z);
> 
>  return geomFactory->createPoint(c);
> }
> 
> NOTE:   Geometry *createPoint( *Coordinate)
>        =>  geomFactory->createPoint() returning a Geometry* 
> and taking a Coordinate*.
> 
> Or am I missing something?
> 
> 
> 
> Also, the CoordinateList should have a constructor like:
> 
> cl = new CoordinateList3D(POINT3D* points, int npoints);
> cl = new CoordinateList2D(POINT2D* points, int npoints);
> 
> Where POINT3D is a simple {double x,y,z} struct, and POINT2D 
> is a simple {double x, double y}.
> 
> I dont really want to take my list of 100,000 points, convert 
> them all to Coordindates, then make a CoordinateList, then a 
> LinearRing, copy the linearRing over to the Polygon creator, 
> then make a copy of the polygon to actually return.  Seems 
> like an lot of work.
> 
> Is this the way to actually construct Geometry objects?  Or 
> am I missing something?
> 
> 
> dave
> ps. For the C/C++ non-programmers - Geometry* means 
> Pointer-to-Geometry.
> 
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
> 


From nhv at cape.com  Tue Nov 12 15:00:48 2002
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] Pass by reference in Java and C++
References: <5A94289A9268514C8D6C0F1FF44BA0270FD3E0@venus.VividSolutions.com> <3DD147B1.DD055D2A@refractions.net>
Message-ID: <0f0d01c28a86$32a2b550$473dba8c@sfdev3>

David Blasby writes:
> 
> I'm just starting playing around with creating GEOS "Geometry" objects.  Here's a little snippet of code:
> 
> Geometry createGEOSPoint(POINT3D *pt)
> {
>  Coordinate *c = new Coordinate(pt->x, pt->y, pt->z);
> 
>  return geomFactory->createPoint(*c);
> }
> 
> 
> This causes the Coordinate to be copied (to the createPoint() constructor), 
> and the resulting Geometry to be copied out of the function.  
> It would be much more efficient to:
> 
> Geometry *createGEOSPoint(POINT3D *pt)
> {
>  Coordinate *c = new Coordinate(pt->x, pt->y, pt->z);
> 
>  return geomFactory->createPoint(c);
> }
> 
> NOTE:   Geometry *createPoint( *Coordinate)
>        =>  geomFactory->createPoint() returning a Geometry* and taking a Coordinate*.
> 
> Or am I missing something?

Nope !

In fact since this is what GEOS does internally I am rather surprised that it is
only twice as slow as the original JAVA implementation :-)

FWIW - I think this is due to the 'literal' translation of the code from Java where
'everything' is automatically passed by reference.

GEOS probably wants to change to where everything is passed by reference
like JTS does,  I am not really sure what is the best way to start dong this though.

It's tempting to just start with a new geom.h that defines an interface that is
tuned for FAST 'C' manipulation

Norman





From dblasby at refractions.net  Tue Nov 12 15:39:47 2002
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] Pass by reference in Java and C++
References: <5A94289A9268514C8D6C0F1FF44BA02701DD52@venus.VividSolutions.com>
Message-ID: <3DD16713.B72FE037@refractions.net>

Yuri,


> Dave, note that it's the caller's responsibility to make his own CoordinateList subtypes to wrapper whatever point format he happens to use.

Perhaps you could provide a simple one for a simple {double x,y,z} structure.  I'm not sure exactly what to do, especially in terms of efficiently.  I think this is sufficient for most people's uses, and others could use it as a template.

dave



From ybychkov at direct.ca  Tue Nov 12 15:39:43 2002
From: ybychkov at direct.ca (Yury A. Bychkov)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] Pass by reference in Java and C++
References: <5A94289A9268514C8D6C0F1FF44BA02701DD52@venus.VividSolutions.com>
 <3DD16713.B72FE037@refractions.net>
Message-ID: <006801c28a8b$a2b20c60$b9354d18@yury>

Sure, I'll look into it.

Yury

----- Original Message -----
From: "David Blasby" <dblasby@refractions.net>
To: <geos-devel@geos.refractions.net>
Sent: Tuesday, November 12, 2002 12:39 PM
Subject: Re: [geos-devel] Pass by reference in Java and C++


> Yuri,
>
>
> > Dave, note that it's the caller's responsibility to make his own
CoordinateList subtypes to wrapper whatever point format he happens to use.
>
> Perhaps you could provide a simple one for a simple {double x,y,z} structure.
I'm not sure exactly what to do, especially in terms of efficiently.  I think
this is sufficient for most people's uses, and others could use it as a
template.
>
> dave
>
>
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
>
>




From dblasby at refractions.net  Tue Nov 12 15:50:11 2002
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] BUG: getGeometryType() returns "Geometry" instead of actual type
References: <5A94289A9268514C8D6C0F1FF44BA02701DD52@venus.VividSolutions.com>
	 <3DD16713.B72FE037@refractions.net> <006801c28a8b$a2b20c60$b9354d18@yury>
Message-ID: <3DD16983.37976EEA@refractions.net>

int main(int argc, char** argv)
{
 Coordinate *c = new Coordinate(0,0,0);
  Geometry result;
   string s,ss;
 GeometryFactory   * geomFactory = new GeometryFactory();

     result =  geomFactory->createPoint(*c);

      s = result.getGeometryType();   //### HERE

cout << s << "\n";
     cout << "done\n";
}

This prints out "Geometry", it should print out "POINT".

dave



From dblasby at refractions.net  Tue Nov 12 16:02:18 2002
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] BUG: getGeometryType() returns "Geometry" instead of 
 actual type
References: <5A94289A9268514C8D6C0F1FF44BA02701DD52@venus.VividSolutions.com>
		 <3DD16713.B72FE037@refractions.net> <006801c28a8b$a2b20c60$b9354d18@yury> <3DD16983.37976EEA@refractions.net>
Message-ID: <3DD16C5A.613DAE3E@refractions.net>

Actually, I think its the GeometryFactory constructor thats giving
problems.  This works:

void pp()
{
    WKTReader *r = new WKTReader(GeometryFactory(PrecisionModel(),10));
    Geometry *g;
    string s,ss;
    char *c;

    s = "POINT(0 0)";

    g =r->read(s);

    cout << g->toString();
cout << "\ntype: " << g->getGeometryType() << "\n";

}




From mbdavis at VividSolutions.com  Tue Nov 12 16:16:06 2002
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] Format for bug reports
Message-ID: <5A94289A9268514C8D6C0F1FF44BA02701DD53@venus.VividSolutions.com>

In order to make bug tracking easier, here's a format to use for bug reports:

- Subject line starts with "BUG:", followed by the bug "name" (a brief identifying description)
- Body of message starts with a short but complete description of the problem, followed by any code examples that illustrate the problem
- Each bug is submitted in its own message.  Nothing else is discussed in the message.

Bug fixers can reply with messages that have a subject line prefixed with "FIXED:" followed by the bug name

Martin Davis, Senior Technical Specialist
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com



From dblasby at refractions.net  Tue Nov 12 17:07:56 2002
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:04 2007
Subject: [geos-devel] test table
References: <5A94289A9268514C8D6C0F1FF44BA02701DD53@venus.VividSolutions.com>
Message-ID: <3DD17BBC.8CC21E44@refractions.net>

Here's conversion of theTestRelate*.xml files in the JTS 1.2 distribution as a postgis table.


CREATE TABLE "relate_test" (
    "g1" geometry,
    "g2" geometry,
    "result" text
);


there are 555 tests.

I'm working on a converter:

PostGIS geometry -> WKT -> GEOS WKT Parser -> GEOS Geometry

until the GeometryFactory() methods are fixed.   Things are looking good now!


dave






From dblasby at refractions.net  Tue Nov 12 17:11:10 2002
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] test table
References: <5A94289A9268514C8D6C0F1FF44BA02701DD53@venus.VividSolutions.com> <3DD17BBC.8CC21E44@refractions.net>
Message-ID: <3DD17C7E.2017E3A0@refractions.net>

This time it actually attached...

dave
-------------- next part --------------
--
-- Selected TOC Entries:
--

--
-- TOC Entry ID 2 (OID 69760603)
--
-- Name: relate_test Type: TABLE Owner: dblasby
--

CREATE TABLE "relate_test" (
	"g1" geometry,
	"g2" geometry,
	"result" text
);

--
-- Data for TOC Entry ID 3 (OID 69760603)
--
-- Name: relate_test Type: TABLE DATA Owner: dblasby
--


COPY "relate_test" FROM stdin;
SRID=-1;POLYGON((0 0,80 0,80 80,0 80,0 0))	SRID=-1;POLYGON((100 200,100 140,180 140,180 200,100 200))	FF2FF1212
SRID=-1;POLYGON((0 0,140 0,140 140,0 140,0 0))	SRID=-1;POLYGON((140 0,0 0,0 140,140 140,140 0))	2FFF1FFF2
SRID=-1;POLYGON((40 60,360 60,360 300,40 300,40 60))	SRID=-1;POLYGON((120 100,280 100,280 240,120 240,120 100))	212FF1FF2
SRID=-1;POLYGON((40 60,420 60,420 320,40 320,40 60),(200 140,160 220,260 200,200 140))	SRID=-1;POLYGON((80 100,360 100,360 280,80 280,80 100))	2121F12F2
SRID=-1;POLYGON((0 280,0 0,260 0,260 280,0 280),(220 240,40 240,40 40,220 40,220 240))	SRID=-1;POLYGON((20 260,240 260,240 20,20 20,20 260),(160 180,80 180,120 120,160 180))	2121F1212
SRID=-1;POLYGON((60 80,200 80,200 220,60 220,60 80))	SRID=-1;POLYGON((120 140,260 140,260 260,120 260,120 140))	212101212
SRID=-1;POLYGON((60 220,220 220,140 140,60 220))	SRID=-1;POLYGON((100 180,180 180,180 100,100 100,100 180))	212101212
SRID=-1;POLYGON((40 40,180 40,180 180,40 180,40 40))	SRID=-1;POLYGON((180 40,40 180,160 280,300 140,180 40))	212101212
SRID=-1;POLYGON((100 60,140 100,100 140,60 100,100 60))	SRID=-1;MULTIPOLYGON(((80 40,120 40,120 80,80 80,80 40)),((120 80,160 80,160 120,120 120,120 80)),((80 120,120 120,120 160,80 160,80 120)),((40 80,80 80,80 120,40 120,40 80)))	21210F212
SRID=-1;POLYGON((40 280,200 280,200 100,40 100,40 280),(100 220,120 220,120 200,100 180,100 220))	SRID=-1;POLYGON((40 280,180 260,180 120,60 120,40 280))	2121012F2
SRID=-1;POLYGON((0 200,0 0,200 0,200 200,0 200),(20 180,130 180,130 30,20 30,20 180))	SRID=-1;POLYGON((60 90,130 90,130 30,60 30,60 90))	FF2F11212
SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150),(170 120,330 120,260 50,100 50,170 120))	SRID=-1;POLYGON((270 90,200 50,150 80,210 120,270 90))	FF2F01212
SRID=-1;POLYGON((100 60,140 100,100 140,60 100,100 60))	SRID=-1;MULTIPOLYGON(((80 40,120 40,120 80,80 80,80 40)),((120 80,160 80,160 120,120 120,120 80)),((80 120,120 120,120 160,80 160,80 120)),((40 80,80 80,80 120,40 120,40 80)))	21210F212
SRID=-1;LINESTRING(100 120,100 240)	SRID=-1;POLYGON((40 60,160 60,160 180,40 180,40 60))	1010F0212
SRID=-1;LINESTRING(80 80,140 140,200 200)	SRID=-1;POLYGON((40 40,140 40,140 140,40 140,40 40))	1010F0212
SRID=-1;LINESTRING(70 50,70 150)	SRID=-1;MULTIPOLYGON(((0 0,0 100,140 100,140 0,0 0)),((20 170,70 100,130 170,20 170)))	10F0FF212
SRID=-1;LINESTRING(60 160,150 70)	SRID=-1;POLYGON((190 190,360 20,20 20,190 190),(110 110,250 100,140 30,110 110))	F01FF0212
SRID=-1;LINESTRING(60 160,150 70)	SRID=-1;POLYGON((190 190,360 20,20 20,190 190),(111 110,250 100,140 30,111 110))	101FF0212
SRID=-1;LINESTRING(80 110,170 110)	SRID=-1;POLYGON((20 200,20 20,240 20,240 200,20 200),(130 110,60 40,60 180,130 110),(130 180,130 40,200 110,130 180))	F01FF0212
SRID=-1;LINESTRING(80 110,170 110)	SRID=-1;POLYGON((20 200,20 20,240 20,240 200,20 200),(130 110,60 40,60 180,130 110),(130 180,131 40,200 110,130 180))	101FF0212
SRID=-1;LINESTRING(160 70,320 230)	SRID=-1;MULTIPOLYGON(((140 110,260 110,170 20,50 20,140 110)),((300 270,420 270,340 190,220 190,300 270)))	1010FF212
SRID=-1;LINESTRING(100 140,100 40)	SRID=-1;MULTIPOLYGON(((20 80,180 79,100 0,20 80)),((20 160,180 160,100 80,20 160)))	1010FF212
SRID=-1;LINESTRING(100 140,100 40)	SRID=-1;MULTIPOLYGON(((20 80,180 80,100 0,20 80)),((20 160,180 160,100 80,20 160)))	10F0FF212
SRID=-1;LINESTRING(110 60,20 150,200 150,110 60)	SRID=-1;POLYGON((20 20,200 20,110 110,20 20))	101FFF212
SRID=-1;LINESTRING(0 0,0 50,50 50,50 0,0 0)	SRID=-1;MULTILINESTRING((0 0,0 50),(0 50,50 50),(50 50,50 0),(50 0,0 0))	1FFFFFFF2
SRID=-1;LINESTRING(40 180,140 180)	SRID=-1;MULTIPOLYGON(((20 320,180 320,180 180,20 180,20 320)),((20 180,20 80,180 80,180 180,20 180)))	1FF0FF212
SRID=-1;LINESTRING(40 180,140 180)	SRID=-1;MULTIPOLYGON(((20 320,180 320,180 180,20 180,20 320)),((60 180,60 80,180 80,180 180,60 180)))	11F00F212
SRID=-1;LINESTRING(0 0,60 0,60 60,60 0,120 0)	SRID=-1;MULTILINESTRING((0 0,60 0),(60 0,120 0),(60 0,60 60))	10FF0FFF2
SRID=-1;LINESTRING(60 0,20 80,100 80,80 120,40 140)	SRID=-1;LINESTRING(140 300,220 160,260 200,240 260)	FF1FF0102
SRID=-1;LINESTRING(60 0,20 80,100 80,80 120,40 140)	SRID=-1;LINESTRING(60 40,140 40,140 160,0 160)	FF1FF0102
SRID=-1;LINESTRING(60 0,20 80,100 80,80 120,40 140)	SRID=-1;LINESTRING(140 280,240 280,240 180,140 180,140 280)	FF1FF01F2
SRID=-1;LINESTRING(140 0,0 0,40 60,0 120,60 200,220 160,220 40)	SRID=-1;LINESTRING(80 140,180 100,160 40,100 40,60 100,80 140)	FF1FF01F2
SRID=-1;LINESTRING(20 20,80 80)	SRID=-1;LINESTRING(20 20,80 80)	1FFF0FFF2
SRID=-1;LINESTRING(40 40,160 160,200 60,60 140)	SRID=-1;LINESTRING(40 40,160 160,200 60,60 140)	1FFF0FFF2
SRID=-1;LINESTRING(40 40,200 40)	SRID=-1;LINESTRING(200 40,140 40,40 40)	1FFF0FFF2
SRID=-1;LINESTRING(0 0,110 0,60 0)	SRID=-1;LINESTRING(0 0,110 0)	10F00FFF2
SRID=-1;LINESTRING(0 0,0 50,50 50,50 0,0 0)	SRID=-1;MULTILINESTRING((0 0,0 50),(0 50,50 50),(50 50,50 0),(50 0,0 0))	1FFFFFFF2
SRID=-1;LINESTRING(0 0,80 0,80 60,80 0,170 0)	SRID=-1;MULTILINESTRING((0 0,170 0),(80 0,80 60))	10FF0FFF2
SRID=-1;LINESTRING(80 100,180 200)	SRID=-1;LINESTRING(80 180,180 120)	0F1FF0102
SRID=-1;LINESTRING(40 40,100 100,160 160)	SRID=-1;LINESTRING(160 60,100 100,60 140)	0F1FF0102
SRID=-1;LINESTRING(40 40,100 100,180 100,180 180,100 180,100 100)	SRID=-1;LINESTRING(140 60,60 140)	FF10F0102
SRID=-1;LINESTRING(40 40,180 180,100 180,100 100)	SRID=-1;LINESTRING(140 60,60 140)	FF10F0102
SRID=-1;LINESTRING(20 110,200 110)	SRID=-1;LINESTRING(200 200,20 20,200 20,110 110,20 200,110 200,110 110)	F01FF0102
SRID=-1;LINESTRING(80 90,50 50,0 0)	SRID=-1;LINESTRING(0 0,100 100)	1F1F00102
SRID=-1;LINESTRING(40 140,240 140)	SRID=-1;LINESTRING(40 140,100 140,80 80,120 60,100 140,160 140,160 100,200 100,160 140,240 140)	1FFF0F1F2
SRID=-1;LINESTRING(20 20,100 20,20 20)	SRID=-1;LINESTRING(60 20,200 20)	101FFF102
SRID=-1;LINESTRING(40 60,180 60,180 140,100 140,100 60,220 60,220 180,80 180,80 60,280 60)	SRID=-1;LINESTRING(140 60,180 60,220 60,260 60)	101FF0FF2
SRID=-1;POINT(20 20)	SRID=-1;POLYGON((60 120,60 40,160 40,160 120,60 120))	FF0FFF212
SRID=-1;MULTIPOINT(0 20,40 20)	SRID=-1;POLYGON((20 40,20 0,60 0,60 40,20 40))	0F0FFF212
SRID=-1;MULTIPOINT(0 20,20 20)	SRID=-1;POLYGON((20 40,20 0,60 0,60 40,20 40))	F00FFF212
SRID=-1;MULTIPOINT(20 20,40 20)	SRID=-1;POLYGON((20 40,20 0,60 0,60 40,20 40))	00FFFF212
SRID=-1;MULTIPOINT(80 260,140 260,180 260)	SRID=-1;POLYGON((40 320,140 320,140 200,40 200,40 320))	000FFF212
SRID=-1;POINT(40 40)	SRID=-1;MULTIPOLYGON(((0 40,0 0,40 0,40 40,0 40)),((40 80,40 40,80 40,80 80,40 80)))	F0FFFF212
SRID=-1;POINT(60 120)	SRID=-1;LINESTRING(40 40,120 120,200 120)	FF0FFF102
SRID=-1;POINT(40 40)	SRID=-1;LINESTRING(40 40,100 100,160 100)	F0FFFF102
SRID=-1;POINT(60 60)	SRID=-1;LINESTRING(40 40,100 100)	0FFFFF102
SRID=-1;MULTIPOINT(40 40,100 40)	SRID=-1;LINESTRING(40 40,80 80)	F00FFF102
SRID=-1;MULTIPOINT(40 40,60 60)	SRID=-1;LINESTRING(40 40,80 80)	00FFFF102
SRID=-1;MULTIPOINT(60 60,100 100)	SRID=-1;LINESTRING(40 40,80 80)	0F0FFF102
SRID=-1;MULTIPOINT(60 60,100 100)	SRID=-1;LINESTRING(40 40,80 80)	0F0FFF102
SRID=-1;MULTIPOINT(60 60,100 100)	SRID=-1;LINESTRING(40 40,60 60,80 80)	0F0FFF102
SRID=-1;POINT(20 20)	SRID=-1;POINT(20 20)	0FFFFFFF2
SRID=-1;POINT(20 20)	SRID=-1;POINT(20 30)	FF0FFF0F2
SRID=-1;MULTIPOINT(40 40,80 60,40 100)	SRID=-1;MULTIPOINT(40 40,80 60,120 100)	0F0FFF0F2
SRID=-1;MULTIPOINT(40 40,80 60,120 100)	SRID=-1;MULTIPOINT(40 40,80 60,120 100)	0FFFFFFF2
SRID=-1;POLYGON((100 100,100 200,200 200,200 100,100 100))	SRID=-1;POLYGON((100 100,1e+15 110,1e+15 100,100 100))	212111212
SRID=-1;POLYGON((120 100,120 200,200 200,200 100,120 100))	SRID=-1;POLYGON((100 100,1e+15 110,1e+15 100,100 100))	212111212
SRID=-1;POLYGON((20 20,20 100,120 100,140 20,20 20))	SRID=-1;POLYGON((20 20,20 100,120 100,140 20,20 20))	2FFF1FFF2
SRID=-1;POLYGON((20 20,20 100,120 100,140 20,20 20))	SRID=-1;POLYGON((20 20,140 20,120 100,20 100,20 20))	2FFF1FFF2
SRID=-1;POLYGON((20 20,20 100,120 100,140 20,20 20))	SRID=-1;POLYGON((120 100,140 20,20 20,20 100,120 100))	2FFF1FFF2
SRID=-1;POLYGON((20 20,20 100,120 100,140 20,20 20))	SRID=-1;POLYGON((20 100,60 100,120 100,140 20,80 20,20 20,20 100))	2FFF1FFF2
SRID=-1;POLYGON((0 0,80 0,80 80,0 80,0 0))	SRID=-1;POLYGON((100 200,100 140,180 140,180 200,100 200))	FF2FF1212
SRID=-1;POLYGON((140 120,160 20,20 20,20 120,140 120))	SRID=-1;POLYGON((140 120,140 200,240 200,240 120,140 120))	FF2F01212
SRID=-1;POLYGON((140 120,160 20,20 20,20 120,140 120))	SRID=-1;POLYGON((80 180,140 260,260 200,200 60,80 180))	FF2F01212
SRID=-1;POLYGON((140 120,160 20,20 20,20 120,140 120))	SRID=-1;POLYGON((240 80,140 120,180 240,280 200,240 80))	FF2F01212
SRID=-1;POLYGON((140 160,20 20,270 20,150 160,230 40,60 40,140 160))	SRID=-1;POLYGON((140 40,180 80,120 100,140 40))	FF2F01212
SRID=-1;POLYGON((140 160,20 20,270 20,150 160,230 40,60 40,140 160))	SRID=-1;POLYGON((120 100,180 80,130 40,120 100))	FF2F01212
SRID=-1;POLYGON((20 20,180 20,140 140,20 140,20 20))	SRID=-1;POLYGON((180 100,80 200,180 280,260 200,180 100))	FF2F01212
SRID=-1;POLYGON((140 120,160 20,20 20,20 120,140 120))	SRID=-1;POLYGON((140 140,20 120,0 220,120 240,140 140))	FF2F01212
SRID=-1;POLYGON((160 200,210 70,120 70,160 200))	SRID=-1;POLYGON((160 200,260 40,70 40,160 200,20 20,310 20,160 200))	FF2F01212
SRID=-1;POLYGON((110 140,200 70,200 160,110 140))	SRID=-1;POLYGON((110 140,110 50,60 50,60 90,160 190,20 110,20 20,200 20,110 140))	FF2F01212
SRID=-1;POLYGON((20 120,20 20,260 20,260 120,200 40,140 120,80 40,20 120))	SRID=-1;POLYGON((20 120,20 240,260 240,260 120,200 200,140 120,80 200,20 120))	FF2F01212
SRID=-1;POLYGON((20 120,20 20,260 20,260 120,180 40,140 120,100 40,20 120))	SRID=-1;POLYGON((20 120,300 120,140 240,20 120))	FF2F01212
SRID=-1;POLYGON((20 20,20 300,280 300,280 260,220 260,60 100,60 60,280 60,280 20,20 20))	SRID=-1;POLYGON((100 140,160 80,280 180,200 240,220 160,160 200,180 120,100 140))	FF2F01212
SRID=-1;POLYGON((20 20,20 300,280 300,280 260,220 260,60 100,60 60,280 60,280 20,20 20))	SRID=-1;POLYGON((260 200,180 80,120 160,200 160,180 220,260 200))	FF2F01212
SRID=-1;POLYGON((20 20,280 20,280 140,220 60,140 140,80 60,20 140,20 20))	SRID=-1;POLYGON((0 140,300 140,140 240,0 140))	FF2F01212
SRID=-1;POLYGON((20 20,280 20,280 140,220 60,140 140,80 60,20 140,20 20))	SRID=-1;POLYGON((20 240,20 140,320 140,180 240,20 240))	FF2F01212
SRID=-1;POLYGON((20 20,280 20,280 140,220 60,140 140,80 60,20 140,20 20))	SRID=-1;POLYGON((20 240,20 140,80 180,140 140,220 180,280 140,280 240,20 240))	FF2F01212
SRID=-1;POLYGON((120 120,180 60,20 20,20 120,120 120))	SRID=-1;POLYGON((120 120,220 20,280 20,240 160,120 120))	FF2F11212
SRID=-1;POLYGON((140 120,160 20,20 20,20 120,140 120))	SRID=-1;POLYGON((140 120,160 20,260 120,220 200,140 120))	FF2F11212
SRID=-1;POLYGON((20 140,120 40,20 40,20 140))	SRID=-1;POLYGON((190 140,190 20,140 20,20 140,190 140))	FF2F11212
SRID=-1;POLYGON((120 120,180 60,20 20,20 120,120 120))	SRID=-1;POLYGON((300 20,220 20,120 120,260 160,300 20))	FF2F11212
SRID=-1;POLYGON((140 120,160 20,20 20,20 120,140 120))	SRID=-1;POLYGON((140 120,240 160,280 60,160 20,140 120))	FF2F11212
SRID=-1;POLYGON((120 120,180 60,20 20,20 120,120 120))	SRID=-1;POLYGON((280 60,180 60,120 120,260 180,280 60))	FF2F11212
SRID=-1;POLYGON((140 120,160 20,20 20,20 120,140 120))	SRID=-1;POLYGON((120 200,120 120,40 120,40 200,120 200))	FF2F11212
SRID=-1;POLYGON((140 120,160 20,20 20,20 120,140 120))	SRID=-1;POLYGON((160 220,140 120,60 120,40 220,160 220))	FF2F11212
SRID=-1;POLYGON((140 120,160 20,20 20,20 120,140 120))	SRID=-1;POLYGON((140 120,20 120,20 220,140 220,140 120))	FF2F11212
SRID=-1;POLYGON((120 120,180 60,20 20,20 120,120 120))	SRID=-1;POLYGON((320 20,220 20,80 160,240 140,320 20))	FF2F11212
SRID=-1;POLYGON((20 20,20 180,220 180,220 20,20 20))	SRID=-1;POLYGON((60 40,60 140,180 140,180 40,60 40))	212FF1FF2
SRID=-1;POLYGON((20 20,20 180,220 180,220 20,20 20))	SRID=-1;POLYGON((20 20,80 140,160 60,20 20))	212F01FF2
SRID=-1;POLYGON((20 20,20 180,220 180,220 20,20 20))	SRID=-1;POLYGON((160 60,20 20,100 140,160 60))	212F01FF2
SRID=-1;POLYGON((20 20,20 180,220 180,220 20,20 20))	SRID=-1;POLYGON((20 100,140 160,160 40,20 100))	212F01FF2
SRID=-1;POLYGON((20 20,20 180,220 180,220 20,20 20))	SRID=-1;POLYGON((160 40,20 100,160 160,160 40))	212F01FF2
SRID=-1;POLYGON((20 20,20 180,220 180,220 20,20 20))	SRID=-1;POLYGON((20 180,180 120,80 40,20 180))	212F01FF2
SRID=-1;POLYGON((20 20,20 180,220 180,220 20,20 20))	SRID=-1;POLYGON((180 120,100 40,20 180,180 120))	212F01FF2
SRID=-1;POLYGON((20 20,20 180,220 180,220 20,20 20))	SRID=-1;POLYGON((20 20,140 40,140 120,20 160,80 80,20 20))	212F01FF2
SRID=-1;POLYGON((20 20,20 180,220 180,220 20,20 20))	SRID=-1;POLYGON((20 20,140 40,140 140,20 180,80 100,20 20))	212F01FF2
SRID=-1;POLYGON((20 20,20 180,220 180,220 20,20 20))	SRID=-1;POLYGON((40 180,60 100,180 100,200 180,120 120,40 180))	212F01FF2
SRID=-1;POLYGON((20 20,20 180,220 180,220 20,20 20))	SRID=-1;POLYGON((20 180,60 80,180 80,220 180,120 120,20 180))	212F01FF2
SRID=-1;POLYGON((20 20,20 180,220 180,220 20,20 20))	SRID=-1;POLYGON((40 60,20 180,100 100,140 180,160 120,220 100,140 40,40 60))	212F01FF2
SRID=-1;POLYGON((20 20,20 180,220 180,220 20,20 20))	SRID=-1;POLYGON((60 100,180 100,220 180,120 140,20 180,60 100))	212F01FF2
SRID=-1;POLYGON((20 20,20 180,220 180,220 20,20 20))	SRID=-1;POLYGON((20 20,20 140,120 120,120 40,20 20))	212F11FF2
SRID=-1;POLYGON((20 20,20 180,220 180,220 20,20 20))	SRID=-1;POLYGON((20 20,20 180,140 140,140 60,20 20))	212F11FF2
SRID=-1;POLYGON((20 20,20 180,220 180,220 20,20 20))	SRID=-1;POLYGON((20 20,120 40,120 120,20 140,20 20))	212F11FF2
SRID=-1;POLYGON((20 20,20 180,220 180,220 20,20 20))	SRID=-1;POLYGON((120 40,20 20,20 140,120 120,120 40))	212F11FF2
SRID=-1;POLYGON((20 20,20 180,220 180,220 20,20 20))	SRID=-1;POLYGON((20 20,140 60,140 140,20 180,20 20))	212F11FF2
SRID=-1;POLYGON((20 20,20 180,220 180,220 20,20 20))	SRID=-1;POLYGON((140 60,20 20,20 180,140 140,140 60))	212F11FF2
SRID=-1;POLYGON((20 20,20 180,220 180,220 20,20 20))	SRID=-1;POLYGON((20 20,60 120,140 120,180 20,20 20))	212F11FF2
SRID=-1;POLYGON((20 20,20 180,220 180,220 20,20 20))	SRID=-1;POLYGON((20 40,120 40,120 120,20 140,20 40))	212F11FF2
SRID=-1;POLYGON((20 20,20 180,220 180,220 20,20 20))	SRID=-1;POLYGON((20 20,20 180,60 120,100 180,140 120,220 180,200 120,140 60,20 20))	212F11FF2
SRID=-1;POLYGON((150 150,330 150,250 70,70 70,150 150))	SRID=-1;POLYGON((150 150,270 150,140 20,20 20,150 150))	212111212
SRID=-1;POLYGON((150 150,270 150,330 150,250 70,190 70,70 70,150 150))	SRID=-1;POLYGON((150 150,270 150,190 70,140 20,20 20,70 70,150 150))	212111212
SRID=-1;POLYGON((20 20,60 50,20 40,60 70,20 60,60 90,20 90,70 110,20 130,80 130,20 150,80 160,20 170,80 180,20 200,80 200,30 240,80 220,50 260,100 220,100 260,120 220,130 260,140 220,150 280,150 190,160 280,170 190,180 280,190 190,200 280,210 190,220 280,230 190,240 260,250 230,260 260,260 220,290 270,290 220,330 260,300 210,340 240,290 180,340 210,290 170,350 170,240 150,350 150,240 140,350 130,240 120,350 120,240 110,350 110,240 100,350 100,240 90,350 90,240 80,350 80,300 70,340 60,290 60,340 40,300 50,340 20,270 60,310 20,250 60,270 20,230 60,240 20,210 60,210 20,190 70,190 20,180 90,170 20,160 90,150 20,140 90,130 20,120 90,110 20,100 90,100 20,90 60,80 20,70 40,20 20))	SRID=-1;POLYGON((190 140,140 130,200 160,130 150,210 170,130 170,210 180,120 190,220 200,120 200,250 210,120 210,250 220,120 220,250 230,120 240,230 240,120 250,240 260,120 260,240 270,120 270,270 290,120 290,230 300,150 310,250 310,180 320,250 320,200 360,260 330,240 360,280 320,290 370,290 320,320 360,310 320,360 360,310 310,380 340,310 290,390 330,310 280,410 310,310 270,420 280,310 260,430 250,300 250,440 240,300 240,450 230,280 220,440 220,280 210,440 210,300 200,430 190,300 190,440 180,330 180,430 150,320 180,420 130,300 180,410 120,280 180,400 110,280 170,390 90,280 160,400 70,270 160,450 30,260 160,420 30,250 160,390 30,240 160,370 30,230 160,360 30,230 150,330 50,240 130,330 30,230 130,310 30,220 130,280 30,230 100,270 40,220 110,250 30,210 130,240 30,210 100,220 40,200 90,200 20,190 100,180 30,20 20,180 40,20 30,180 50,20 50,180 60,30 60,180 70,20 70,170 80,80 80,170 90,20 80,180 100,40 100,200 110,60 110,200 120,120 120,190 140))	212101212
SRID=-1;POLYGON((70 150,20 160,110 160,20 180,100 200,20 200,190 210,20 210,160 220,20 220,150 230,60 240,180 250,20 260,170 260,60 270,160 270,100 310,170 280,200 260,180 230,210 260,130 330,230 250,210 290,240 250,230 210,260 300,250 230,270 300,270 240,300 340,280 250,320 330,290 250,340 350,290 240,350 360,270 190,350 340,290 200,350 330,300 190,360 320,310 190,360 300,320 200,360 280,330 200,360 260,340 200,370 260,340 180,390 290,340 170,400 260,350 170,400 250,350 160,410 240,350 150,400 170,350 140,310 170,340 140,270 180,330 140,260 170,310 140,240 170,290 140,200 190,270 140,180 190,260 140,170 190,260 130,170 180,250 130,170 170,240 120,170 160,210 120,170 150,210 110,340 130,230 110,420 140,220 100,410 130,220 90,400 120,220 80,390 110,220 70,420 110,240 70,420 100,260 70,420 90,280 70,430 80,230 60,430 60,270 50,450 40,210 50,370 40,260 40,460 30,160 40,210 60,200 110,190 60,190 120,170 50,180 130,150 30,170 130,140 20,160 120,130 20,160 150,120 20,160 170,110 20,160 190,100 20,150 190,90 20,140 180,80 20,120 140,70 20,120 150,60 20,110 150,50 20,100 140,50 30,90 130,40 30,80 120,30 30,80 130,30 40,80 140,20 40,70 140,40 90,60 130,20 90,60 140,20 130,70 150))	SRID=-1;POLYGON((190 140,140 130,200 160,130 150,210 170,130 170,210 180,120 190,220 200,120 200,250 210,120 210,250 220,120 220,250 230,120 240,230 240,120 250,240 260,120 260,240 270,120 270,270 290,120 290,230 300,150 310,250 310,180 320,250 320,200 360,260 330,240 360,280 320,290 370,290 320,320 360,310 320,360 360,310 310,380 340,310 290,390 330,310 280,410 310,310 270,420 280,310 260,430 250,300 250,440 240,300 240,450 230,280 220,440 220,280 210,440 210,300 200,430 190,300 190,440 180,330 180,430 150,320 180,420 130,300 180,410 120,280 180,400 110,280 170,390 90,280 160,400 70,270 160,450 30,260 160,420 30,250 160,390 30,240 160,370 30,230 160,360 30,230 150,330 50,240 130,330 30,230 130,310 30,220 130,280 30,230 100,270 40,220 110,250 30,210 130,240 30,210 100,220 40,200 90,200 20,190 100,180 30,20 20,180 40,20 30,180 50,20 50,180 60,30 60,180 70,20 70,170 80,80 80,170 90,20 80,180 100,40 100,200 110,60 110,200 120,120 120,190 140))	212111212
SRID=-1;POLYGON((60 160,220 160,220 20,60 20,60 160))	SRID=-1;POLYGON((60 160,20 200,260 200,220 160,140 80,60 160))	212101212
SRID=-1;POLYGON((60 160,220 160,220 20,60 20,60 160))	SRID=-1;POLYGON((60 160,20 200,260 200,140 80,60 160))	212101212
SRID=-1;POLYGON((60 160,220 160,220 20,60 20,60 160))	SRID=-1;POLYGON((20 200,140 80,260 200,20 200))	212101212
SRID=-1;POLYGON((60 160,220 160,220 20,60 20,60 160))	SRID=-1;POLYGON((20 200,60 160,140 80,220 160,260 200,20 200))	212101212
SRID=-1;POLYGON((60 160,220 160,220 20,60 20,60 160))	SRID=-1;POLYGON((20 200,60 160,140 80,260 200,20 200))	212101212
SRID=-1;POLYGON((0 0,0 200,200 200,200 0,0 0))	SRID=-1;POLYGON((100 100,1000000 110,10000000 100,100 100))	212101212
SRID=-1;POLYGON((100 0,100 200,200 200,200 0,100 0))	SRID=-1;POLYGON((100 100,1000000 110,10000000 100,100 100))	212101212
SRID=-1;POLYGON((120 0,120 200,200 200,200 0,120 0))	SRID=-1;POLYGON((100 100,1000000 110,10000000 100,100 100))	212101212
SRID=-1;POLYGON((0 0,0 200,110 200,110 0,0 0))	SRID=-1;POLYGON((100 100,1000000 110,10000000 100,100 100))	212101212
SRID=-1;POLYGON((100 100,100 200,200 200,200 100,100 100))	SRID=-1;POLYGON((100 100,2100 110,2100 100,100 100))	212111212
SRID=-1;POLYGON((100 100,100 200,200 200,200 100,100 100))	SRID=-1;POLYGON((100 100,2101 110,2101 100,100 100))	212111212
SRID=-1;POLYGON((100 100,200 200,200 100,100 100))	SRID=-1;POLYGON((100 100,2101 110,2101 100,100 100))	212111212
SRID=-1;POLYGON((100 100,100 200,200 200,200 100,100 100))	SRID=-1;POLYGON((100 100,1000000 110,1000000 100,100 100))	212111212
SRID=-1;POLYGON((120 100,120 200,200 200,200 100,120 100))	SRID=-1;POLYGON((100 100,500 110,500 100,100 100))	212111212
SRID=-1;POLYGON((120 100,120 200,200 200,200 100,120 100))	SRID=-1;POLYGON((100 100,501 110,501 100,100 100))	212111212
SRID=-1;POLYGON((120 100,130 200,200 200,200 100,120 100))	SRID=-1;POLYGON((100 100,501 110,501 100,100 100))	212111212
SRID=-1;POLYGON((120 100,17 200,200 200,200 100,120 100))	SRID=-1;POLYGON((100 100,501 110,501 100,100 100))	212111212
SRID=-1;POLYGON((120 100,120 200,200 200,200 100,120 100))	SRID=-1;POLYGON((100 100,1000000 110,1000000 100,100 100))	212111212
SRID=-1;POLYGON((101 99,101 1000000,102 1000000,101 99))	SRID=-1;POLYGON((100 100,1000000 110,1000000 100,100 100))	212101212
SRID=-1;POLYGON((100 100,200 101,200 100,100 100))	SRID=-1;POLYGON((100 100,2101 110,2101 100,100 100))	212111212
SRID=-1;POLYGON((16 319,150 39,25 302,160 20,265 20,127 317,16 319))	SRID=-1;POLYGON((10 307,22 307,153 34,22 34,10 307))	212101212
SRID=-1;POLYGON((160 200,210 70,120 70,160 200))	SRID=-1;POLYGON((160 200,310 20,20 20,160 200),(160 200,260 40,70 40,160 200))	FF2F01212
SRID=-1;POLYGON((170 120,240 100,260 50,190 70,170 120))	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150),(170 120,330 120,260 50,100 50,170 120))	FF2F01212
SRID=-1;POLYGON((270 90,200 50,150 80,210 120,270 90))	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150),(170 120,330 120,260 50,100 50,170 120))	FF2F01212
SRID=-1;POLYGON((170 120,260 100,240 60,150 80,170 120))	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150),(170 120,330 120,260 50,100 50,170 120))	FF2F01212
SRID=-1;POLYGON((220 120,270 80,200 60,160 100,220 120))	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150),(170 120,330 120,260 50,100 50,170 120))	FF2F01212
SRID=-1;POLYGON((260 50,180 70,180 110,260 90,260 50))	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150),(170 120,330 120,260 50,100 50,170 120))	FF2F01212
SRID=-1;POLYGON((230 110,290 80,190 60,140 90,230 110))	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150),(170 120,330 120,260 50,100 50,170 120))	FF2F01212
SRID=-1;POLYGON((170 120,330 120,260 50,100 50,170 120))	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150),(170 120,330 120,260 50,100 50,170 120))	FF2F1F212
SRID=-1;POLYGON((170 120,330 120,280 70,120 70,170 120))	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150),(170 120,330 120,260 50,100 50,170 120))	FF2F11212
SRID=-1;POLYGON((170 120,300 120,250 70,120 70,170 120))	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150),(170 120,330 120,260 50,100 50,170 120))	FF2F11212
SRID=-1;POLYGON((190 100,310 100,260 50,140 50,190 100))	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150),(170 120,330 120,260 50,100 50,170 120))	FF2F11212
SRID=-1;POLYGON((280 130,360 130,270 40,190 40,280 130))	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150),(170 120,250 120,180 50,100 50,170 120))	2FF1FF212
SRID=-1;POLYGON((220 80,180 40,80 40,170 130,270 130,230 90,300 90,250 30,280 30,390 140,150 140,40 30,230 30,280 80,220 80))	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150),(170 120,250 120,180 50,100 50,170 120))	2FF1FF212
SRID=-1;POLYGON((260 130,360 130,280 40,170 40,260 130))	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150),(170 120,250 120,180 50,100 50,170 120))	2FF11F212
SRID=-1;POLYGON((240 110,340 110,290 60,190 60,240 110))	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150),(170 120,250 120,180 50,100 50,170 120))	2FF11F212
SRID=-1;POLYGON((250 120,350 120,280 50,180 50,250 120))	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150),(170 120,250 120,180 50,100 50,170 120))	2FF11F212
SRID=-1;POLYGON((230 210,230 20,20 20,20 210,230 210),(120 180,50 50,200 50,120 180))	SRID=-1;POLYGON((230 210,230 20,20 20,20 210,230 210),(120 180,50 50,200 50,120 180))	2FFF1FFF2
SRID=-1;POLYGON((230 210,230 20,20 20,20 210,230 210),(140 40,40 40,40 170,140 40),(110 190,210 190,210 50,110 190))	SRID=-1;POLYGON((230 210,230 20,20 20,20 210,230 210),(140 40,40 40,40 170,140 40),(110 190,210 190,210 50,110 190))	2FFF1FFF2
SRID=-1;POLYGON((280 190,330 150,200 110,150 150,280 190))	SRID=-1;MULTIPOLYGON(((140 110,260 110,170 20,50 20,140 110)),((300 270,420 270,340 190,220 190,300 270)))	FF2F01212
SRID=-1;POLYGON((80 190,220 190,140 110,0 110,80 190))	SRID=-1;MULTIPOLYGON(((140 110,260 110,170 20,50 20,140 110)),((300 270,420 270,340 190,220 190,300 270)))	FF2F01212
SRID=-1;POLYGON((330 150,200 110,150 150,280 190,330 150))	SRID=-1;MULTIPOLYGON(((140 110,260 110,170 20,50 20,140 110)),((300 270,420 270,340 190,220 190,300 270)))	FF2F01212
SRID=-1;POLYGON((290 190,340 150,220 120,170 170,290 190))	SRID=-1;MULTIPOLYGON(((140 110,260 110,170 20,50 20,140 110)),((300 270,420 270,340 190,220 190,300 270)))	FF2F01212
SRID=-1;POLYGON((220 190,340 190,260 110,140 110,220 190))	SRID=-1;MULTIPOLYGON(((140 110,260 110,170 20,50 20,140 110)),((300 270,420 270,340 190,220 190,300 270)))	FF2F11212
SRID=-1;POLYGON((140 190,220 190,100 70,20 70,140 190))	SRID=-1;MULTIPOLYGON(((140 110,260 110,170 20,50 20,140 110)),((300 270,420 270,340 190,220 190,300 270)))	FF2F11212
SRID=-1;POLYGON((140 220,60 140,140 60,220 140,140 220))	SRID=-1;MULTIPOLYGON(((100 20,180 20,180 100,100 100,100 20)),((20 100,100 100,100 180,20 180,20 100)),((100 180,180 180,180 260,100 260,100 180)),((180 100,260 100,260 180,180 180,180 100)))	21210F212
SRID=-1;MULTIPOLYGON(((110 110,70 200,150 200,110 110)),((110 110,150 20,70 20,110 110)))	SRID=-1;MULTIPOLYGON(((110 110,160 160,210 110,160 60,110 110)),((110 110,60 60,10 110,60 160,110 110)))	FF2F01212
SRID=-1;MULTIPOLYGON(((110 110,70 200,150 200,110 110),(110 110,100 180,120 180,110 110)),((110 110,150 20,70 20,110 110),(110 110,120 40,100 40,110 110)))	SRID=-1;MULTIPOLYGON(((110 110,160 160,210 110,160 60,110 110),(110 110,160 130,160 90,110 110)),((110 110,60 60,10 110,60 160,110 110),(110 110,60 90,60 130,110 110)))	FF2F01212
SRID=-1;MULTIPOLYGON(((110 110,70 200,200 200,110 110),(110 110,100 180,120 180,110 110)),((110 110,200 20,70 20,110 110),(110 110,120 40,100 40,110 110)))	SRID=-1;MULTIPOLYGON(((110 110,160 160,210 110,160 60,110 110),(110 110,160 130,160 90,110 110)),((110 110,60 60,10 110,60 160,110 110),(110 110,60 90,60 130,110 110)))	FF2F11212
SRID=-1;MULTIPOLYGON(((110 110,20 200,200 200,110 110),(110 110,100 180,120 180,110 110)),((110 110,200 20,20 20,110 110),(110 110,120 40,100 40,110 110)))	SRID=-1;MULTIPOLYGON(((110 110,160 160,210 110,160 60,110 110),(110 110,160 130,160 90,110 110)),((110 110,60 60,10 110,60 160,110 110),(110 110,60 90,60 130,110 110)))	FF2F11212
SRID=-1;MULTIPOLYGON(((110 110,70 200,200 200,110 110),(110 110,100 180,120 180,110 110)),((110 110,200 20,70 20,110 110),(110 110,120 40,100 40,110 110)))	SRID=-1;MULTIPOLYGON(((110 110,160 160,210 110,160 60,110 110),(110 110,160 130,160 90,110 110)),((110 110,60 60,10 110,60 160,110 110),(110 110,60 90,60 130,110 110)))	FF2F11212
SRID=-1;MULTIPOLYGON(((110 110,70 200,200 200,110 110),(110 110,100 180,120 180,110 110)),((110 110,200 20,70 20,110 110),(110 110,120 40,100 40,110 110)))	SRID=-1;MULTIPOLYGON(((110 110,70 200,210 110,70 20,110 110),(110 110,110 140,150 110,110 80,110 110)),((110 110,60 60,10 110,60 160,110 110),(110 110,60 90,60 130,110 110)))	212111212
SRID=-1;POLYGON((100 60,140 100,100 140,60 100,100 60))	SRID=-1;MULTIPOLYGON(((80 40,120 40,120 80,80 80,80 40)),((120 80,160 80,160 120,120 120,120 80)),((80 120,120 120,120 160,80 160,80 120)),((40 80,80 80,80 120,40 120,40 80)))	21210F212
SRID=-1;LINESTRING(150 150,40 230)	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150))	FF1F00212
SRID=-1;LINESTRING(40 40,50 130,130 130)	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150))	FF1F0F212
SRID=-1;LINESTRING(40 230,150 150)	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150))	FF1F00212
SRID=-1;LINESTRING(210 150,330 150)	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150))	F1FF0F212
SRID=-1;LINESTRING(200 150,310 150,360 220)	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150))	F11F00212
SRID=-1;LINESTRING(180 150,250 150,230 250,370 250,410 150)	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150))	F11F0F212
SRID=-1;LINESTRING(210 210,220 150,320 150,370 210)	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150))	F11FF0212
SRID=-1;LINESTRING(20 60,150 60)	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150))	1010F0212
SRID=-1;LINESTRING(60 90,310 180)	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150))	101FF0212
SRID=-1;LINESTRING(90 210,210 90)	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150))	1010F0212
SRID=-1;LINESTRING(290 10,130 170)	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150))	101FF0212
SRID=-1;LINESTRING(30 100,100 100,180 100)	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150))	1010F0212
SRID=-1;LINESTRING(20 100,100 100,360 100,410 100)	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150))	101FF0212
SRID=-1;LINESTRING(90 210,150 150,210 90)	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150))	1010F0212
SRID=-1;LINESTRING(180 90,280 120)	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150))	1FF0FF212
SRID=-1;LINESTRING(70 70,80 20)	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150))	1FFF0F212
SRID=-1;LINESTRING(130 20,150 60)	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150))	1FF00F212
SRID=-1;LINESTRING(70 70,80 20,140 20,150 60)	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150))	11F00F212
SRID=-1;LINESTRING(170 50,170 20,240 20,260 60)	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150))	11F0FF212
SRID=-1;LINESTRING(50 100,140 190,280 190)	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150),(170 120,330 120,260 50,100 50,170 120))	FF1FF0212
SRID=-1;LINESTRING(140 60,180 100,290 100)	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150),(170 120,330 120,260 50,100 50,170 120))	FF1FF0212
SRID=-1;LINESTRING(170 120,210 80,270 80)	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150),(170 120,330 120,260 50,100 50,170 120))	FF1F00212
SRID=-1;LINESTRING(170 120,260 50)	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150),(170 120,330 120,260 50,100 50,170 120))	FF1F0F212
SRID=-1;LINESTRING(190 90,190 270)	SRID=-1;POLYGON((190 190,360 20,20 20,190 190),(190 190,280 50,100 50,190 190))	F01FF0212
SRID=-1;LINESTRING(60 160,150 70)	SRID=-1;POLYGON((190 190,360 20,20 20,190 190),(110 110,250 100,140 30,110 110))	F01FF0212
SRID=-1;LINESTRING(60 160,150 70)	SRID=-1;POLYGON((190 190,20 20,360 20,190 190),(250 100,110 110,140 30,250 100))	F01FF0212
SRID=-1;LINESTRING(60 160,150 70)	SRID=-1;POLYGON((190 190,20 20,360 20,190 190),(250 100,110 110,140 30,250 100))	F01FF0212
SRID=-1;LINESTRING(190 90,190 190,190 270)	SRID=-1;POLYGON((190 190,360 20,20 20,190 190),(190 190,280 50,100 50,190 190))	F01FF0212
SRID=-1;LINESTRING(60 160,110 110,150 70)	SRID=-1;POLYGON((190 190,360 20,20 20,190 190),(110 110,250 100,140 30,110 110))	F01FF0212
SRID=-1;LINESTRING(60 160,110 110,150 70)	SRID=-1;POLYGON((190 190,20 20,360 20,190 190),(250 100,110 110,140 30,250 100))	F01FF0212
SRID=-1;LINESTRING(60 160,110 110,150 70)	SRID=-1;POLYGON((190 190,110 110,20 20,360 20,190 190),(250 100,110 110,140 30,250 100))	F01FF0212
SRID=-1;LINESTRING(130 110,180 110,190 60)	SRID=-1;POLYGON((20 200,240 200,240 20,20 20,20 200),(130 110,60 180,60 40,130 110),(130 110,200 40,200 180,130 110))	FF1F00212
SRID=-1;LINESTRING(80 110,180 110)	SRID=-1;POLYGON((20 200,240 200,240 20,20 20,20 200),(130 110,60 180,60 40,130 110),(130 110,200 40,200 180,130 110))	F01FF0212
SRID=-1;LINESTRING(80 110,180 110)	SRID=-1;POLYGON((20 200,20 20,240 20,240 200,20 200),(60 180,130 110,60 40,60 180),(130 110,200 40,200 180,130 110))	F01FF0212
SRID=-1;LINESTRING(80 110,170 110)	SRID=-1;POLYGON((20 200,20 20,240 20,240 200,20 200),(130 110,60 40,60 180,130 110),(130 180,130 40,200 110,130 180))	F01FF0212
SRID=-1;LINESTRING(80 110,130 110,170 110)	SRID=-1;POLYGON((20 200,20 20,240 20,240 200,20 200),(130 110,60 40,60 180,130 110),(130 180,130 40,200 110,130 180))	F01FF0212
SRID=-1;LINESTRING(80 110,130 110,180 110)	SRID=-1;POLYGON((20 200,240 200,240 20,20 20,20 200),(130 110,60 180,60 40,130 110),(130 110,200 40,200 180,130 110))	F01FF0212
SRID=-1;LINESTRING(80 110,130 110,180 110)	SRID=-1;POLYGON((20 200,20 20,240 20,240 200,20 200),(60 180,130 110,60 40,60 180),(130 110,200 40,200 180,130 110))	F01FF0212
SRID=-1;LINESTRING(80 110,130 110,170 110)	SRID=-1;POLYGON((20 200,20 20,240 20,240 200,20 200),(130 110,60 40,60 180,130 110),(130 180,130 40,200 110,130 180))	F01FF0212
SRID=-1;LINESTRING(160 70,320 230)	SRID=-1;MULTIPOLYGON(((140 110,260 110,170 20,50 20,140 110)),((300 270,420 270,340 190,220 190,300 270)))	1010FF212
SRID=-1;LINESTRING(160 70,200 110,280 190,320 230)	SRID=-1;MULTIPOLYGON(((140 110,260 110,170 20,50 20,140 110)),((300 270,420 270,340 190,220 190,300 270)))	1010FF212
SRID=-1;LINESTRING(70 50,70 150)	SRID=-1;MULTIPOLYGON(((0 0,0 100,140 100,140 0,0 0)),((20 170,70 100,130 170,20 170)))	10F0FF212
SRID=-1;LINESTRING(110 110,20 200,200 200,110 110)	SRID=-1;POLYGON((20 20,200 20,110 110,20 20))	F01FFF212
SRID=-1;LINESTRING(150 70,160 110,200 60,150 70)	SRID=-1;POLYGON((20 20,200 20,110 110,20 20))	F01FFF212
SRID=-1;LINESTRING(80 60,120 40,120 70,80 60)	SRID=-1;POLYGON((110 110,200 20,20 20,110 110),(110 90,50 30,170 30,110 90))	F01FFF212
SRID=-1;LINESTRING(20 20,200 20,110 110,20 20)	SRID=-1;POLYGON((20 20,200 20,110 110,20 20))	F1FFFF2F2
SRID=-1;LINESTRING(110 90,170 30,50 30,110 90)	SRID=-1;POLYGON((110 110,200 20,20 20,110 110),(110 90,50 30,170 30,110 90))	F1FFFF212
SRID=-1;LINESTRING(110 110,170 50,170 110,110 110)	SRID=-1;POLYGON((110 110,200 20,20 20,110 110),(110 90,50 30,170 30,110 90))	F11FFF212
SRID=-1;LINESTRING(110 90,70 50,130 50,110 90)	SRID=-1;POLYGON((110 110,200 20,20 20,110 110),(110 90,50 30,170 30,110 90))	F11FFF212
SRID=-1;LINESTRING(110 60,20 150,200 150,110 60)	SRID=-1;POLYGON((20 20,200 20,110 110,20 20))	101FFF212
SRID=-1;LINESTRING(110 130,110 70,200 100,110 130)	SRID=-1;POLYGON((110 110,200 20,20 20,110 110),(110 90,50 30,170 30,110 90))	101FFF212
SRID=-1;LINESTRING(110 90,160 40,60 40,110 90)	SRID=-1;POLYGON((20 20,200 20,110 110,20 20))	1FFFFF212
SRID=-1;LINESTRING(110 100,40 30,180 30,110 100)	SRID=-1;POLYGON((110 110,200 20,20 20,110 110),(110 90,60 40,160 40,110 90))	1FFFFF212
SRID=-1;LINESTRING(110 110,180 30,40 30,110 110)	SRID=-1;POLYGON((110 110,200 20,20 20,110 110),(110 90,60 40,160 40,110 90))	10FFFF212
SRID=-1;LINESTRING(110 90,180 30,40 30,110 90)	SRID=-1;POLYGON((110 110,200 20,20 20,110 110),(110 90,60 40,160 40,110 90))	10FFFF212
SRID=-1;LINESTRING(110 90,50 30,180 30,110 90)	SRID=-1;POLYGON((110 110,200 20,20 20,110 110),(110 90,60 40,160 40,110 90))	11FFFF212
SRID=-1;LINESTRING(110 110,200 200,200 110,110 200)	SRID=-1;POLYGON((110 110,200 20,20 20,110 110))	FF1F00212
SRID=-1;LINESTRING(110 110,200 200,110 110,20 200,20 110,200 110)	SRID=-1;POLYGON((110 110,200 20,20 20,110 110))	FF1F00212
SRID=-1;LINESTRING(110 110,20 110,200 110,50 110,110 170)	SRID=-1;POLYGON((110 110,200 20,20 20,110 110))	FF1F00212
SRID=-1;LINESTRING(110 110,20 200,110 200,110 110,200 200)	SRID=-1;POLYGON((110 110,200 20,20 20,110 110))	FF1F00212
SRID=-1;LINESTRING(110 110,170 50,20 200,20 110,200 110)	SRID=-1;POLYGON((110 110,200 20,20 20,110 110))	F11F00212
SRID=-1;LINESTRING(110 110,180 40,110 40,110 180)	SRID=-1;POLYGON((110 110,200 20,20 20,110 110))	111F00212
SRID=-1;LINESTRING(110 60,50 30,170 30,90 70)	SRID=-1;POLYGON((110 110,200 20,20 20,110 110))	1FF0FF212
SRID=-1;LINESTRING(110 110,180 40,110 40,110 110,70 40)	SRID=-1;POLYGON((110 110,200 20,20 20,110 110))	11F00F212
SRID=-1;LINESTRING(230 70,170 120,190 60,140 60,170 120,270 90)	SRID=-1;POLYGON((150 150,410 150,280 20,20 20,150 150),(170 120,330 120,260 50,100 50,170 120))	F01FF0212
SRID=-1;MULTILINESTRING((20 110,200 110),(200 200,110 110,20 210,110 110))	SRID=-1;POLYGON((110 110,200 20,20 20,110 110))	FF1F00212
SRID=-1;MULTILINESTRING((20 110,200 110),(60 180,60 110,160 110,110 110))	SRID=-1;POLYGON((110 110,200 20,20 20,110 110))	FF1F00212
SRID=-1;MULTILINESTRING((20 110,200 110),(200 200,110 110,20 200,110 200,110 110))	SRID=-1;POLYGON((110 110,200 20,20 20,110 110))	FF1F00212
SRID=-1;MULTILINESTRING((20 110,200 110),(110 50,110 170,110 70,110 150,200 150))	SRID=-1;POLYGON((110 110,200 20,20 20,110 110))	1010F0212
SRID=-1;MULTILINESTRING((20 110,200 110),(50 110,170 110,110 170,110 50,110 170,110 50))	SRID=-1;POLYGON((110 110,200 20,20 20,110 110))	1010F0212
SRID=-1;MULTILINESTRING((20 110,200 110),(110 60,110 160,200 160))	SRID=-1;POLYGON((110 110,200 20,20 20,110 110))	1010F0212
SRID=-1;MULTILINESTRING((20 110,200 110),(110 60,110 160,200 160))	SRID=-1;POLYGON((110 110,200 20,20 20,110 110))	1010F0212
SRID=-1;MULTILINESTRING((110 100,40 30,180 30),(170 30,110 90,50 30))	SRID=-1;POLYGON((110 110,200 20,20 20,110 110))	1FF0FF212
SRID=-1;MULTILINESTRING((110 110,60 40,70 20,150 20,170 40),(180 30,40 30,110 80))	SRID=-1;POLYGON((110 110,200 20,20 20,110 110))	11F00F212
SRID=-1;MULTILINESTRING((20 110,200 110,200 160),(110 110,200 110,200 70,20 150))	SRID=-1;MULTIPOLYGON(((110 110,20 20,200 20,110 110)),((110 110,20 200,200 200,110 110)))	FF1F00212
SRID=-1;MULTILINESTRING((20 160,70 110,150 110,200 160),(110 110,20 110,50 80,70 110,200 110))	SRID=-1;MULTIPOLYGON(((110 110,20 20,200 20,110 110)),((110 110,20 200,200 200,110 110)))	FF1F00212
SRID=-1;MULTILINESTRING((20 110,200 110),(110 110,20 170,20 130,200 90))	SRID=-1;MULTIPOLYGON(((110 110,20 20,200 20,110 110)),((110 110,20 200,200 200,110 110)))	FF1F00212
SRID=-1;LINESTRING(0 0,0 50,50 50,50 0,0 0)	SRID=-1;MULTILINESTRING((0 0,0 50),(0 50,50 50),(50 50,50 0),(50 0,0 0))	1FFFFFFF2
SRID=-1;LINESTRING(40 180,140 180)	SRID=-1;MULTIPOLYGON(((20 320,180 320,180 180,20 180,20 320)),((20 180,20 80,180 80,180 180,20 180)))	1FF0FF212
SRID=-1;LINESTRING(40 180,140 180)	SRID=-1;MULTIPOLYGON(((20 320,180 320,180 180,20 180,20 320)),((60 180,60 80,180 80,180 180,60 180)))	11F00F212
SRID=-1;LINESTRING(0 0,60 0,60 60,60 0,120 0)	SRID=-1;MULTILINESTRING((0 0,60 0),(60 0,120 0),(60 0,60 60))	10FF0FFF2
SRID=-1;LINESTRING(40 40,120 120)	SRID=-1;LINESTRING(40 40,60 120)	FF1F00102
SRID=-1;LINESTRING(40 40,120 120)	SRID=-1;LINESTRING(60 240,40 40)	FF1F00102
SRID=-1;LINESTRING(40 40,180 180)	SRID=-1;LINESTRING(120 120,20 200)	F01FF0102
SRID=-1;LINESTRING(40 40,120 120)	SRID=-1;LINESTRING(60 240,120 120)	FF1F00102
SRID=-1;LINESTRING(40 40,180 180)	SRID=-1;LINESTRING(20 180,140 140)	F01FF0102
SRID=-1;LINESTRING(40 40,120 120)	SRID=-1;LINESTRING(40 120,120 40)	0F1FF0102
SRID=-1;LINESTRING(40 40,100 100)	SRID=-1;LINESTRING(40 40,100 100)	1FFF0FFF2
SRID=-1;LINESTRING(40 40,100 100)	SRID=-1;LINESTRING(100 100,40 40)	1FFF0FFF2
SRID=-1;LINESTRING(40 40,120 120)	SRID=-1;LINESTRING(40 120,120 160)	FF1FF0102
SRID=-1;LINESTRING(20 20,180 180)	SRID=-1;LINESTRING(20 20,180 180)	1FFF0FFF2
SRID=-1;LINESTRING(20 20,180 180)	SRID=-1;LINESTRING(20 20,110 110)	101F00FF2
SRID=-1;LINESTRING(20 20,180 180)	SRID=-1;LINESTRING(50 50,140 140)	101FF0FF2
SRID=-1;LINESTRING(180 180,40 40)	SRID=-1;LINESTRING(120 120,260 260)	1010F0102
SRID=-1;LINESTRING(40 40,180 180)	SRID=-1;LINESTRING(260 260,120 120)	1010F0102
SRID=-1;LINESTRING(40 40,180 180)	SRID=-1;LINESTRING(120 120,260 260)	1010F0102
SRID=-1;LINESTRING(40 40,100 100,200 120,80 240)	SRID=-1;LINESTRING(40 40,20 100,40 160,20 200)	FF1F00102
SRID=-1;LINESTRING(40 40,100 100,200 120,80 240)	SRID=-1;LINESTRING(20 200,40 160,20 100,40 40)	FF1F00102
SRID=-1;LINESTRING(80 240,200 120,100 100,40 40)	SRID=-1;LINESTRING(20 200,40 160,20 100,40 40)	FF1F00102
SRID=-1;LINESTRING(60 60,60 230,140 230,250 160)	SRID=-1;LINESTRING(20 20,60 60,250 160,310 230)	FF10FF102
SRID=-1;LINESTRING(60 60,60 230,140 230,250 160)	SRID=-1;LINESTRING(20 20,110 110,200 110,320 230)	FF10FF102
SRID=-1;LINESTRING(60 110,60 250,360 210)	SRID=-1;LINESTRING(60 110,110 160,250 160,310 160,360 210)	FF1F0F1F2
SRID=-1;LINESTRING(60 110,60 250,360 210)	SRID=-1;LINESTRING(360 210,310 160,110 160,60 110)	FF1F0F1F2
SRID=-1;LINESTRING(40 40,100 100,200 120,80 240)	SRID=-1;LINESTRING(160 160,240 240)	F01FF0102
SRID=-1;LINESTRING(40 40,100 100,200 120,80 240)	SRID=-1;LINESTRING(240 240,160 160)	F01FF0102
SRID=-1;LINESTRING(60 60,60 230,140 230,250 160)	SRID=-1;LINESTRING(60 150,110 100,170 100,110 230)	F01FF01F2
SRID=-1;LINESTRING(60 60,60 230,140 230,250 160)	SRID=-1;LINESTRING(60 110,110 160,250 160,310 160,360 210)	F010F0102
SRID=-1;LINESTRING(40 40,100 100,200 120,80 240)	SRID=-1;LINESTRING(200 120,200 190,150 240,200 240)	F01FF0102
SRID=-1;LINESTRING(40 40,100 100,200 120,80 240)	SRID=-1;LINESTRING(200 240,150 240,200 200,200 120)	F01FF0102
SRID=-1;LINESTRING(60 60,60 230,140 230,250 160)	SRID=-1;LINESTRING(60 230,80 140,120 140,140 230)	F01FF01F2
SRID=-1;LINESTRING(60 110,200 110,250 160,300 210)	SRID=-1;LINESTRING(60 110,110 160,250 160,310 160,360 210)	0F1F00102
SRID=-1;LINESTRING(60 110,200 110,250 160,300 210,360 210)	SRID=-1;LINESTRING(60 110,110 160,250 160,310 160,360 210)	0F1F0F1F2
SRID=-1;LINESTRING(60 110,220 110,250 160,280 110)	SRID=-1;LINESTRING(60 110,110 160,250 160,310 160,360 210)	0F1F00102
SRID=-1;LINESTRING(60 110,150 110,200 160,250 110,360 110,360 210)	SRID=-1;LINESTRING(60 110,110 160,250 160,310 160,360 210)	0F1F0F1F2
SRID=-1;LINESTRING(130 160,160 110,220 110,250 160,250 210)	SRID=-1;LINESTRING(60 110,110 160,250 160,310 160,360 210)	0F10F0102
SRID=-1;LINESTRING(130 160,160 110,190 110,230 210)	SRID=-1;LINESTRING(60 110,110 160,250 160,310 160,360 210)	0F10F0102
SRID=-1;LINESTRING(130 160,160 110,200 110,230 160,260 210,360 210)	SRID=-1;LINESTRING(60 110,110 160,250 160,310 160,360 210)	0F100F102
SRID=-1;LINESTRING(130 160,160 110,200 110,230 160,260 210,360 210,380 210)	SRID=-1;LINESTRING(60 110,110 160,250 160,310 160,360 210)	0010F0102
SRID=-1;LINESTRING(130 160,160 110,200 110,230 160,260 210,380 210)	SRID=-1;LINESTRING(60 110,110 160,250 160,310 160,360 210)	0010F0102
SRID=-1;LINESTRING(110 160,160 110,200 110,250 160,250 210)	SRID=-1;LINESTRING(60 110,110 160,250 160,310 160,360 210)	0F10F0102
SRID=-1;LINESTRING(110 160,180 110,250 160,320 110)	SRID=-1;LINESTRING(60 110,110 160,250 160,310 160,360 210)	0F10F0102
SRID=-1;LINESTRING(140 160,180 80,220 160,250 80)	SRID=-1;LINESTRING(60 110,110 160,250 160,310 160,360 210)	0F10F0102
SRID=-1;LINESTRING(40 40,100 100,200 120,130 190)	SRID=-1;LINESTRING(20 130,70 130,160 40)	0F1FF0102
SRID=-1;LINESTRING(40 40,100 100,200 120,130 190)	SRID=-1;LINESTRING(40 160,40 100,110 40,170 40)	0F1FF0102
SRID=-1;LINESTRING(130 110,180 160,230 110,280 160,330 110)	SRID=-1;LINESTRING(60 110,110 160,250 160,310 160,360 210)	0F1FF0102
SRID=-1;LINESTRING(40 40,100 100,200 120,130 190)	SRID=-1;LINESTRING(30 140,80 140,100 100,200 30)	0F1FF0102
SRID=-1;LINESTRING(110 110,110 160,180 110,250 160,250 110)	SRID=-1;LINESTRING(60 110,110 160,250 160,310 160,360 210)	0F1FF0102
SRID=-1;LINESTRING(20 20,80 80,160 80,240 80,300 140)	SRID=-1;LINESTRING(20 60,60 60,60 140,80 80,100 20,140 140,180 20,200 80,220 20,240 80,300 80,270 110,200 110)	0F1FF0102
SRID=-1;LINESTRING(20 20,230 20,20 30,170 30,20 40,230 40,20 50,230 60,60 60,230 70,20 70,180 80,60 80,230 90,20 90,230 100,30 100,210 110,20 110,80 120,20 130,170 130,90 120,230 130,170 140,230 140,80 150,160 140,20 140,70 150,20 150,230 160,80 160,230 170,20 160,180 170,20 170,230 180,20 180,40 190,230 190,20 200,230 200)	SRID=-1;LINESTRING(30 210,30 60,40 210,40 30,50 190,50 20,60 160,60 50,70 220,70 50,80 20,80 210,90 50,90 150,100 30,100 210,110 20,110 190,120 50,120 180,130 210,120 20,140 210,130 50,150 210,130 20,160 210,140 30,170 210,150 20,180 210,160 20,190 210,180 80,170 50,170 20,180 70,180 20,190 190,190 30,200 210,200 30,210 210,210 20,220 150,220 20)	001FF0102
SRID=-1;LINESTRING(40 40,100 100,200 120,80 240)	SRID=-1;LINESTRING(40 40,100 100,200 120,80 240)	1FFF0FFF2
SRID=-1;LINESTRING(40 40,100 100,200 120,80 240)	SRID=-1;LINESTRING(80 240,200 120,100 100,40 40)	1FFF0FFF2
SRID=-1;LINESTRING(40 40,100 100,200 120,80 240)	SRID=-1;LINESTRING(80 240,120 200,200 120,100 100,80 80,40 40)	1FFF0FFF2
SRID=-1;LINESTRING(40 40,100 100,200 120,80 240)	SRID=-1;LINESTRING(260 210,240 130,280 120,260 40)	FF1FF0102
SRID=-1;LINESTRING(100 20,20 20,20 160,210 160,210 20,110 20,50 120,120 150,200 150)	SRID=-1;LINESTRING(140 130,100 110,120 60,170 60)	FF1FF0102
SRID=-1;LINESTRING(60 110,110 160,250 160,310 160,360 210)	SRID=-1;LINESTRING(60 110,110 160,250 160,310 160,360 210)	1FFF0FFF2
SRID=-1;LINESTRING(60 110,110 160,310 160,360 210)	SRID=-1;LINESTRING(60 110,110 160,250 160,310 160,360 210)	1FFF0FFF2
SRID=-1;LINESTRING(60 110,110 160,250 160,310 160,360 210)	SRID=-1;LINESTRING(60 110,110 160,250 160)	101F00FF2
SRID=-1;LINESTRING(60 110,110 160,250 160,310 160,360 210)	SRID=-1;LINESTRING(110 160,310 160,340 190)	101FF0FF2
SRID=-1;LINESTRING(60 110,110 160,250 160,310 160,360 210)	SRID=-1;LINESTRING(140 160,250 160,310 160,340 190)	101FF0FF2
SRID=-1;LINESTRING(60 110,110 160,250 160,310 160,360 210)	SRID=-1;LINESTRING(110 160,250 160,310 160)	101FF0FF2
SRID=-1;LINESTRING(40 40,100 100,200 120,80 240)	SRID=-1;LINESTRING(200 120,100 100,40 40,140 80,200 40)	1010F0102
SRID=-1;LINESTRING(40 40,100 100,200 120,80 240)	SRID=-1;LINESTRING(280 240,240 140,200 120,100 100,40 40)	1F1F00102
SRID=-1;LINESTRING(40 40,100 100,200 120,80 240)	SRID=-1;LINESTRING(80 190,140 140,40 40)	1F1F00102
SRID=-1;LINESTRING(40 40,100 100,200 120,80 240)	SRID=-1;LINESTRING(240 200,200 260,80 240,140 180)	1010F0102
SRID=-1;LINESTRING(40 40,100 100,200 120,80 240)	SRID=-1;LINESTRING(140 180,80 240,200 260,240 200)	1010F0102
SRID=-1;LINESTRING(40 40,100 100,200 120,80 240)	SRID=-1;LINESTRING(280 240,240 140,200 120,80 240)	1F1F00102
SRID=-1;LINESTRING(20 20,80 80,160 80,240 80,300 140)	SRID=-1;LINESTRING(20 80,120 80,200 80,260 20)	1F1FF0102
SRID=-1;LINESTRING(40 40,100 100,200 120,80 240)	SRID=-1;LINESTRING(100 100,200 120,240 140,280 240)	101FF0102
SRID=-1;LINESTRING(40 40,100 100,200 120,80 240)	SRID=-1;LINESTRING(280 240,240 140,200 120,100 100)	101FF0102
SRID=-1;LINESTRING(20 20,80 80,160 80,240 80,300 140)	SRID=-1;LINESTRING(80 20,80 80,240 80,300 20)	1F1FF0102
SRID=-1;LINESTRING(20 20,80 80,160 80,240 80,300 140)	SRID=-1;LINESTRING(20 80,80 80,120 80,140 140,160 80,200 80,220 20,240 80,270 110,300 80)	1F1FF0102
SRID=-1;LINESTRING(100 100,20 180,180 180)	SRID=-1;LINESTRING(100 100,180 20,20 20,100 100)	FF10F01F2
SRID=-1;LINESTRING(20 100,180 100,100 180)	SRID=-1;LINESTRING(100 100,180 20,20 20,100 100)	0F1FF01F2
SRID=-1;LINESTRING(100 40,100 160,180 160)	SRID=-1;LINESTRING(100 100,180 20,20 20,100 100)	0F1FF01F2
SRID=-1;LINESTRING(20 100,100 100,180 100,100 180)	SRID=-1;LINESTRING(100 100,180 20,20 20,100 100)	0F1FF01F2
SRID=-1;LINESTRING(100 100,160 40)	SRID=-1;LINESTRING(100 100,180 20,20 20,100 100)	1FF0FF1F2
SRID=-1;LINESTRING(100 100,180 20)	SRID=-1;LINESTRING(100 100,180 20,20 20,100 100)	1FF0FF1F2
SRID=-1;LINESTRING(60 60,100 100,140 60)	SRID=-1;LINESTRING(100 100,180 20,20 20,100 100)	1FF0FF1F2
SRID=-1;LINESTRING(100 100,190 10,190 100)	SRID=-1;LINESTRING(100 100,180 20,20 20,100 100)	1F10F01F2
SRID=-1;LINESTRING(100 100,160 40,160 100)	SRID=-1;LINESTRING(100 100,180 20,20 20,100 100)	1F10F01F2
SRID=-1;LINESTRING(60 140,160 40,160 140)	SRID=-1;LINESTRING(100 100,180 20,20 20,100 100)	1F1FF01F2
SRID=-1;LINESTRING(20 20,140 140)	SRID=-1;LINESTRING(80 80,20 80,140 80,80 20,80 140)	F01FF0102
SRID=-1;LINESTRING(20 20,140 140)	SRID=-1;LINESTRING(80 80,20 80,140 80)	F01FF0102
SRID=-1;LINESTRING(20 20,140 140)	SRID=-1;LINESTRING(80 80,140 80,80 20,80 140)	F01FF0102
SRID=-1;LINESTRING(20 20,140 140)	SRID=-1;LINESTRING(80 80,20 80,140 80,80 20,80 80)	0F1FF01F2
SRID=-1;LINESTRING(20 20,140 140)	SRID=-1;LINESTRING(80 80,20 80,140 80,80 80)	0F1FF01F2
SRID=-1;LINESTRING(20 20,140 140)	SRID=-1;LINESTRING(80 80,20 80,20 140,140 20,80 20,80 80)	0F1FF01F2
SRID=-1;LINESTRING(20 20,140 140)	SRID=-1;LINESTRING(20 140,140 20,100 20,100 80)	0F1FF0102
SRID=-1;LINESTRING(20 20,140 140)	SRID=-1;LINESTRING(140 80,20 80,120 80,80 20,80 140)	0F1FF0102
SRID=-1;LINESTRING(20 20,140 140)	SRID=-1;LINESTRING(140 80,20 80,140 80)	0F1FF01F2
SRID=-1;LINESTRING(20 20,140 140)	SRID=-1;LINESTRING(140 80,20 80,80 140,80 20)	0F1FF0102
SRID=-1;LINESTRING(20 20,140 140)	SRID=-1;LINESTRING(140 80,80 80,20 80,50 140,50 60)	0F1FF0102
SRID=-1;LINESTRING(20 20,140 140)	SRID=-1;LINESTRING(140 80,20 80,120 80,80 20,80 80,80 140)	0F1FF0102
SRID=-1;LINESTRING(20 20,140 140)	SRID=-1;LINESTRING(140 80,20 80,80 80,140 80)	0F1FF01F2
SRID=-1;LINESTRING(20 20,140 140)	SRID=-1;LINESTRING(140 80,20 80,80 140,80 80,80 20)	0F1FF0102
SRID=-1;LINESTRING(130 150,220 150,220 240)	SRID=-1;LINESTRING(130 240,130 150,220 20,50 20,130 150)	FF1F00102
SRID=-1;LINESTRING(30 150,130 150,250 150)	SRID=-1;LINESTRING(130 240,130 150,220 20,50 20,130 150)	F01FF0102
SRID=-1;LINESTRING(30 150,250 150)	SRID=-1;LINESTRING(130 240,130 150,220 20,50 20,130 150)	F01FF0102
SRID=-1;LINESTRING(30 150,130 150,250 150)	SRID=-1;LINESTRING(130 240,130 20,30 20,130 150)	F01FF0102
SRID=-1;LINESTRING(30 150,250 150)	SRID=-1;LINESTRING(120 240,120 20,20 20,120 170)	0F1FF0102
SRID=-1;LINESTRING(200 200,20 20,200 20,110 110,20 200,110 200,110 110)	SRID=-1;LINESTRING(110 110,200 110)	FF1F00102
SRID=-1;LINESTRING(110 110,200 110)	SRID=-1;LINESTRING(200 200,20 20,200 20,110 110,20 200,110 200,110 110)	FF1F00102
SRID=-1;LINESTRING(20 110,200 110)	SRID=-1;LINESTRING(200 200,20 20,200 20,110 110,20 200,110 200,110 110)	F01FF0102
SRID=-1;LINESTRING(200 200,20 20,200 20,110 110,20 200,110 200,110 110)	SRID=-1;LINESTRING(20 110,200 110)	FF10F0102
SRID=-1;LINESTRING(90 200,90 130,110 110,150 200)	SRID=-1;LINESTRING(200 200,20 20,200 20,20 200,20 130,90 130)	101FF0102
SRID=-1;LINESTRING(200 110,110 110,90 130,90 200)	SRID=-1;LINESTRING(200 200,20 20,200 20,20 200,20 130,90 130)	101FF0102
SRID=-1;LINESTRING(80 80,150 80,210 80)	SRID=-1;MULTILINESTRING((20 20,140 140),(20 140,140 20))	FF10F0102
SRID=-1;LINESTRING(40 80,160 200,260 20,40 80)	SRID=-1;LINESTRING(40 80,160 200,260 20,40 80)	1FFFFFFF2
SRID=-1;LINESTRING(40 80,160 200,260 20,40 80)	SRID=-1;LINESTRING(40 80,260 20,160 200,40 80)	1FFFFFFF2
SRID=-1;LINESTRING(40 80,160 200,260 20,40 80)	SRID=-1;LINESTRING(260 20,40 80,160 200,260 20)	1FFFFFFF2
SRID=-1;LINESTRING(40 80,160 200,260 20,40 80)	SRID=-1;LINESTRING(100 140,160 200,260 20,40 80,100 140)	1FFFFFFF2
SRID=-1;LINESTRING(100 100,180 20,20 20,100 100)	SRID=-1;LINESTRING(100 100,180 180,20 180,100 100)	0F1FFF1F2
SRID=-1;LINESTRING(40 150,40 40,150 40,150 150,40 150)	SRID=-1;LINESTRING(40 150,150 40,170 20,170 190,40 150)	0F1FFF1F2
SRID=-1;LINESTRING(100 100,180 20,20 20,100 100)	SRID=-1;LINESTRING(180 100,20 100,100 180,180 100)	0F1FFF1F2
SRID=-1;LINESTRING(100 100,180 20,20 20,100 100)	SRID=-1;LINESTRING(180 180,100 100,20 180,180 180)	0F1FFF1F2
SRID=-1;LINESTRING(20 180,100 100,20 20,20 180)	SRID=-1;LINESTRING(100 20,100 180,180 100,100 20)	0F1FFF1F2
SRID=-1;LINESTRING(40 150,40 40,150 40,150 150,40 150)	SRID=-1;LINESTRING(170 20,20 170,170 170,170 20)	0F1FFF1F2
SRID=-1;LINESTRING(40 150,40 40,150 40,150 150,40 150)	SRID=-1;LINESTRING(40 150,150 150,90 210,40 150)	1F1FFF1F2
SRID=-1;LINESTRING(40 150,40 40,150 40,150 150,40 150)	SRID=-1;LINESTRING(20 150,170 150,90 230,20 150)	1F1FFF1F2
SRID=-1;LINESTRING(40 150,40 40,150 40,150 150,40 150)	SRID=-1;LINESTRING(40 150,150 150,150 40,20 40,20 150,40 150)	1F1FFF1F2
SRID=-1;LINESTRING(110 110,200 20,20 20,110 110)	SRID=-1;LINESTRING(110 110,200 200,110 110,20 200,20 110,200 110)	F01FFF102
SRID=-1;LINESTRING(110 110,200 20,20 20,110 110)	SRID=-1;LINESTRING(110 110,20 110,200 110,50 110,110 170)	F01FFF102
SRID=-1;LINESTRING(110 110,200 20,20 20,110 110)	SRID=-1;LINESTRING(110 110,20 200,110 200,110 110,200 200)	F01FFF102
SRID=-1;LINESTRING(110 110,200 20,20 20,110 110)	SRID=-1;LINESTRING(200 20,20 200,200 200,110 110,110 40)	101FFF102
SRID=-1;LINESTRING(110 110,200 20,20 20,110 110)	SRID=-1;LINESTRING(200 20,20 200,200 200,20 20)	101FFF1F2
SRID=-1;LINESTRING(110 110,20 110,110 20,20 20,110 110)	SRID=-1;LINESTRING(110 110,200 200,110 200,200 110,110 110)	0F1FFF1F2
SRID=-1;LINESTRING(20 120,120 120,20 20,120 20,20 120)	SRID=-1;LINESTRING(170 100,70 100,170 170,70 170,170 100)	0F1FFF1F2
SRID=-1;LINESTRING(20 110,110 110,20 20,110 20,20 110)	SRID=-1;LINESTRING(110 160,70 110,60 160,20 130,110 160)	0F1FFF1F2
SRID=-1;LINESTRING(20 200,200 200,20 20,200 20,20 200)	SRID=-1;LINESTRING(20 110,200 110,200 160,20 60,20 110)	0F1FFF1F2
SRID=-1;LINESTRING(20 110,110 110,20 20,110 20,20 110)	SRID=-1;LINESTRING(200 200,110 110,200 110,110 200,200 200)	0F1FFF1F2
SRID=-1;LINESTRING(20 120,120 120,20 20,120 20,20 120)	SRID=-1;LINESTRING(220 120,120 20,220 20,120 120,220 120)	0F1FFF1F2
SRID=-1;MULTILINESTRING((70 20,20 90,70 170),(70 170,120 90,70 20))	SRID=-1;MULTILINESTRING((70 20,20 90,70 170),(70 170,120 90,70 20))	1FFFFFFF2
SRID=-1;MULTILINESTRING((20 20,90 20,170 20),(90 20,90 80,90 140))	SRID=-1;MULTILINESTRING((20 20,90 20,170 20),(90 20,90 80,90 140))	1FFF0FFF2
SRID=-1;MULTILINESTRING((20 20,90 20,170 20),(90 20,90 80,90 140))	SRID=-1;MULTILINESTRING((90 140,90 60,90 20),(170 20,130 20,20 20))	1FFF0FFF2
SRID=-1;MULTILINESTRING((20 20,90 20,170 20),(90 20,90 80,90 140))	SRID=-1;MULTILINESTRING((90 20,170 100,170 140),(170 60,90 20,20 60),(130 100,130 60,90 20,50 90))	FF1F00102
SRID=-1;MULTILINESTRING((20 20,90 20,170 20),(90 20,90 80,90 140))	SRID=-1;MULTILINESTRING((90 20,170 100,170 140),(130 140,130 60,90 20,20 90,90 20,130 60,170 60))	FF1F00102
SRID=-1;MULTILINESTRING((20 20,90 20,170 20),(90 20,90 80,90 140))	SRID=-1;MULTILINESTRING((90 20,170 100,170 140),(170 60,90 20,20 60))	FF1F00102
SRID=-1;MULTILINESTRING((20 20,90 20,170 20),(90 20,90 80,90 140))	SRID=-1;MULTILINESTRING((90 20,170 100,170 140),(170 60,90 20,20 60),(130 100,90 20))	FF10F0102
SRID=-1;MULTILINESTRING((20 20,90 20,170 20),(90 20,90 80,90 140))	SRID=-1;MULTILINESTRING((90 20,170 100,170 140),(170 60,90 20,20 60),(120 100,170 100,90 20))	FF10F0102
SRID=-1;MULTILINESTRING((20 20,90 20,170 20),(90 20,90 80,90 140))	SRID=-1;MULTILINESTRING((90 20,170 100,170 140),(170 60,90 20,20 60),(120 100,170 100,90 20))	FF10F0102
SRID=-1;MULTILINESTRING((20 20,90 20,170 20),(90 20,90 80,90 140))	SRID=-1;MULTILINESTRING((90 20,170 100,170 140),(130 140,130 60,90 20,20 90,90 20))	FF10F0102
SRID=-1;MULTILINESTRING((20 20,90 20,170 20),(90 20,90 80,90 140))	SRID=-1;MULTILINESTRING((90 20,170 100,170 140),(170 60,90 20,20 60,20 140,90 20))	FF10F0102
SRID=-1;MULTILINESTRING((20 20,90 90,20 160),(90 160,90 20))	SRID=-1;MULTILINESTRING((160 160,90 90,160 20),(160 120,120 120,90 90,160 60))	0F1FF0102
SRID=-1;MULTILINESTRING((20 20,90 90,20 160),(90 160,90 20))	SRID=-1;MULTILINESTRING((160 160,90 90,160 20),(160 120,120 120,90 90,120 60,160 60))	0F1FF0102
SRID=-1;MULTILINESTRING((20 20,90 90,20 160),(90 160,90 20))	SRID=-1;MULTILINESTRING((160 160,90 90,160 20),(160 120,90 90,160 60))	0F1FF0102
SRID=-1;POINT(20 20)	SRID=-1;POLYGON((60 120,60 40,160 40,160 120,60 120))	FF0FFF212
SRID=-1;POINT(70 170)	SRID=-1;POLYGON((110 230,80 160,20 160,20 20,200 20,200 160,140 160,110 230))	FF0FFF212
SRID=-1;POINT(110 130)	SRID=-1;POLYGON((20 160,80 160,110 100,140 160,200 160,200 20,20 20,20 160))	FF0FFF212
SRID=-1;POINT(100 70)	SRID=-1;POLYGON((20 150,100 150,40 50,170 50,110 150,190 150,190 20,20 20,20 150))	FF0FFF212
SRID=-1;POINT(100 70)	SRID=-1;POLYGON((20 150,100 150,40 50,160 50,100 150,180 150,180 20,20 20,20 150))	FF0FFF212
SRID=-1;POINT(60 120)	SRID=-1;POLYGON((60 120,60 40,160 40,160 120,60 120))	F0FFFF212
SRID=-1;POINT(110 120)	SRID=-1;POLYGON((60 120,60 40,160 40,160 120,60 120))	F0FFFF212
SRID=-1;POINT(160 120)	SRID=-1;POLYGON((60 120,60 40,160 40,160 120,60 120))	F0FFFF212
SRID=-1;POINT(100 150)	SRID=-1;POLYGON((20 150,100 150,40 50,160 50,100 150,180 150,180 20,20 20,20 150))	F0FFFF212
SRID=-1;POINT(100 80)	SRID=-1;POLYGON((60 120,60 40,160 40,160 120,60 120))	0FFFFF212
SRID=-1;POINT(60 160)	SRID=-1;POLYGON((190 190,360 20,20 20,190 190),(280 50,100 50,190 140,280 50))	FF0FFF212
SRID=-1;POINT(190 90)	SRID=-1;POLYGON((190 190,360 20,20 20,190 190),(280 50,100 50,190 140,280 50))	FF0FFF212
SRID=-1;POINT(190 190)	SRID=-1;POLYGON((190 190,360 20,20 20,190 190),(280 50,100 50,190 140,280 50))	F0FFFF212
SRID=-1;POINT(360 20)	SRID=-1;POLYGON((190 190,360 20,20 20,190 190),(280 50,100 50,190 140,280 50))	F0FFFF212
SRID=-1;POINT(130 130)	SRID=-1;POLYGON((190 190,360 20,20 20,190 190),(280 50,100 50,190 140,280 50))	F0FFFF212
SRID=-1;POINT(280 50)	SRID=-1;POLYGON((190 190,360 20,20 20,190 190),(280 50,100 50,190 140,280 50))	F0FFFF212
SRID=-1;POINT(150 100)	SRID=-1;POLYGON((190 190,360 20,20 20,190 190),(280 50,100 50,190 140,280 50))	F0FFFF212
SRID=-1;POINT(100 50)	SRID=-1;POLYGON((190 190,360 20,20 20,190 190),(280 50,100 50,190 140,280 50))	F0FFFF212
SRID=-1;POINT(140 120)	SRID=-1;POLYGON((190 190,360 20,20 20,190 190),(280 50,100 50,190 140,280 50))	0FFFFF212
SRID=-1;POINT(190 50)	SRID=-1;POLYGON((190 190,360 20,20 20,190 190),(90 50,150 110,190 50,90 50),(190 50,230 110,290 50,190 50))	F0FFFF212
SRID=-1;POINT(180 90)	SRID=-1;POLYGON((190 190,360 20,20 20,190 190),(180 140,180 40,80 40,180 140),(180 90,210 140,310 40,230 40,180 90))	F0FFFF212
SRID=-1;MULTIPOINT(20 80,110 160,20 160)	SRID=-1;POLYGON((60 120,60 40,160 40,160 120,60 120))	FF0FFF212
SRID=-1;MULTIPOINT(20 80,60 120,20 160)	SRID=-1;POLYGON((60 120,60 40,160 40,160 120,60 120))	F00FFF212
SRID=-1;MULTIPOINT(10 80,110 170,110 120)	SRID=-1;POLYGON((60 120,60 40,160 40,160 120,60 120))	F00FFF212
SRID=-1;MULTIPOINT(10 80,110 170,160 120)	SRID=-1;POLYGON((60 120,60 40,160 40,160 120,60 120))	F00FFF212
SRID=-1;MULTIPOINT(20 120,60 120,110 120,160 120,200 120)	SRID=-1;POLYGON((60 120,60 40,160 40,160 120,60 120))	F00FFF212
SRID=-1;MULTIPOINT(60 120,110 120,160 120)	SRID=-1;POLYGON((60 120,60 40,160 40,160 120,60 120))	F0FFFF212
SRID=-1;MULTIPOINT(60 120,160 120,160 40,60 40)	SRID=-1;POLYGON((60 120,60 40,160 40,160 120,60 120))	F0FFFF212
SRID=-1;MULTIPOINT(20 150,60 120,110 80)	SRID=-1;POLYGON((60 120,60 40,160 40,160 120,60 120))	000FFF212
SRID=-1;MULTIPOINT(110 80,160 120,200 160)	SRID=-1;POLYGON((60 120,60 40,160 40,160 120,60 120))	000FFF212
SRID=-1;MULTIPOINT(110 80,110 120,110 160)	SRID=-1;POLYGON((60 120,60 40,160 40,160 120,60 120))	000FFF212
SRID=-1;MULTIPOINT(110 170,110 80)	SRID=-1;POLYGON((60 120,60 40,160 40,160 120,60 120))	0F0FFF212
SRID=-1;MULTIPOINT(60 120,160 120,110 80,110 170)	SRID=-1;POLYGON((60 120,60 40,160 40,160 120,60 120))	000FFF212
SRID=-1;MULTIPOINT(90 80,130 80)	SRID=-1;POLYGON((60 120,60 40,160 40,160 120,60 120))	0FFFFF212
SRID=-1;MULTIPOINT(60 120,160 120,110 80)	SRID=-1;POLYGON((60 120,60 40,160 40,160 120,60 120))	00FFFF212
SRID=-1;MULTIPOINT(40 170,40 90,130 170)	SRID=-1;POLYGON((190 190,360 20,20 20,190 190),(280 50,100 50,190 140,280 50))	FF0FFF212
SRID=-1;MULTIPOINT(90 170,280 170,190 90)	SRID=-1;POLYGON((190 190,360 20,20 20,190 190),(280 50,100 50,190 140,280 50))	FF0FFF212
SRID=-1;MULTIPOINT(190 110,150 70,230 70)	SRID=-1;POLYGON((190 190,360 20,20 20,190 190),(280 50,100 50,190 140,280 50))	FF0FFF212
SRID=-1;POINT(100 100)	SRID=-1;MULTIPOLYGON(((20 100,20 20,100 20,100 100,20 100)),((100 180,100 100,180 100,180 180,100 180)))	F0FFFF212
SRID=-1;POINT(20 100)	SRID=-1;MULTIPOLYGON(((20 100,20 20,100 20,100 100,20 100)),((100 180,100 100,180 100,180 180,100 180)))	F0FFFF212
SRID=-1;POINT(60 100)	SRID=-1;MULTIPOLYGON(((20 100,20 20,100 20,100 100,20 100)),((100 180,100 100,180 100,180 180,100 180)))	F0FFFF212
SRID=-1;POINT(110 110)	SRID=-1;MULTIPOLYGON(((110 110,20 200,200 200,110 110),(110 110,80 180,140 180,110 110)),((110 110,20 20,200 20,110 110),(110 110,80 40,140 40,110 110)))	F0FFFF212
SRID=-1;POINT(110 200)	SRID=-1;LINESTRING(90 80,160 150,300 150,340 150,340 240)	FF0FFF102
SRID=-1;POINT(90 80)	SRID=-1;LINESTRING(90 80,160 150,300 150,340 150,340 240)	F0FFFF102
SRID=-1;POINT(340 240)	SRID=-1;LINESTRING(90 80,160 150,300 150,340 150,340 240)	F0FFFF102
SRID=-1;POINT(230 150)	SRID=-1;LINESTRING(90 80,160 150,300 150,340 150,340 240)	0FFFFF102
SRID=-1;POINT(160 150)	SRID=-1;LINESTRING(90 80,160 150,300 150,340 150,340 240)	0FFFFF102
SRID=-1;POINT(90 150)	SRID=-1;LINESTRING(150 150,20 20,280 20,150 150)	FF0FFF1F2
SRID=-1;POINT(150 80)	SRID=-1;LINESTRING(150 150,20 20,280 20,150 150)	FF0FFF1F2
SRID=-1;POINT(150 150)	SRID=-1;LINESTRING(150 150,20 20,280 20,150 150)	0FFFFF1F2
SRID=-1;POINT(100 20)	SRID=-1;LINESTRING(150 150,20 20,280 20,150 150)	0FFFFF1F2
SRID=-1;POINT(20 20)	SRID=-1;LINESTRING(150 150,20 20,280 20,150 150)	0FFFFF1F2
SRID=-1;POINT(220 220)	SRID=-1;LINESTRING(110 110,220 20,20 20,110 110,220 220)	F0FFFF102
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(110 110,220 20,20 20,110 110,220 220)	F0FFFF102
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(110 110,220 20,20 20,220 220)	F0FFFF102
SRID=-1;POINT(110 20)	SRID=-1;LINESTRING(110 110,220 20,20 20,220 220)	0FFFFF102
SRID=-1;POINT(220 20)	SRID=-1;LINESTRING(110 110,220 20,20 20,220 220)	0FFFFF102
SRID=-1;POINT(110 20)	SRID=-1;LINESTRING(220 220,20 20,220 20,110 110)	0FFFFF102
SRID=-1;POINT(20 20)	SRID=-1;LINESTRING(220 220,20 20,220 20,110 110)	0FFFFF102
SRID=-1;POINT(20 110)	SRID=-1;LINESTRING(20 200,20 20,110 20,20 110,110 200)	0FFFFF102
SRID=-1;POINT(20 200)	SRID=-1;LINESTRING(20 200,200 20,20 20,200 200)	F0FFFF102
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(20 200,200 20,140 20,140 80,80 140,20 140)	0FFFFF102
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(20 200,200 20,20 20,200 200)	0FFFFF102
SRID=-1;POINT(80 140)	SRID=-1;LINESTRING(20 200,110 110,200 20,140 20,140 80,110 110,80 140,20 140)	0FFFFF102
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(20 200,110 110,200 20,140 20,140 80,110 110,80 140,20 140)	0FFFFF102
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(20 200,200 20,140 20,140 80,110 110,80 140,20 140)	0FFFFF102
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(20 200,110 110,200 20,20 20,110 110,200 200)	0FFFFF102
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(20 200,200 20,20 20,110 110,200 200)	0FFFFF102
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(20 200,110 110,20 20,200 20,110 110,200 200)	0FFFFF102
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(110 110,110 200,20 200,110 110,200 20,140 20,140 80,110 110,80 140,20 140)	F0FFFF102
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(110 110,110 200,20 200,200 20,140 20,140 80,110 110,80 140,20 140)	F0FFFF102
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(110 110,110 200,20 200,200 20,140 20,140 80,80 140,20 140)	F0FFFF102
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(110 110,110 200,20 200,110 110,200 20,20 20,110 110,200 200)	F0FFFF102
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(110 110,110 200,20 200,200 20,20 20,110 110,200 200)	F0FFFF102
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(110 110,110 200,20 200,200 20,20 20,200 200)	F0FFFF102
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(110 110,110 200,20 200,110 110,20 20,200 20,110 110,200 200)	F0FFFF102
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(110 110,110 200,20 200,200 20,200 110,110 110,200 200)	F0FFFF102
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(200 200,110 110,20 20,200 20,110 110,20 200,110 200,110 110)	F0FFFF102
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(200 200,20 20,200 20,110 110,20 200,110 200,110 110)	F0FFFF102
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(200 200,20 20,200 20,20 200,110 200,110 110)	F0FFFF102
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(200 200,110 110,200 20,20 20,110 110,20 200,110 200,110 110)	F0FFFF102
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(200 200,20 20,20 110,110 110,20 200,110 200,110 110)	F0FFFF102
SRID=-1;POINT(110 160)	SRID=-1;LINESTRING(110 160,200 250,110 250,110 160,110 110,110 20,20 20,110 110)	F0FFFF102
SRID=-1;POINT(110 160)	SRID=-1;LINESTRING(110 160,200 250,110 250,110 110,110 20,20 20,110 110)	F0FFFF102
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(110 160,200 250,110 250,110 160,110 110,110 20,20 20,110 110)	F0FFFF102
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(110 160,200 250,110 250,110 160,110 20,20 20,110 110)	F0FFFF102
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(110 110,200 200,110 200,110 110,110 20,20 20,110 110)	0FFFFF1F2
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(110 110,200 200,110 200,110 20,20 20,110 110)	0FFFFF1F2
SRID=-1;POINT(140 200)	SRID=-1;LINESTRING(110 110,200 200,110 200,110 110,110 20,20 20,110 110)	0FFFFF1F2
SRID=-1;POINT(110 200)	SRID=-1;LINESTRING(110 110,200 200,110 200,110 110,110 20,20 20,110 110)	0FFFFF1F2
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(110 110,200 200,110 200,110 110,110 20,200 20,110 110)	0FFFFF1F2
SRID=-1;POINT(140 200)	SRID=-1;LINESTRING(110 110,200 200,110 200,110 110,110 20,200 20,110 110)	0FFFFF1F2
SRID=-1;POINT(110 200)	SRID=-1;LINESTRING(110 110,200 200,110 200,110 110,110 20,200 20,110 110)	0FFFFF1F2
SRID=-1;POINT(90 130)	SRID=-1;LINESTRING(90 130,20 130,20 200,90 130,200 20,20 20,200 200)	F0FFFF102
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(90 130,20 130,20 200,90 130,200 20,20 20,200 200)	0FFFFF102
SRID=-1;POINT(90 130)	SRID=-1;LINESTRING(90 130,20 130,20 200,200 20,20 20,200 200)	F0FFFF102
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(90 130,20 130,20 200,200 20,20 20,200 200)	0FFFFF102
SRID=-1;POINT(90 130)	SRID=-1;LINESTRING(200 200,20 20,200 20,90 130,20 200,20 130,90 130)	F0FFFF102
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(200 200,20 20,200 20,90 130,20 200,20 130,90 130)	0FFFFF102
SRID=-1;POINT(90 130)	SRID=-1;LINESTRING(200 200,20 20,200 20,20 200,20 130,90 130)	F0FFFF102
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(200 200,20 20,200 20,20 200,20 130,90 130)	0FFFFF102
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(110 110,20 130,20 200,110 110,200 20,20 20,110 110,200 200,200 130,110 110)	0FFFFF1F2
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(110 110,20 130,20 200,200 20,20 20,200 200,200 130,110 110)	0FFFFF1F2
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(110 110,80 200,20 200,110 110,200 20,20 20,110 110,200 200,140 200,110 110)	0FFFFF1F2
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(110 110,80 200,20 200,200 20,20 20,200 200,140 200,110 110)	0FFFFF1F2
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(200 200,20 20,200 20,20 200,200 200)	0FFFFF1F2
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(200 200,110 110,20 20,200 20,110 110,20 200,200 200)	0FFFFF1F2
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(200 200,110 110,200 20,20 20,110 110,20 200,200 200)	0FFFFF1F2
SRID=-1;POINT(90 130)	SRID=-1;LINESTRING(90 130,20 130,20 200,90 130,110 110,200 20,20 20,110 110,200 200,90 130)	0FFFFF1F2
SRID=-1;POINT(90 130)	SRID=-1;LINESTRING(90 130,20 130,20 200,110 110,200 20,20 20,110 110,200 200,90 130)	0FFFFF1F2
SRID=-1;POINT(90 130)	SRID=-1;LINESTRING(90 130,90 200,20 200,90 130,110 110,200 20,20 20,110 110,200 200,90 130)	0FFFFF1F2
SRID=-1;POINT(90 130)	SRID=-1;LINESTRING(90 130,90 200,20 200,200 20,20 20,200 200,90 130)	0FFFFF1F2
SRID=-1;POINT(90 130)	SRID=-1;LINESTRING(90 130,90 200,20 200,110 110,200 20,20 20,110 110,200 200,90 130)	0FFFFF1F2
SRID=-1;POINT(90 130)	SRID=-1;LINESTRING(90 130,90 200,20 200,200 20,20 20,200 200,90 130)	0FFFFF1F2
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(90 130,90 200,20 200,200 20,20 20,200 200,90 130)	0FFFFF1F2
SRID=-1;POINT(110 200)	SRID=-1;LINESTRING(110 200,110 110,20 20,200 20,110 110,110 200,200 200)	F0FFFF102
SRID=-1;POINT(110 150)	SRID=-1;LINESTRING(110 200,110 110,20 20,200 20,110 110,110 200,200 200)	0FFFFF102
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(110 200,110 110,20 20,200 20,110 110,110 200,200 200)	0FFFFF102
SRID=-1;POINT(110 200)	SRID=-1;LINESTRING(110 200,110 110,20 20,200 20,110 110,110 200)	0FFFFF1F2
SRID=-1;POINT(110 150)	SRID=-1;LINESTRING(110 200,110 110,20 20,200 20,110 110,110 200)	0FFFFF1F2
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(110 200,110 110,20 20,200 20,110 110,110 200)	0FFFFF1F2
SRID=-1;POINT(110 150)	SRID=-1;LINESTRING(20 200,110 200,110 110,20 20,200 20,110 110,110 200,200 200)	0FFFFF102
SRID=-1;POINT(110 110)	SRID=-1;LINESTRING(20 200,110 200,110 110,20 20,200 20,110 110,110 200,200 200)	0FFFFF102
SRID=-1;POINT(110 200)	SRID=-1;LINESTRING(20 200,110 200,110 110,20 20,200 20,110 110,110 200,200 200)	0FFFFF102
SRID=-1;MULTIPOINT(50 250,90 220,130 190)	SRID=-1;LINESTRING(90 80,160 150,300 150,340 150,340 240)	FF0FFF102
SRID=-1;MULTIPOINT(180 180,230 130,280 80)	SRID=-1;LINESTRING(90 80,160 150,300 150,340 150,340 240)	FF0FFF102
SRID=-1;MULTIPOINT(50 120,90 80,130 40)	SRID=-1;LINESTRING(90 80,160 150,300 150,340 150,340 240)	F00FFF102
SRID=-1;MULTIPOINT(300 280,340 240,380 200)	SRID=-1;LINESTRING(90 80,160 150,300 150,340 150,340 240)	F00FFF102
SRID=-1;MULTIPOINT(230 150,260 120,290 90)	SRID=-1;LINESTRING(90 80,160 150,300 150,340 150,340 240)	0F0FFF102
SRID=-1;MULTIPOINT(200 190,240 150,270 110)	SRID=-1;LINESTRING(90 80,160 150,300 150,340 150,340 240)	0F0FFF102
SRID=-1;MULTIPOINT(160 150,190 120,220 90)	SRID=-1;LINESTRING(90 80,160 150,300 150,340 150,340 240)	0F0FFF102
SRID=-1;MULTIPOINT(120 190,160 150,200 110)	SRID=-1;LINESTRING(90 80,160 150,300 150,340 150,340 240)	0F0FFF102
SRID=-1;MULTIPOINT(90 80,160 150,340 240)	SRID=-1;LINESTRING(90 80,160 150,300 150,340 150,340 240)	00FFFF1F2
SRID=-1;MULTIPOINT(90 80,160 150,300 150)	SRID=-1;LINESTRING(90 80,160 150,300 150,340 150,340 240)	00FFFF102
SRID=-1;MULTIPOINT(90 80,160 150,240 150)	SRID=-1;LINESTRING(90 80,160 150,300 150,340 150,340 240)	00FFFF102
SRID=-1;MULTIPOINT(90 80,130 120,210 150)	SRID=-1;LINESTRING(90 80,160 150,300 150,340 150,340 240)	00FFFF102
SRID=-1;MULTIPOINT(130 120,210 150,340 200)	SRID=-1;LINESTRING(90 80,160 150,300 150,340 150,340 240)	0FFFFF102
SRID=-1;MULTIPOINT(160 150,240 150,340 210)	SRID=-1;LINESTRING(90 80,160 150,300 150,340 150,340 240)	0FFFFF102
SRID=-1;MULTIPOINT(160 150,300 150,340 150)	SRID=-1;LINESTRING(90 80,160 150,300 150,340 150,340 240)	0FFFFF102
SRID=-1;MULTIPOINT(160 150,240 150,340 240)	SRID=-1;LINESTRING(90 80,160 150,300 150,340 150,340 240)	00FFFF102
SRID=-1;POINT(20 20)	SRID=-1;POINT(20 20)	0FFFFFFF2
SRID=-1;POINT(20 20)	SRID=-1;POINT(40 60)	FF0FFF0F2
SRID=-1;POINT(40 40)	SRID=-1;MULTIPOINT(20 20,80 80,20 120)	FF0FFF0F2
SRID=-1;POINT(20 20)	SRID=-1;MULTIPOINT(20 20,80 80,20 120)	0FFFFF0F2
SRID=-1;MULTIPOINT(40 40,80 60,120 100)	SRID=-1;MULTIPOINT(40 40,80 60,120 100)	0FFFFFFF2
SRID=-1;MULTIPOINT(40 40,80 60,120 100)	SRID=-1;MULTIPOINT(40 40,120 100,80 60)	0FFFFFFF2
SRID=-1;MULTIPOINT(40 40,60 100,100 60,120 120)	SRID=-1;MULTIPOINT(20 120,60 60,100 100,140 40)	FF0FFF0F2
SRID=-1;MULTIPOINT(20 20,80 70,140 120,200 170)	SRID=-1;MULTIPOINT(20 20,80 70,140 120,200 170)	0FFFFFFF2
SRID=-1;MULTIPOINT(20 20,140 120,80 70,200 170)	SRID=-1;MULTIPOINT(80 70,20 20,200 170,140 120)	0FFFFFFF2
SRID=-1;MULTIPOINT(20 20,80 70,140 120,200 170)	SRID=-1;MULTIPOINT(80 70,140 120)	0F0FFFFF2
SRID=-1;MULTIPOINT(80 70,20 20,200 170,140 120)	SRID=-1;MULTIPOINT(140 120,80 70)	0F0FFFFF2
SRID=-1;MULTIPOINT(80 70,20 20,200 170,140 120)	SRID=-1;MULTIPOINT(80 170,140 120,200 80)	0F0FFF0F2
SRID=-1;MULTIPOINT(80 70,20 20,200 170,140 120)	SRID=-1;MULTIPOINT(80 170,140 120,200 80,80 70)	0F0FFF0F2
\.
From dblasby at refractions.net  Tue Nov 12 17:56:38 2002
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Relate now working in Postgis
References: <5A94289A9268514C8D6C0F1FF44BA02701DD53@venus.VividSolutions.com> <3DD17BBC.8CC21E44@refractions.net> <3DD17C7E.2017E3A0@refractions.net>
Message-ID: <3DD18726.85E878F6@refractions.net>

I have a relate(geometry, geometry) function in PostGIS now.  It passes the 555 tests I previously sent
out.

Its a bit slow because of the PostGIS Geometry -> WKT -> WKT Reader -> GEOS geometry.

I  havent looked at any memory management issues...

dave



From nhv at cape.com  Tue Nov 12 18:43:35 2002
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Relate now working in Postgis
References: <5A94289A9268514C8D6C0F1FF44BA02701DD53@venus.VividSolutions.com> <3DD17BBC.8CC21E44@refractions.net> <3DD17C7E.2017E3A0@refractions.net> <3DD18726.85E878F6@refractions.net>
Message-ID: <10ef01c28aa5$55c2ec70$473dba8c@sfdev3>

David Blasby writes:

> I have a relate(geometry, geometry) function in PostGIS now.  
> It passes the 555 tests I previously sent  out.

Neat ! 

> Its a bit slow because of the PostGIS Geometry -> WKT -> WKT Reader -> GEOS geometry.

Being 'correct' is the important thing at this stage.

I predict we will see an order of magnitude speed improvement 
after a little restructuring  :-)

FYI - here is the 'top 10' as reported by gprof for a 1,000,000 point run 
of TestSweepLineSpeed on my system

  %   cumulative   self              self     total           
 time   seconds   seconds    calls   s/call   s/call  name    

 61.18     17.84    17.84 254555476     0.00     0.00  Coordinate::Coordinate(Coordinate const&)
 10.29     20.84     3.00 78696778     0.00     0.00  CoordinateList::get()
  7.82     23.12     2.28 78696778     0.00     0.00  CoordinateList::moveTo(int)
  6.96     25.15     2.03 78696778     0.00     0.00  CoordinateList::getAt(int)
  2.26     25.81     0.66 20465462     0.00     0.00  Envelope::init(double, double, double, double)
  1.75     26.32     0.51 13643640     0.00     0.00  Envelope::init(Coordinate, Coordinate)
  1.68     26.81     0.49  5176115     0.00     0.00  SegmentIntersector::addIntersections(Edge*, int, Edge*, int)
  1.51     27.25     0.44 17704454     0.00     0.00  RobustCGAlgorithms::orientationIndex(Coordinate, Coordinate, Coordinate)
  0.86     27.50     0.25  6821821     0.00     0.00  Envelope::overlaps(Envelope)
  0.72     27.71     0.21  6821820     0.00     0.00  Envelope::Envelope(Envelope const&)

Can't see why there are 254 times more calls to Coordinate() then there are points yet
Maybe my profiler is feeding me bad info

Norman




From dblasby at refractions.net  Tue Nov 12 18:55:56 2002
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Relate now working in Postgis
References: <5A94289A9268514C8D6C0F1FF44BA02701DD53@venus.VividSolutions.com> <3DD17BBC.8CC21E44@refractions.net> <3DD17C7E.2017E3A0@refractions.net> <3DD18726.85E878F6@refractions.net> <10ef01c28aa5$55c2ec70$473dba8c@sfdev3>
Message-ID: <3DD1950C.2E84ADFB@refractions.net>

I've also added the functions like disjoint() and relate(<pattern>).

All there is to do is:

1. write postgis->GEOS convert that uses a GeometryFactory()
2. Minor code clean ups
3. Makefile changes (to compile the .cpp wrapper)
4. testing on other platforms.
5. install instructions

dave



From pramsey at refractions.net  Wed Nov 13 22:55:38 2002
From: pramsey at refractions.net (Paul Ramsey)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Priorities
Message-ID: <3DD31EBA.6010501@refractions.net>

Could we get an update on current status and effort priorities? I would 
personally like to see some things prioritized to make bringing a 
GEOS-enabled version of PostGIS out possible.
To that end, the number one priority, I think, should be:

   Fix the bugs in the Geometry Factories, and stabilize the external 
interfaces so that future versions of GEOS can be slotted in without 
requiring simultaneous upgrades to PostGIS.

Thoughts?

P



From dblasby at refractions.net  Thu Nov 14 11:58:22 2002
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Priorities
References: <3DD31EBA.6010501@refractions.net>
Message-ID: <3DD3D62E.761DEA1F@refractions.net>

Paul Ramsey wrote:

>    Fix the bugs in the Geometry Factories, and stabilize the external
> interfaces so that future versions of GEOS can be slotted in without
> requiring simultaneous upgrades to PostGIS.

1.  GeometryFactory() class needs to be re-designed so that it doesnt
require copying so many objects.  (Plus debugging)
2.  Coordinate and Coordinate list need looking at too.
CoordinateList.get() looks like its constructing new Coordinates each time
(at least from the profiler output).  Most of the time is spent in
constructing Coordiates and getting them.
3. quick CoordinateList constructor for an array of struct {double x,y,z}
points.  That is, if there is a better way than just converting each point
into a Coordinate and adding it to a CoordinateList.

dave



From mbdavis at VividSolutions.com  Thu Nov 14 13:09:15 2002
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Priorities
Message-ID: <5A94289A9268514C8D6C0F1FF44BA0270FD414@venus.VividSolutions.com>

This all sounds good to me, guys.  

Yury, let's make Dave's list (below) the head of our priority list.  If you see something else that needs adding to the list, just let me know.

I have a comment on the design for #3 - will post it later today.

Martin Davis, Senior Technical Specialist
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


> -----Original Message-----
> From: David Blasby [mailto:dblasby@refractions.net]
> Sent: Thursday, November 14, 2002 8:58 AM
> To: geos-devel@geos.refractions.net
> Subject: Re: [geos-devel] Priorities
> 
> 
> Paul Ramsey wrote:
> 
> >    Fix the bugs in the Geometry Factories, and stabilize 
> the external
> > interfaces so that future versions of GEOS can be slotted in without
> > requiring simultaneous upgrades to PostGIS.
> 
> 1.  GeometryFactory() class needs to be re-designed so that it doesnt
> require copying so many objects.  (Plus debugging)
> 2.  Coordinate and Coordinate list need looking at too.
> CoordinateList.get() looks like its constructing new 
> Coordinates each time
> (at least from the profiler output).  Most of the time is spent in
> constructing Coordiates and getting them.
> 3. quick CoordinateList constructor for an array of struct 
> {double x,y,z}
> points.  That is, if there is a better way than just 
> converting each point
> into a Coordinate and adding it to a CoordinateList.
> 
> dave
> 
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
> 


From dblasby at refractions.net  Thu Nov 14 15:00:06 2002
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Coordinate & Coordinate list
Message-ID: <3DD400C6.611EC0F4@refractions.net>

I took a quick look at the CoordinateList class.

This seems like a fairly foundational class, and I think efficiency
improvements here would trickle up the system quite well.
Unfortunately,  changes could cause lots of changes to other portions of
code.

Java always passes things by reference, so in most cases it ought to be
okay to just move around pointers to objects instead of the object.
But, you'll have to be carefull about memory management & unexpected
changes to objects, and when to actually delete stuff.

In many cases, the objects are not allocated, de-allocated, or copied
often so it wouldnt be worth the effort to change them.

The obvious way to speed things up is to *never* copy coordinates if you
dont have to.  That means making the CoordinateList keep a list of
pointers to Coordinate, have set() take a pointer to a coordinate, and
get() return a pointer to coordinate.

How are things handled in objects like Linestring, linear ring, and
polygon.  Are they just carrying around a Coordinate list?  If so, it
should probably just be carrying around a pointer to a coordinate list.
That way copying, say, a linear ring would be very quick (just hard to
know when to actually delete the coordinate list).

Hopefully this will give us lots of speed ups and memory efficienty by
only changing a few things...


But I dont know what's actually using these things, so I could be
wrong.  What do you folks think?

dave
ps. a Geometry.DieDieDie() function might be needed to ensure that
memory is actually released.


{
Geometry *g1,*g2;

//make coodinates & coordinate lists

g1 = <create a geometry>
g2 = <create a geometry>

 IntersectionMatrix im(g1->relate(g2));

    //im will be released automagically when block ends

g1.DieDieDie();  // ensure that everything is actually released
g2.DieDieDie(); // including all the CoordinateList and Coordinates
}

We'll have to be careful that there are no "shared" Coordinates - ie. if
you union g1 and g2, the result should have all new coordinates instead
of re-using the old ones (because someone could de-allocate them when
you're not looking).



From georef at tie.cl  Thu Nov 14 15:03:23 2002
From: georef at tie.cl (Juanse)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Cross posting
References: <3DD400C6.611EC0F4@refractions.net>
Message-ID: <01b701c28c18$e2ebc080$c800a8c0@referencia.cl>

sorry for cross posting, but no one seem to listen on the postgis list.

I am looking for Postgrass C drivers for linking Grass to Postgis and only
arrives to pdf files.

It seem that this taz.gz are non existent as independently but built in
Grass 5.1, am i right ore there is a place to search for it?

juanse
temuko-chile

----- Original Message -----
From: David Blasby <dblasby@refractions.net>
To: Geos-Devel (E-mail) <geos-devel@geos.refractions.net>
Sent: Thursday, November 14, 2002 5:00 PM
Subject: [geos-devel] Coordinate & Coordinate list


> I took a quick look at the CoordinateList class.
>
> This seems like a fairly foundational class, and I think efficiency
> improvements here would trickle up the system quite well.
> Unfortunately,  changes could cause lots of changes to other portions of
> code.
>
> Java always passes things by reference, so in most cases it ought to be
> okay to just move around pointers to objects instead of the object.
> But, you'll have to be carefull about memory management & unexpected
> changes to objects, and when to actually delete stuff.
>
> In many cases, the objects are not allocated, de-allocated, or copied
> often so it wouldnt be worth the effort to change them.
>
> The obvious way to speed things up is to *never* copy coordinates if you
> dont have to.  That means making the CoordinateList keep a list of
> pointers to Coordinate, have set() take a pointer to a coordinate, and
> get() return a pointer to coordinate.
>
> How are things handled in objects like Linestring, linear ring, and
> polygon.  Are they just carrying around a Coordinate list?  If so, it
> should probably just be carrying around a pointer to a coordinate list.
> That way copying, say, a linear ring would be very quick (just hard to
> know when to actually delete the coordinate list).
>
> Hopefully this will give us lots of speed ups and memory efficienty by
> only changing a few things...
>
>
> But I dont know what's actually using these things, so I could be
> wrong.  What do you folks think?
>
> dave
> ps. a Geometry.DieDieDie() function might be needed to ensure that
> memory is actually released.
>
>
> {
> Geometry *g1,*g2;
>
> file://make coodinates & coordinate lists
>
> g1 = <create a geometry>
> g2 = <create a geometry>
>
>  IntersectionMatrix im(g1->relate(g2));
>
>     file://im will be released automagically when block ends
>
> g1.DieDieDie();  // ensure that everything is actually released
> g2.DieDieDie(); // including all the CoordinateList and Coordinates
> }
>
> We'll have to be careful that there are no "shared" Coordinates - ie. if
> you union g1 and g2, the result should have all new coordinates instead
> of re-using the old ones (because someone could de-allocate them when
> you're not looking).
>
>
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel


---
Outgoing mail is certified Virus Free.
Checked by AVG anti-virus system (http://www.grisoft.com).
Version: 6.0.417 / Virus Database: 233 - Release Date: 09/11/02



From mbdavis at VividSolutions.com  Thu Nov 14 16:53:10 2002
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Coordinate & Coordinate list
Message-ID: <5A94289A9268514C8D6C0F1FF44BA02701DD58@venus.VividSolutions.com>

I've looked at the implementation of CoordinateList.  It seems to provide the semantics that I had in mind for CoordinateLists (with one exception, discussed below).  These semantics were based on the following design requirements:

CoordinateList should provide an abstract wrapper to hide the actual implementation of lists of Coordinates, and to take care of memory management. This allows clients with their own pointlist structures to pass them into JTS without copying them.  A default implementation will be provided to support clients with no structure of their own, and also for internal use in GEOS.  

CoordinateLists are immutable - in the few cases in GEOS where it is required to change the value of one or many coordinates in a Geometry, a new CoordinateList will be created and the old one deleted.  

It is up to the implementation of CoordinateList subclasses how they handle the delete operator.  A CoordinateList that wrappers a client pointlist will probably not delete that memory when the wrapper object is deleted.  The GEOS-provided concrete CoordinateList *will* delete its list of points.  

For efficiency, CoordinateList point storage should be implemented as an array of Coordinate values (NOT a list of pointers to coordinates).

GEOS Geometry objects "own" their CoordinateLists.  All CoordinateLists are deleted when the Geometry itself is deleted.  CoordinateLists are not shared - when new Geometrys are constructed (e.g in the overlay methods) new CoordinateLists will be constructed internally for the new Geometry.

The thing GEOS is currently missing is defining CoordinateList as an interface class (ie. class containing only pure virtual functions).  The current CoordinateList implementation would be provided as a default (called say ArrayCoordinateList). As an example, we should also provide a implementation which wrappers an array of POINT structs, and does not delete them.

Dave, I think this takes care of the issues you've raised below.  There's no need for a DieDieDie() function, since the regular Geometry delete operators will completely take care of deleting all storage associated with the Geometry.

Martin Davis, Senior Technical Specialist
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


> -----Original Message-----
> From: David Blasby [mailto:dblasby@refractions.net]
> Sent: Thursday, November 14, 2002 12:00 PM
> To: Geos-Devel (E-mail)
> Subject: [geos-devel] Coordinate & Coordinate list
> 
> 
> I took a quick look at the CoordinateList class.
> 
> This seems like a fairly foundational class, and I think efficiency
> improvements here would trickle up the system quite well.
> Unfortunately,  changes could cause lots of changes to other 
> portions of
> code.
> 
> Java always passes things by reference, so in most cases it 
> ought to be
> okay to just move around pointers to objects instead of the object.
> But, you'll have to be carefull about memory management & unexpected
> changes to objects, and when to actually delete stuff.
> 
> In many cases, the objects are not allocated, de-allocated, or copied
> often so it wouldnt be worth the effort to change them.
> 
> The obvious way to speed things up is to *never* copy 
> coordinates if you
> dont have to.  That means making the CoordinateList keep a list of
> pointers to Coordinate, have set() take a pointer to a coordinate, and
> get() return a pointer to coordinate.
> 
> How are things handled in objects like Linestring, linear ring, and
> polygon.  Are they just carrying around a Coordinate list?  If so, it
> should probably just be carrying around a pointer to a 
> coordinate list.
> That way copying, say, a linear ring would be very quick (just hard to
> know when to actually delete the coordinate list).
> 
> Hopefully this will give us lots of speed ups and memory efficienty by
> only changing a few things...
> 
> 
> But I dont know what's actually using these things, so I could be
> wrong.  What do you folks think?
> 
> dave
> ps. a Geometry.DieDieDie() function might be needed to ensure that
> memory is actually released.
> 
> 
> {
> Geometry *g1,*g2;
> 
> //make coodinates & coordinate lists
> 
> g1 = <create a geometry>
> g2 = <create a geometry>
> 
>  IntersectionMatrix im(g1->relate(g2));
> 
>     //im will be released automagically when block ends
> 
> g1.DieDieDie();  // ensure that everything is actually released
> g2.DieDieDie(); // including all the CoordinateList and Coordinates
> }
> 
> We'll have to be careful that there are no "shared" 
> Coordinates - ie. if
> you union g1 and g2, the result should have all new 
> coordinates instead
> of re-using the old ones (because someone could de-allocate them when
> you're not looking).
> 
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
> 


From dblasby at refractions.net  Thu Nov 14 18:09:52 2002
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Coordinate & Coordinate list
References: <5A94289A9268514C8D6C0F1FF44BA02701DD58@venus.VividSolutions.com>
Message-ID: <3DD42D40.23E6E11@refractions.net>

Good points, Martin.

The profing of GEOS seemed to indicate that most of the time was spent constructing and get()ing coordinates.  I think the get() function should be returning pointers to coordinates instead of actual coordinates (which require quite a bit of memory moving and allocation).

The important thing is to *not* return a Coordinate, but a pointer-to-coordinate.

Any word on why there were 250 million Coordinate constructions?

dave
ps. I checked  and Coordinate is only 24 bytes long (I thought there would be a bunch of other information in it for the class and class methods).

pps. you're right about array-of-pointers being less efficient.  I thought they would be more efficient because your memory space wouldnt be chopped-up so much, but after thinking about it, the malloc() free table should be pretty empty.




From mbdavis at VividSolutions.com  Thu Nov 14 18:30:39 2002
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Coordinate & Coordinate list
Message-ID: <5A94289A9268514C8D6C0F1FF44BA0270FD423@venus.VividSolutions.com>

Good point about returning a pointer instead of a value.  Or even better I think (certainly a more precise reflection of the usage), return a reference.

Not sure about the reason for the large number of Coordinate allocations.  I think we should make the obvious changes to the CoordinateList interface and then rerun the metrics, since things may change quite a bit.

Martin Davis, Senior Technical Specialist
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


> -----Original Message-----
> From: David Blasby [mailto:dblasby@refractions.net]
> Sent: Thursday, November 14, 2002 3:10 PM
> To: geos-devel@geos.refractions.net
> Subject: Re: [geos-devel] Coordinate & Coordinate list
> 
> 
> Good points, Martin.
> 
> The profing of GEOS seemed to indicate that most of the time 
> was spent constructing and get()ing coordinates.  I think the 
> get() function should be returning pointers to coordinates 
> instead of actual coordinates (which require quite a bit of 
> memory moving and allocation).
> 
> The important thing is to *not* return a Coordinate, but a 
> pointer-to-coordinate.
> 
> Any word on why there were 250 million Coordinate constructions?
> 
> dave
> ps. I checked  and Coordinate is only 24 bytes long (I 
> thought there would be a bunch of other information in it for 
> the class and class methods).
> 
> pps. you're right about array-of-pointers being less 
> efficient.  I thought they would be more efficient because 
> your memory space wouldnt be chopped-up so much, but after 
> thinking about it, the malloc() free table should be pretty empty.
> 
> 
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
> 


From nhv at cape.com  Thu Nov 14 18:42:04 2002
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Coordinate & Coordinate list
References: <5A94289A9268514C8D6C0F1FF44BA0270FD423@venus.VividSolutions.com>
Message-ID: <03e501c28c37$70582530$a637ba8c@sfdev3>

Martin Davis writes:
>
> Good point about returning a pointer instead of a value.  Or even better I think (certainly a more precise reflection of the
usage), return a reference.
>
> Not sure about the reason for the large number of Coordinate allocations.  I think we should make the obvious changes to the
CoordinateList interface and then rerun the metrics, since things may change quite a bit.

Changing the code to return a references for both the CoordinateLists
and the Coordinates themselves is a GOOD idea !

This will also make the 'C' code much more like the JAVA it
is trying to duplicate and should make 'speed' comparisons
more meaningful :-)

Norman




From dblasby at refractions.net  Thu Nov 14 18:51:41 2002
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Coordinate & Coordinate list
References: <5A94289A9268514C8D6C0F1FF44BA0270FD423@venus.VividSolutions.com>
Message-ID: <3DD4370D.A0444EB6@refractions.net>

Martin Davis wrote:

> Not sure about the reason for the large number of Coordinate allocations.  I think we should make the obvious changes to the CoordinateList interface and then rerun the metrics, since things may change quite a bit.

I thought it was actually calling the "new Coordinate(...)" constructor.  Now I'm thinking its actually calling a auto-generated "copy" constructor.

If you look at the CoordinateList class, the

get(int) method calls the get() method.  The get() method copy-creates a Coordinate, which might be  copy-created (again) in the get(int) method, and again copy-created in the caller's "=" assignment.

Norman, how (exactly) did you get gprof to profile the library calls to get your profile results.

dave



From nhv at cape.com  Thu Nov 14 19:00:30 2002
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Coordinate & Coordinate list
References: <5A94289A9268514C8D6C0F1FF44BA0270FD423@venus.VividSolutions.com> <3DD4370D.A0444EB6@refractions.net>
Message-ID: <041201c28c3a$03dd45e0$a637ba8c@sfdev3>

David Blasby writes:


> Martin Davis wrote:
>
> > Not sure about the reason for the large number of Coordinate allocations.  I think we should make the obvious changes to the
CoordinateList interface and then rerun the metrics, since things may change quite a bit.
>
> I thought it was actually calling the "new Coordinate(...)" constructor.  Now I'm thinking its actually calling a auto-generated
"copy" constructor.
>
> If you look at the CoordinateList class, the
>
> get(int) method calls the get() method.  The get() method copy-creates a Coordinate, which might be  copy-created (again) in the
get(int) method, and again copy-created in the caller's "=" assignment.


Yes I believe this is exactly what is going on
FWI - I dumped the assembly for the Coordinate functions
and this is what led me to say

"there seems to be a LOT  of information being passed on the stack in
GEOS which doesn't necessarily need to be."   in an earlier message


> Norman, how (exactly) did you get gprof to profile the library calls to get your profile results.

you add the profiling statistics gathering flag to the compiler options

-pg

do
% make clean && make

Run the program as usual

then run gprof on the resulting 'profiler statistics' file

on my system this is

% gprof executable_file gmon.out > humman_readable_file

% info gprof   should give you all you need to know

Norman




From dblasby at refractions.net  Thu Nov 14 19:15:17 2002
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Coordinate & Coordinate list (20% faster now)
References: <5A94289A9268514C8D6C0F1FF44BA0270FD423@venus.VividSolutions.com> <3DD4370D.A0444EB6@refractions.net>
Message-ID: <3DD43C95.388F54D9@refractions.net>

I tested my theory:


50,000 points TestSweepLineSpeed

takes about 10.2 seconds on my machine

I changed CoordinateList's getAt(int) from:

Coordinate CoordinateList::getAt(int pos)
{
        moveTo(pos);
        return get();
}

to:

Coordinate CoordinateList::getAt(int pos)
{
    if ((pos>vect->size()-1) || (pos<0) )
         throw "Invalid argument: out of bounds\n" ;
    else
        current=pos;
    return (*vect)[current];
}

This is *exactly* the same code, but I pulled the MoveTo() and get() into the function.  This should only really save 2 function call overheads and one call to the copy constructor.

The results is 8.2 seconds.  Thats 20% faster!!!

So, the CooridinateList is a pretty key code portion!


We could probably save a bunch more time by:
    actually implementing the vector in the class (save a bunch of class calling overhead)
    returning pointers instead of actual objects


I'd love to see the Copy Constructor called only 50,000 times for a 50,000 point input set.

dave



From nhv at cape.com  Thu Nov 14 19:18:04 2002
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Coordinate & Coordinate list (20% faster now)
References: <5A94289A9268514C8D6C0F1FF44BA0270FD423@venus.VividSolutions.com> <3DD4370D.A0444EB6@refractions.net> <3DD43C95.388F54D9@refractions.net>
Message-ID: <049501c28c3c$780c17a0$a637ba8c@sfdev3>

David Blasby writes:

> I tested my theory:
>
>
> 50,000 points TestSweepLineSpeed
>
> takes about 10.2 seconds on my machine
>
> I changed CoordinateList's getAt(int) from:
>
> Coordinate CoordinateList::getAt(int pos)
> {
>         moveTo(pos);
>         return get();
> }
>
> to:
>
> Coordinate CoordinateList::getAt(int pos)
> {
>     if ((pos>vect->size()-1) || (pos<0) )
>          throw "Invalid argument: out of bounds\n" ;
>     else
>         current=pos;
>     return (*vect)[current];
> }
>
> This is *exactly* the same code, but I pulled the MoveTo() and get() into the function.  This should only really save 2 function
call overheads and one call to the copy constructor.
>
> The results is 8.2 seconds.  Thats 20% faster!!!
>
> So, the CooridinateList is a pretty key code portion!
>
>
> We could probably save a bunch more time by:
>     actually implementing the vector in the class (save a bunch of class calling overhead)
>     returning pointers instead of actual objects
>
>
> I'd love to see the Copy Constructor called only 50,000 times for a 50,000 point input set.
>
> dave
>
>
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
>



From mbdavis at VividSolutions.com  Thu Nov 14 19:17:43 2002
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Coordinate & Coordinate list (20% faster now)
Message-ID: <5A94289A9268514C8D6C0F1FF44BA0270FD42B@venus.VividSolutions.com>

Excellent - shows we're on the right track.

I wonder how much ditching the use of vector really saves?  Aren't most of the vector functions inlined?  However, it should be pretty easy & secure to implement a coordinate array directly instead of a vector, so it's worth trying.

Martin Davis, Senior Technical Specialist
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


> -----Original Message-----
> From: David Blasby [mailto:dblasby@refractions.net]
> Sent: Thursday, November 14, 2002 4:15 PM
> To: geos-devel@geos.refractions.net
> Subject: Re: [geos-devel] Coordinate & Coordinate list (20% 
> faster now)
> 
> 
> I tested my theory:
> 
> 
> 50,000 points TestSweepLineSpeed
> 
> takes about 10.2 seconds on my machine
> 
> I changed CoordinateList's getAt(int) from:
> 
> Coordinate CoordinateList::getAt(int pos)
> {
>         moveTo(pos);
>         return get();
> }
> 
> to:
> 
> Coordinate CoordinateList::getAt(int pos)
> {
>     if ((pos>vect->size()-1) || (pos<0) )
>          throw "Invalid argument: out of bounds\n" ;
>     else
>         current=pos;
>     return (*vect)[current];
> }
> 
> This is *exactly* the same code, but I pulled the MoveTo() 
> and get() into the function.  This should only really save 2 
> function call overheads and one call to the copy constructor.
> 
> The results is 8.2 seconds.  Thats 20% faster!!!
> 
> So, the CooridinateList is a pretty key code portion!
> 
> 
> We could probably save a bunch more time by:
>     actually implementing the vector in the class (save a 
> bunch of class calling overhead)
>     returning pointers instead of actual objects
> 
> 
> I'd love to see the Copy Constructor called only 50,000 times 
> for a 50,000 point input set.
> 
> dave
> 
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
> 


From nhv at cape.com  Thu Nov 14 19:21:28 2002
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Coordinate & Coordinate list (20% faster now)
References: <5A94289A9268514C8D6C0F1FF44BA0270FD423@venus.VividSolutions.com> <3DD4370D.A0444EB6@refractions.net> <3DD43C95.388F54D9@refractions.net>
Message-ID: <049a01c28c3c$f1a2f430$a637ba8c@sfdev3>

David Blasby writes:

> I tested my theory:
> > 
> I changed CoordinateList's getAt(int) from:
> 
> Coordinate CoordinateList::getAt(int pos)
> {
>         moveTo(pos);
>         return get();
> }
> 
> to:
> 
> Coordinate CoordinateList::getAt(int pos)
> {
>     if ((pos>vect->size()-1) || (pos<0) )
>          throw "Invalid argument: out of bounds\n" ;
>     else
>         current=pos;
>     return (*vect)[current];
> }

I would like to see this written to be the equivalent of 

 Coordinate CoordinateList::getAt(int pos)
 {
     if ((pos>vect->size()-1) || (pos<0) )
          throw "Invalid argument: out of bounds\n" ;
     else
         current=pos;
     return &(*vect)[current];
 }

Then we should see a 'N'  instead of a '0.N' speed improvement factor

Cheers

Norman



From dblasby at refractions.net  Thu Nov 14 19:27:02 2002
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Coordinate & Coordinate list
References: <5A94289A9268514C8D6C0F1FF44BA0270FD423@venus.VividSolutions.com> <3DD4370D.A0444EB6@refractions.net> <041201c28c3a$03dd45e0$a637ba8c@sfdev3>
Message-ID: <3DD43F56.FA119B64@refractions.net>

Norman Vine wrote:

> > Norman, how (exactly) did you get gprof to profile the library calls to get your profile results.
>
> you add the profiling statistics gathering flag to the compiler options
>
> -pg
>
> do
> % make clean && make
>
> Run the program as usual
>
> then run gprof on the resulting 'profiler statistics' file
>
> on my system this is
>
> % gprof executable_file gmon.out > humman_readable_file
>
> % info gprof   should give you all you need to know

I've done this, but I dont get results from calls within the GEOS library.  For example, my run of TestSweepLineSpeed gives (actually
lt-TestSweepLineSpeed):


  %   cumulative   self              self     total
 time   seconds   seconds    calls  Ts/call  Ts/call  name
  0.00      0.00     0.00        6     0.00     0.00  data_start
  0.00      0.00     0.00        1     0.00     0.00  run(int, GeometryFactory *)

Do you do something special to get a statically linked version of GEOS used?

dave




From nhv at cape.com  Thu Nov 14 19:26:29 2002
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Coordinate & Coordinate list (20% faster now)
References: <5A94289A9268514C8D6C0F1FF44BA0270FD42B@venus.VividSolutions.com>
Message-ID: <04ab01c28c3d$a49fe070$a637ba8c@sfdev3>

Martin Davis writes:

> Excellent - shows we're on the right track.
>
> I wonder how much ditching the use of vector really saves?  Aren't most of the vector functions inlined?  However, it should be
pretty easy & secure to implement a coordinate array directly instead of a vector, so it's worth trying.

The STL vector implementation is about as good as you can get

FWIW
I did a massive rewrite inlining all of the Coordinate and CoordinateList
and put the moveto() in all of the low level functions and only got a 30-40%
speedup.  We are looking for an ORDER of MAGNITUDE speedup so I
didn't bother to report my results.

See my earlier post for what I think we need to do to get the BIG BOOST

Cheers

Norman




From dblasby at refractions.net  Thu Nov 14 19:31:07 2002
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Coordinate & Coordinate list (20% faster now)
References: <5A94289A9268514C8D6C0F1FF44BA0270FD423@venus.VividSolutions.com> <3DD4370D.A0444EB6@refractions.net> <3DD43C95.388F54D9@refractions.net> <049a01c28c3c$f1a2f430$a637ba8c@sfdev3>
Message-ID: <3DD4404B.4583FC5D@refractions.net>

>  Coordinate *CoordinateList::getAt(int pos)
>  {
>      if ((pos>vect->size()-1) || (pos<0) )
>           throw "Invalid argument: out of bounds\n" ;
>      else
>          current=pos;
>      return &(*vect)[current];
>  }

Yes - this is exactly what I'm saying.  There's probably a bunch of other
places further "up-stream" that would have to be changed as well (so
you're not copying coordinates there too).

The reason I'm looking at the CoordinateList and copy Constructor  so
hard is because your results say it spent 72% of its time there!

dave



From nhv at cape.com  Thu Nov 14 19:31:15 2002
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Coordinate & Coordinate list
References: <5A94289A9268514C8D6C0F1FF44BA0270FD423@venus.VividSolutions.com> <3DD4370D.A0444EB6@refractions.net> <041201c28c3a$03dd45e0$a637ba8c@sfdev3> <3DD43F56.FA119B64@refractions.net>
Message-ID: <04be01c28c3e$4f4a8520$a637ba8c@sfdev3>

David Blasby writes:

>
> I've done this, but I dont get results from calls within the GEOS library.  For example, my run of TestSweepLineSpeed gives
(actually
> lt-TestSweepLineSpeed):
>
>
>   %   cumulative   self              self     total
>  time   seconds   seconds    calls  Ts/call  Ts/call  name
>   0.00      0.00     0.00        6     0.00     0.00  data_start
>   0.00      0.00     0.00        1     0.00     0.00  run(int, GeometryFactory *)
>
> Do you do something special to get a statically linked version of GEOS used?

DOH - did I did forget to mention that

Sorry :-)

Norman

Here is my Test /  Makefile.am
I copied TestLineSweep,cpp into the test directory


noinst_PROGRAMS = CTS SimpleWKTTester XMLTester TestSweepLineSpeed

LIBS = ../geom/libgeos.la

CTS_SOURCES = CTS.cpp
CTS_LDADD = $(LIBS)
CTS_LDFLAGS += -Wl,--allow-multiple-definition

SimpleWKTTester_SOURCES = SimpleWKTTester.cpp
SimpleWKTTester_LDADD = $(LIBS)
SimpleWKTTester_LDFLAGS += -Wl,--allow-multiple-definition

XMLTester_SOURCES = XMLTester.cpp
XMLTester_LDADD = $(LIBS)
XMLTester_LDFLAGS += -Wl,--allow-multiple-definition

TestSweepLineSpeed_SOURCES = TestSweepLineSpeed.cpp
TestSweepLineSpeed_LDADD = $(LIBS)
TestSweepLineSpeed_LDFLAGS += -Wl,--allow-multiple-definition

INCLUDES = -I../headers
INCLUDES += -I../io/markup





From mbdavis at VividSolutions.com  Thu Nov 14 19:40:07 2002
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Explicit exceptions in GEOS
Message-ID: <5A94289A9268514C8D6C0F1FF44BA0270FD42C@venus.VividSolutions.com>

Currently in the code there are all kinds of exceptions thrown which are simply strings.  We should replace these with an explicit exception class hierarchy.  As far as I know C++ doesn't provide any exception hierarchy by default, so we'll have to pretty much build our own.

I suggest at least the following:

GEOSException 
	ArrayIndexOutOfBoundsException
	TopologyException

We can add others as needed.

The signature should look like:  

GEOSException(char *msg);  // copies string
char *getMsg()

... maybe other stuff.  I have an existing Exception base class I can contribute - it's attached.
 <<exception.h>> 


Martin Davis, Senior Technical Specialist
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com

-------------- next part --------------
A non-text attachment was scrubbed...
Name: exception.h
Type: application/octet-stream
Size: 2193 bytes
Desc: exception.h
Url : http://lists.osgeo.org/pipermail/geos-devel/attachments/20021114/915fd244/exception.obj
From mbdavis at VividSolutions.com  Thu Nov 14 19:48:19 2002
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Issue with returning Coordinate * rather than value
Message-ID: <5A94289A9268514C8D6C0F1FF44BA02701DD5C@venus.VividSolutions.com>

One concern I have with the idea of changing all getCoordinate calls to return a ref rather than a value is this kills immutability of Geometrys.  Clients can change Coordinates without the Geometry knowing about it, which could result in internal errors.  JTS does currently allow this as well, but I'm not too happy about it.  In C++ we have the opportunity to easily make this secure, which might be nice to take advantage of.

What do people think - is security more important than performance?

Is there a way to have both, perhaps by having a Coordinate* function only available to friends of the CoordinateList class?



Martin Davis, Senior Technical Specialist
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com



From pramsey at refractions.net  Thu Nov 14 19:57:48 2002
From: pramsey at refractions.net (Paul Ramsey)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Issue with returning Coordinate * rather than value
References: <5A94289A9268514C8D6C0F1FF44BA02701DD5C@venus.VividSolutions.com>
Message-ID: <3DD4468C.6050001@refractions.net>

Martin Davis wrote:

 > What do people think - is security more important than performance?

Well, by "security" you seem to mean "protecting people from doing 
stupid things to themselves" by messing with underlying structures. I 
think we publish an API and we tell them the dangers of messing with 
underlying structures, and we have done due diligence then...

-- 
       __
      /
      | Paul Ramsey
      | Refractions Research
      | Email: pramsey@refractions.net
      | Phone: (250) 885-0632
      \_



From mbdavis at VividSolutions.com  Thu Nov 14 20:38:35 2002
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Issue with returning Coordinate * rather than value
Message-ID: <5A94289A9268514C8D6C0F1FF44BA02701DD5E@venus.VividSolutions.com>

Yep, that's what I meant.  Ok, I guess I can live with that... 

On a philosophical note, I always prefer solutions that help save programmers from shooting themselves in the foot... seems to me that most of the history of the development of programming languages is concerned with doing exactly that, and it's nice to learn from that trend.  But timelines are short - next release, I guess.  The nasty thing is that once this horse is out of the door, it's disappeared around the bend never to be seen again...

Martin Davis, Senior Technical Specialist
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


> -----Original Message-----
> From: Paul Ramsey [mailto:pramsey@refractions.net]
> Sent: Thursday, November 14, 2002 4:58 PM
> To: geos-devel@geos.refractions.net
> Subject: Re: [geos-devel] Issue with returning Coordinate * 
> rather than
> value
> 
> 
> Martin Davis wrote:
> 
>  > What do people think - is security more important than performance?
> 
> Well, by "security" you seem to mean "protecting people from doing 
> stupid things to themselves" by messing with underlying structures. I 
> think we publish an API and we tell them the dangers of messing with 
> underlying structures, and we have done due diligence then...
> 
> -- 
>        __
>       /
>       | Paul Ramsey
>       | Refractions Research
>       | Email: pramsey@refractions.net
>       | Phone: (250) 885-0632
>       \_
> 
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
> 


From nhv at cape.com  Thu Nov 14 20:44:24 2002
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Coordinate & Coordinate list (20% faster now)
References: <5A94289A9268514C8D6C0F1FF44BA0270FD423@venus.VividSolutions.com> <3DD4370D.A0444EB6@refractions.net> <3DD43C95.388F54D9@refractions.net> <049a01c28c3c$f1a2f430$a637ba8c@sfdev3> <3DD4404B.4583FC5D@refractions.net>
Message-ID: <052a01c28c48$87710460$a637ba8c@sfdev3>

David Blasby writesL

> >  Coordinate *CoordinateList::getAt(int pos)
> >  {
> >      if ((pos>vect->size()-1) || (pos<0) )
> >           throw "Invalid argument: out of bounds\n" ;
> >      else
> >          current=pos;
> >      return &(*vect)[current];
> >  }
> 
> Yes - this is exactly what I'm saying.  There's probably a bunch of other
> places further "up-stream" that would have to be changed as well (so
> you're not copying coordinates there too).
> 
> The reason I'm looking at the CoordinateList and copy Constructor  so
> hard is because your results say it spent 72% of its time there!

Here is a first stab at a Coordinate class that might make the above 
easier to accomplish

Norman


const double DoubleNotANumber = -1;

class Coordinate {
public:
    double data[3];

    enum {PX, PY, PZ};

    inline static Coordinate getNull(void){
        return Coordinate(DoubleNotANumber,DoubleNotANumber,DoubleNotANumber);
    }
    
    Coordinate(){
        setx(0.0);
        sety(0.0);
        setz(DoubleNotANumber);
    }
    Coordinate(double xNew, double yNew, double zNew=DoubleNotANumber){
        setx(xNew);
        sety(yNew);
        setz(zNew);
    }
    Coordinate(const Coordinate& c){
        setx(c.x());
        sety(c.y());
        setz(c.z());
    }
    
    void setCoordinate(Coordinate& other){
        setx(other.x());
        sety(other.y());
        setz(other.z());
    }
    
    void setNull(void){
        setx(DoubleNotANumber);
        sety(DoubleNotANumber);
        setz(DoubleNotANumber);
    }
    
    double x() const { return data[PX]; }
    double y() const { return data[PY]; }
    double z() const { return data[PZ]; }

    void setx(const double& x){ data[PX] = x; }
    void sety(const double& y){ data[PY] = y; }
    void setz(const double& z){ data[PZ] = z; }
    
    double& operator [] (int i){
        assert(! (i < PX || i > PZ));
        return data[i];
    }
    double operator[] (int i) const{
        assert(! (i < PX || i > PZ));
        return data[i];
    }

    inline double *get() { return data; }
    
    bool equals2D(Coordinate& other){
        if (x() != other.x()) return false;
        if (y() != other.y()) return false;
        return true;
    }
    
    bool equals3D(Coordinate& other){
        return (x() == other.x()) && (y() == other.y())  &&
                (( z() == other.z()) ||
                 (z()==DoubleNotANumber && other.z()==DoubleNotANumber)  );
    }   
  
    double distance(Coordinate& p){
        double dx = x() - p.x();
        double dy = y() - p.y();
        return sqrt(dx * dx + dy * dy);
    }

    int compareTo(Coordinate& other){
        if (x() < other.x()) return -1;
        if (x() > other.x()) return 1;
        if (y() < other.y()) return -1;
        if (y() > other.y()) return 1;
        return 0;
    }
    
    void makePrecise();
    
    string toString();
};




From mbdavis at VividSolutions.com  Thu Nov 14 20:51:20 2002
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Recap of requirements for Geometry constructors
Message-ID: <5A94289A9268514C8D6C0F1FF44BA02701DD5D@venus.VividSolutions.com>

I'm not sure if it's been made clear or not, but I thought I'd summarize the requirements for Geometry constructors:

The goal is to make constructors as efficient as possible. This means that whereever possible the constructor should avoid copying point lists.  The decision of whether or not to copy can usually be left to the client.  In general, if a CoordinateList is passed to a constructor, it is not copied and is "owned" by the Geometry object (e.g. will be deleted when the Geometry is).  The same goes for LinearRings passed to Polygons, etc.

The general pattern for the constructors of Geometry classes is:

LineString::LineString()
	this(new ArrayCoordinateList(0))

LineString::LineString(const LineString &ls):  
{
	this(new ArrayCoordinateList(ls.points));		// ls.points will be copied by ArrayCoordinateList constructor
}

// pts is owned by this object and will be deleted by the destructor.   User should provide copy if necessary.
LineString::LineString(CoordinateList pts, PrecisionModel precisionModel, int SRID):
						Geometry(precisionModel, SRID) 
{
	points = pts;
}

LineString::~LineString()
{
	delete points;
}


Not sure, but maybe points can be a reference rather than a pointer?

Martin Davis, Senior Technical Specialist
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com



From ybychkov at direct.ca  Fri Nov 15 01:12:49 2002
From: ybychkov at direct.ca (Yury A. Bychkov)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Re:Explicit exceptions in GEOS
References: <5A94289A9268514C8D6C0F1FF44BA0270FD42C@venus.VividSolutions.com>
Message-ID: <017501c28c6e$0786a130$b9354d18@yury>

I agree with that completely, but haven't got to that stage in porting yet. Some
exceptions (e.g. ParseException) are already there; your hierarchy and base
class look good for others.

Yury

----- Original Message -----
From: "Martin Davis" <mbdavis@VividSolutions.com>
To: "Geos-Devel (E-mail)" <geos-devel@geos.refractions.net>
Sent: Thursday, November 14, 2002 4:40 PM
Subject: [geos-devel] Explicit exceptions in GEOS


Currently in the code there are all kinds of exceptions thrown which are simply
strings.  We should replace these with an explicit exception class hierarchy.
As far as I know C++ doesn't provide any exception hierarchy by default, so
we'll have to pretty much build our own.

I suggest at least the following:

GEOSException
ArrayIndexOutOfBoundsException
TopologyException

We can add others as needed.

The signature should look like:

GEOSException(char *msg);  // copies string
char *getMsg()

... maybe other stuff.  I have an existing Exception base class I can
contribute - it's attached.
 <<exception.h>>


Martin Davis, Senior Technical Specialist
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com





From ybychkov at direct.ca  Fri Nov 15 01:15:20 2002
From: ybychkov at direct.ca (Yury A. Bychkov)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Re:Priorities
References: <5A94289A9268514C8D6C0F1FF44BA0270FD414@venus.VividSolutions.com>
Message-ID: <019601c28c6e$9ffca0e0$b9354d18@yury>

> Yury, let's make Dave's list (below) the head of our priority list.
Sure. The list looks good.

> If you see something else that needs adding to the list, just let me know.
We can discuss it during our phone meeting tomorrow.

>Martin Davis, Senior Technical Specialist
>Vivid Solutions Inc.
>Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
>Phone: (250) 385 6040    Fax: (250) 385 6046
>EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


> -----Original Message-----
> From: David Blasby [mailto:dblasby@refractions.net]
> Sent: Thursday, November 14, 2002 8:58 AM
> To: geos-devel@geos.refractions.net
> Subject: Re: [geos-devel] Priorities
> 
> 
> Paul Ramsey wrote:
> 
> >    Fix the bugs in the Geometry Factories, and stabilize 
> the external
> > interfaces so that future versions of GEOS can be slotted in without
> > requiring simultaneous upgrades to PostGIS.
> 
> 1.  GeometryFactory() class needs to be re-designed so that it doesnt
> require copying so many objects.  (Plus debugging)
> 2.  Coordinate and Coordinate list need looking at too.
> CoordinateList.get() looks like its constructing new 
> Coordinates each time
> (at least from the profiler output).  Most of the time is spent in
> constructing Coordiates and getting them.
> 3. quick CoordinateList constructor for an array of struct 
> {double x,y,z}
> points.  That is, if there is a better way than just 
> converting each point
> into a Coordinate and adding it to a CoordinateList.
> 
> dave
> 
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
> 





From dblasby at refractions.net  Fri Nov 15 12:21:07 2002
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Issue with returning Coordinate * rather than value
References: <5A94289A9268514C8D6C0F1FF44BA02701DD5E@venus.VividSolutions.com>
Message-ID: <3DD52D03.61B8E92D@refractions.net>

Martin Davis wrote:

> Yep, that's what I meant.  Ok, I guess I can live with that...
>
> On a philosophical note, I always prefer solutions that help save programmers from shooting themselves in the foot... seems to me that most of the history of the development of programming languages is concerned with doing exactly that, and it's nice to learn from that trend.  But timelines are short - next release, I guess.  The nasty thing is that once this horse is out of the door, it's disappeared around the bend never to be seen again...

I agree with you here martin, but I am really wanting to get performance up.

When would modifying internal structures be a problem?

{
    Geometry *g1;
    Geometry *g2;
    Geometry *g3;

    g1  = ....;
    g2  = ...;


    g3 = g1->intersect(g2);

    // mess around with some of g1's coordinates BAD ME

        CoordinateList coords = g1->getPoints().toCoordinateList(); //or whatever it is
        coords.getAt(1)->x = 25;  // EVIL LAUGH

    delete g3;

    g3 = g1->intersect(g2);
   double len = g1->length();
}

This shouldnt give any funny results unless you're storing meta-information (like an index or graph) inside the geometries that would require re-calculating if the internal coordinate change.

We could have an alternate structure to CoordinateList that has an interface more like:

    Coordinate *getAt(int i);  // fast but a little dangerous
    Coordinate getAtSafe(int i); // or some such thing for evil programmers.

dave



From nhv at cape.com  Fri Nov 15 12:24:10 2002
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Issue with returning Coordinate * rather than value
References: <5A94289A9268514C8D6C0F1FF44BA02701DD5E@venus.VividSolutions.com> <3DD52D03.61B8E92D@refractions.net>
Message-ID: <019201c28ccb$d125f290$6e37ba8c@sfdev3>

David Blasby writes:
> 
> I agree with you here martin, but I am really wanting to get performance up.
> 
> We could have an alternate structure to CoordinateList that has an interface more like:
> 
>     Coordinate *getAt(int i);  // fast but a little dangerous
>     Coordinate getAtSafe(int i); // or some such thing for evil programmers.

< very minor mattter of style >

would we prefer to settle on something like

Coordinate *getAt(int i)  /// Safe
Coordinate *[int i]   /// DANGER !!!! super fast RAW access 

Cheers

Norman



From dblasby at refractions.net  Fri Nov 15 12:32:05 2002
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Issue with returning Coordinate * rather than value
References: <5A94289A9268514C8D6C0F1FF44BA02701DD5E@venus.VividSolutions.com> <3DD52D03.61B8E92D@refractions.net> <019201c28ccb$d125f290$6e37ba8c@sfdev3>
Message-ID: <3DD52F95.7B44FB76@refractions.net>

> Coordinate *getAt(int i)  /// Safe
> Coordinate *[int i]   /// DANGER !!!! super fast RAW access

Yes - I like that. The getAt(int) should return a non-pointer or its should allocate a new
Cooridinate and return that.

Is the [int] method going to do range checking or are we just going to assume the caller is
competent?

dave



From mbdavis at VividSolutions.com  Fri Nov 15 12:46:57 2002
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Issue with returning Coordinate * rather than value
Message-ID: <5A94289A9268514C8D6C0F1FF44BA0270FD438@venus.VividSolutions.com>

Yep, JTS objects cache data internally about the values of their Coordinates.  (The best example is the bounding box).  If Coordinates change without the knowledge of the object, this makes the cached data inconsistent.  There's a possibility of adding more cached data as well - a primary example would be to cache the fact that a geometry is valid.

We currently do provide a geometryChanged() method in JTS 1.2 to allow users to manually flush the cached data.  This is fine for the "user beware" approach, but it would be nice to have an API that allowed us to do better.

(See my following note about how we can get this as a bonus side effect of dealing with another problem).

Martin Davis, Senior Technical Specialist
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


> -----Original Message-----
> From: David Blasby [mailto:dblasby@refractions.net]
> Sent: Friday, November 15, 2002 9:21 AM
> To: geos-devel@geos.refractions.net
> Subject: Re: [geos-devel] Issue with returning Coordinate * 
> rather than
> value
> 
> 
> Martin Davis wrote:
> 
> > Yep, that's what I meant.  Ok, I guess I can live with that...
> >
> > On a philosophical note, I always prefer solutions that 
> help save programmers from shooting themselves in the foot... 
> seems to me that most of the history of the development of 
> programming languages is concerned with doing exactly that, 
> and it's nice to learn from that trend.  But timelines are 
> short - next release, I guess.  The nasty thing is that once 
> this horse is out of the door, it's disappeared around the 
> bend never to be seen again...
> 
> I agree with you here martin, but I am really wanting to get 
> performance up.
> 
> When would modifying internal structures be a problem?
> 
> {
>     Geometry *g1;
>     Geometry *g2;
>     Geometry *g3;
> 
>     g1  = ....;
>     g2  = ...;
> 
> 
>     g3 = g1->intersect(g2);
> 
>     // mess around with some of g1's coordinates BAD ME
> 
>         CoordinateList coords = 
> g1->getPoints().toCoordinateList(); //or whatever it is
>         coords.getAt(1)->x = 25;  // EVIL LAUGH
> 
>     delete g3;
> 
>     g3 = g1->intersect(g2);
>    double len = g1->length();
> }
> 
> This shouldnt give any funny results unless you're storing 
> meta-information (like an index or graph) inside the 
> geometries that would require re-calculating if the internal 
> coordinate change.
> 
> We could have an alternate structure to CoordinateList that 
> has an interface more like:
> 
>     Coordinate *getAt(int i);  // fast but a little dangerous
>     Coordinate getAtSafe(int i); // or some such thing for 
> evil programmers.
> 
> dave
> 
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
> 


From nhv at cape.com  Fri Nov 15 12:56:26 2002
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Issue with returning Coordinate * rather than value
References: <5A94289A9268514C8D6C0F1FF44BA02701DD5E@venus.VividSolutions.com> <3DD52D03.61B8E92D@refractions.net> <019201c28ccb$d125f290$6e37ba8c@sfdev3> <3DD52F95.7B44FB76@refractions.net>
Message-ID: <01d801c28cd0$52edfd50$6e37ba8c@sfdev3>

David Blasby writes:

> > Coordinate *getAt(int i)  /// Safe
> > Coordinate *[int i]   /// DANGER !!!! super fast RAW access
> 
> Yes - I like that. The getAt(int) should return a non-pointer or its should allocate a new
> Cooridinate and return that.
> 
> Is the [int] method going to do range checking or are we just going to assume the caller is
> competent?

Good question :-)

I usually just have it  return the underlying vector<> [] operator
if you want SAFE access DON'T use it !!

Norman



From mbdavis at VividSolutions.com  Fri Nov 15 12:55:40 2002
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Problem with returning Coordinate* from CoordinateList accessor
Message-ID: <5A94289A9268514C8D6C0F1FF44BA02701DD5F@venus.VividSolutions.com>

Dave says:

> Yes - I like that. The getAt(int) should return a non-pointer 
> or its should allocate a new Cooridinate and return that.

I've just realized a big problem with our current thoughts about how CoordinateLists return Coordinates.  We've been assuming that CoordinateList has a Coordinate* getAt(int i) method. The problem with this is that if the CoordinateList implementation is build on some structure which doesn't contain Coordinates (e.g. like POINT2D or something), we'd end up having to allocate a new Coordinate each time (and the caller would have to free it).  This would result in lots of needless malloc traffic, as well as being a likely source of memory bugs.  

I think this means that the only safe, general way of accessing Coordinates in a CoordinateList is by value.  Currently we have:

Coordinate CoordinateList::getAt(int i)

This probably results in all kinds of constructor calls, however.  To avoid this, we can provide a method:

void CoordinateList::getAt(int i, Coordinate& coord)  // calls coord.setX and setY directly

The caller would provide the Coordinate object to receive the value.  This lets the caller decide how it wants to manage memory.  In fact, in many cases in JTS, the caller can simply allocate a single Coordinate on the stack to receive the values of each coord as it iterates over a CoordinateList.

The by-value approach has another advantage as well - it provides complete encapsulation of the data inside the CoordinateList, thus providing us with a way to implement non-mutability, if needed. In fact, this is exactly the scheme I've been thinking of implementing in JTS, to support non-mutability.

The only other option I can see is to use some cheesy casting scheme inside CoordinateList, relying on the underlying implementation storing the ordinate values for each point in contiguous memory.  Yuck!


Martin Davis, Senior Technical Specialist
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com



From mbdavis at VividSolutions.com  Fri Nov 15 12:58:49 2002
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Issue with returning Coordinate * rather than value
Message-ID: <5A94289A9268514C8D6C0F1FF44BA0270FD43A@venus.VividSolutions.com>

I think we should assume the caller is competent.  Don't forget, the primary purpose of CoordinateList is to support GEOS algorithms, which we can assume to have been designed by a brilliant programmer who never makes mistakes.  8^)

Martin Davis, Senior Technical Specialist
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


> -----Original Message-----
> From: Norman Vine [mailto:nhv@cape.com]
> Sent: Friday, November 15, 2002 9:56 AM
> To: geos-devel@geos.refractions.net
> Subject: Re: [geos-devel] Issue with returning Coordinate * 
> rather than
> value
> 
> 
> David Blasby writes:
> 
> > > Coordinate *getAt(int i)  /// Safe
> > > Coordinate *[int i]   /// DANGER !!!! super fast RAW access
> > 
> > Yes - I like that. The getAt(int) should return a 
> non-pointer or its should allocate a new
> > Cooridinate and return that.
> > 
> > Is the [int] method going to do range checking or are we 
> just going to assume the caller is
> > competent?
> 
> Good question :-)
> 
> I usually just have it  return the underlying vector<> [] operator
> if you want SAFE access DON'T use it !!
> 
> Norman
> 
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
> 


From dblasby at refractions.net  Fri Nov 15 13:11:09 2002
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Problem with returning Coordinate* from CoordinateList 
 accessor
References: <5A94289A9268514C8D6C0F1FF44BA02701DD5F@venus.VividSolutions.com>
Message-ID: <3DD538BD.F1DF3432@refractions.net>

Martin,

I've been assuming that the only way to efficiently do the get() operator was to have actual Coordinates lying around in the CoordinateList.  If you have to make new coordinates everytime you do a get(), you're going to have a really really slow system due to malloc()ing on every call.

void CoordinateList::getAt(int i, Coordinate& coord)  // calls coord.setX and setY directly

This is certainly a workable solution in terms of style, but you'll probably find its even slower than it is now.
Right now, its just doing memcpy() on 24 bytes.  At least I'm assuming the compiler is smart enough to do this.

If you use the setX and setY and setZ methods, your call to getAt(int) is going to cause 3 more function calls + inefficiently copy the actual 24 bytes.

dave



From chodgson at refractions.net  Fri Nov 15 13:25:43 2002
From: chodgson at refractions.net (chodgson@refractions.net)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Problem with returning Coordinate* from CoordinateList accessor
In-Reply-To: <5A94289A9268514C8D6C0F1FF44BA02701DD5F@venus.VividSolutions.com>
References: <5A94289A9268514C8D6C0F1FF44BA02701DD5F@venus.VividSolutions.com>
Message-ID: <1037384743.3dd53c2726bfa@www>

Ok, I've been lurking on this list for a while now and I think I'd like to 
contribute a thought.

My understanding is that the reason for the "CoordinateList" class is to 
abstract the underlying data storage. However, the only reason for someone to 
implement a subclass of coordinate list would be to make use of the complex 
algorithms that JTS provides - all of which are going to need actual coordinate 
objects to do their work, no? Perhaps we cannot afford to abstract the the data 
access layer when our algorithms are going to be doing a LOT of data access.

It seems to me like it would be more efficient to copy all of one's points into 
Coordinate objects, once and for all, right at the start (in the CoordinateList 
constructor). Then, we could pass around references/pointers to the Coordinates 
without worrying about someone else owning them.

The only time this would be inefficient, I suppose, is if you were doing a sub-
linear-time operation... do we do many of those? We could always implement a 
subclass of coordinate list, with a different underlying data structure, which 
created the Coordinate objects as they were requested (with gets) and just kept 
a list of pointers to the Coordinates it allocated, so they could be destroyed 
when the List was destroyed. It could even be "smart" and cache the Coordinate 
objects in case they were retrieved again (unlikely to happen much in a sub-
linear-time operation).

Just my two cents.



From mbdavis at VividSolutions.com  Fri Nov 15 13:39:32 2002
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Problem with returning Coordinate* from CoordinateList accessor
Message-ID: <5A94289A9268514C8D6C0F1FF44BA0270FD43D@venus.VividSolutions.com>

Well, if you're right that makes the decision easy!  We just implement   Coordinate getAt(int i).

I would think the function calls in method #2 could be inlined out, however.  I'm hesitant to say a priori which method would be more efficient - compilers do some pretty clever things under the covers.  Probably the only way to say for sure is to try it and see. 

Martin Davis, Senior Technical Specialist
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


> -----Original Message-----
> From: David Blasby [mailto:dblasby@refractions.net]
> Sent: Friday, November 15, 2002 10:11 AM
> To: geos-devel@geos.refractions.net
> Subject: Re: [geos-devel] Problem with returning Coordinate* from
> CoordinateList accessor
> 
> 
> Martin,
> 
> I've been assuming that the only way to efficiently do the 
> get() operator was to have actual Coordinates lying around in 
> the CoordinateList.  If you have to make new coordinates 
> everytime you do a get(), you're going to have a really 
> really slow system due to malloc()ing on every call.
> 
> void CoordinateList::getAt(int i, Coordinate& coord)  // 
> calls coord.setX and setY directly
> 
> This is certainly a workable solution in terms of style, but 
> you'll probably find its even slower than it is now.
> Right now, its just doing memcpy() on 24 bytes.  At least I'm 
> assuming the compiler is smart enough to do this.
> 
> If you use the setX and setY and setZ methods, your call to 
> getAt(int) is going to cause 3 more function calls + 
> inefficiently copy the actual 24 bytes.
> 
> dave
> 
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
> 


From mbdavis at VividSolutions.com  Fri Nov 15 13:47:01 2002
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Problem with returning Coordinate* from CoordinateList accessor
Message-ID: <5A94289A9268514C8D6C0F1FF44BA02701DD60@venus.VividSolutions.com>

Good comments...    Your analysis certainly makes sense to me.  And it results in the cleanest, simplest implementation.  

So the two options are:
1. copy the coordinates once at the start of processing and then access them by pointer
2. don't copy the coordinates, but copy them one by one every time they are accessed

It certainly *seems* like #1 should be more efficient in almost all situations.  It's sometimes difficult to predict this kind of thing, however.  When Yury's finished rejigging the code to make the constructors and CoordinateList accessors non-copying, perhaps some more profiling will establish once and for all whether the initial copying of the point lists is a  bottleneck.

Martin Davis, Senior Technical Specialist
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


> -----Original Message-----
> From: chodgson@refractions.net [mailto:chodgson@refractions.net]
> Sent: Friday, November 15, 2002 10:26 AM
> To: geos-devel@geos.refractions.net
> Subject: Re: [geos-devel] Problem with returning Coordinate* from
> CoordinateList accessor
> 
> 
> Ok, I've been lurking on this list for a while now and I 
> think I'd like to 
> contribute a thought.
> 
> My understanding is that the reason for the "CoordinateList" 
> class is to 
> abstract the underlying data storage. However, the only 
> reason for someone to 
> implement a subclass of coordinate list would be to make use 
> of the complex 
> algorithms that JTS provides - all of which are going to need 
> actual coordinate 
> objects to do their work, no? Perhaps we cannot afford to 
> abstract the the data 
> access layer when our algorithms are going to be doing a LOT 
> of data access.
> 
> It seems to me like it would be more efficient to copy all of 
> one's points into 
> Coordinate objects, once and for all, right at the start (in 
> the CoordinateList 
> constructor). Then, we could pass around references/pointers 
> to the Coordinates 
> without worrying about someone else owning them.
> 
> The only time this would be inefficient, I suppose, is if you 
> were doing a sub-
> linear-time operation... do we do many of those? We could 
> always implement a 
> subclass of coordinate list, with a different underlying data 
> structure, which 
> created the Coordinate objects as they were requested (with 
> gets) and just kept 
> a list of pointers to the Coordinates it allocated, so they 
> could be destroyed 
> when the List was destroyed. It could even be "smart" and 
> cache the Coordinate 
> objects in case they were retrieved again (unlikely to happen 
> much in a sub-
> linear-time operation).
> 
> Just my two cents.
> 
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
> 


From nhv at cape.com  Tue Nov 19 00:06:36 2002
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Performance of GEOS compared to JTS (Report, Nov. 8)
References: <5A94289A9268514C8D6C0F1FF44BA0270FD3DD@venus.VividSolutions.com>
Message-ID: <031801c28f89$70b3fa90$6e37ba8c@sfdev3>

Martin Davis writes:

> For comparison purposes, here's the timings for JTS on the same numbers.  JTS now looks linear, just like GEOS. (I think we just
didn't go quite large enough last time).  It's still (a bit) faster than GEOS, though - and I'm running on a 1.1 GHz machine, not a
1.9 GHz box.  Maybe Java's just bettah...  8^)
>
> n Pts: 1000   Executed in 3014 ms
> n Pts: 2000   Executed in 91 ms
> n Pts: 4000   Executed in 50 ms
> n Pts: 8000   Executed in 110 ms
> n Pts: 16000   Executed in 210 ms
> n Pts: 32000   Executed in 411 ms
> n Pts: 64000   Executed in 801 ms
> n Pts: 128000   Executed in 2032 ms
> n Pts: 256000   Executed in 3545 ms

I did some major hacking on the code
machine: PIII 733 Cygwin gcc 3.2 -O3

n Pts: 1000  Executed in     10 ms.
n Pts: 2000  Executed in     30 ms.
n Pts: 4000  Executed in     60 ms.
n Pts: 8000  Executed in    140 ms.
n Pts: 16000  Executed in    330 ms.
n Pts: 32000  Executed in    680 ms.
n Pts: 64000  Executed in   1321 ms.
n Pts: 128000  Executed in   2834 ms.
n Pts: 256000  Executed in   5639 ms.


And here is the profiling result

Notice that the signOfDet2x2() is dominating like we would expect  :-)

I'll clean up what I did 'a little' and post a tarball somewhere tomorrow
so others can play.

Norman


Flat profile:

Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total
 time   seconds   seconds    calls   s/call   s/call  name
 79.17      0.95     0.95  4543842     0.00     0.00  RobustDeterminant::signOfDet2x2(double, double, double, double)
  5.83      1.02     0.07        2     0.04     0.04  Geometry::hasNullElements(CoordinateList)
  5.00      1.08     0.06        2     0.03     0.03  LineString::computeEnvelopeInternal()
  4.17      1.13     0.05  1327961     0.00     0.00  SegmentIntersector::addIntersections(Edge*, int, Edge*, int)
  3.33      1.17     0.04   511968     0.00     0.00  SegmentIntersector::isTrivialIntersection(Edge*, int, Edge*, int)
  2.50      1.20     0.03        1     0.03     0.03  GeometryTestFactory::createSineStar(double, double, double, double, int, int)
  0.00      1.20     0.00  1327965     0.00     0.00  LineIntersector::hasIntersection()
  0.00      1.20     0.00  1071957     0.00     0.00  LineIntersector::computeIntersection(CoordinateList*, int, CoordinateList*,
int)
  0.00      1.20     0.00  1071957     0.00     0.00  RobustLineIntersector::computeIntersect(Coordinate, Coordinate, Coordinate,
Coordinate)
  0.00      1.20     0.00   511981     0.00     0.00  LineIntersector::getIntersectionNum()
  0.00      1.20     0.00   256100     0.00     0.00  Quadrant::quadrant(double, double)
  0.00      1.20     0.00   256088     0.00     0.00  Quadrant::quadrant(Coordinate, Coordinate)
  0.00      1.20     0.00   256006     0.00     0.00  Coordinate::getNull()
  0.00      1.20     0.00   256000     0.00     0.00  RobustLineIntersector::computeIntersection(Coordinate, Coordinate, Coordinate)
  0.00      1.20     0.00     1242     0.00     0.00  sleLessThan(SweepLineEvent*, SweepLineEvent*)
  0.00      1.20     0.00     1242     0.00     0.00  SweepLineEvent::compareTo(SweepLineEvent*)



From nhv at cape.com  Tue Nov 19 10:42:13 2002
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Performance of GEOS compared to JTS (Report, Nov. 8)
References: <5A94289A9268514C8D6C0F1FF44BA0270FD3DD@venus.VividSolutions.com>
	<031801c28f89$70b3fa90$6e37ba8c@sfdev3>
Message-ID: <053d01c28fe2$3c27b010$6e37ba8c@sfdev3>

Norman Vine wrote:
> 
> I did some major hacking on the code
> machine: PIII 733 Cygwin gcc 3.2 -O3
> 
> 
> I'll clean up what I did 'a little' and post a tarball somewhere tomorrow
> so others can play.

Here is the promised tarball
This is not necessarily 'pretty' but should be useful
for comparison purposes  < This won't stay here long >
http://www.vso.cape.com/~nhv/files/geos-1.tar.gz

 
I am still surprised at how often some functions are called
signOfDet2x2                      13 times 
addIntersections           5

Note that before I did a little rearanging signOfDet2x2
was called 17 times per point but ...... since this code
is now dominated by the Determinate code if the Java
performance is still close My guess is that for some reason
the Java code is calling the determinate calculation far fewer 
times

Norman

this is against a 1000000 point SineStar

 %   cumulative   self              self     total           
 time   seconds   seconds    calls   s/call   s/call  name    
 75.24      1.55     1.55 13352204     0.00     0.00  RobustDeterminant::signOfDet2x2(double&, double&, double&, double&)
  9.71      1.75     0.20  5176115     0.00     0.00  SegmentIntersector::addIntersections(Edge*, int, Edge*, int)
  5.83      1.87     0.12        2     0.06     0.06  LineString::computeEnvelopeInternal()
  3.88      1.95     0.08        1     0.08     0.08  GeometryTestFactory::createSineStar(double, double, double, double, int, int)
  2.91      2.01     0.06  1999968     0.00     0.00  SegmentIntersector::isTrivialIntersection(Edge*, int, Edge*, int)
  0.97      2.03     0.02        2     0.01     0.01  Geometry::hasNullElements(CoordinateList)
  0.49      2.04     0.01        6     0.00     0.00  RobustCGAlgorithms::RobustCGAlgorithms()
  0.49      2.05     0.01        2     0.01     0.01  LineString::LineString(CoordinateList, PrecisionModel, int)
  0.49      2.06     0.01        2     0.01     0.01  GeometryGraph::addPolygonRing(LinearRing*, int, int)
  0.00      2.06     0.00  5176119     0.00     0.00  LineIntersector::hasIntersection()



From nhv at cape.com  Wed Nov 20 13:52:01 2002
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Profiling results
References: 
	<5A94289A9268514C8D6C0F1FF44BA0270FD3DD@venus.VividSolutions.com><031801c28f89$70b3fa90$6e37ba8c@sfdev3>
	<053d01c28fe2$3c27b010$6e37ba8c@sfdev3>
Message-ID: <063f01c290c5$e9fdb2f0$0836ba8c@sfdev3>

Hi all,

While looking into why all the calls to signOfDet2x2()
I experimented with an early out mechanism in
RobustLineIntersector::computeIntersect(...)

I think that computeIntersect() is still 'correct'
but would appreciate comments as to otherwise
 < see below >

following results from a 2,000,000 point test
< note new functions indexOfMaxY() and getMinMax2() 
  are simple scans of the CoordinateList that 
  reflect the time to traverse the List >

Cheers

Norman

< before >
 81.21      6.31     6.31 28704650     0.00     0.00  RobustDeterminant::signOfDet2x2(double&, double&, double&, double&)
 10.17      7.10     0.79 10352339     0.00     0.00  SegmentIntersector::addIntersections(Edge*, int, Edge*, int)
  3.73      7.39     0.29        1     0.29     0.29  GeometryTestFactory::createSineStar(double, double, double, double, int, int)
  2.83      7.61     0.22        2     0.11     0.11  CoordinateList::getMinMax2D(double*, double*, double*, double*)
  1.16      7.70     0.09        2     0.04     0.04  CoordinateList::indexOfMaxY()
  0.26      7.72     0.02        2     0.01     0.02  LineString::LineString(CoordinateList, PrecisionModel, int)
  0.13      7.73     0.01       19     0.00     0.00  PrecisionModel::PrecisionModel(PrecisionModel const&)
  0.13      7.74     0.01        2     0.01     0.01  LineString::isClosed()
  0.13      7.75     0.01        2     0.01     0.01  PlanarGraph::insertEdge(Edge*)
  0.13      7.76     0.01        2     0.01     0.01  CoordinateList::hasNullElement()
  0.13      7.77     0.01        2     0.01     0.01  EdgeIntersectionList::EdgeIntersectionList(Edge*)

< after >
 66.92      1.78     1.78 17999884     0.00     0.00  RobustDeterminant::signOfDet2x2(double&, double&, double&, double&)
 12.41      2.11     0.33        1     0.33     0.33  GeometryTestFactory::createSineStar(double, double, double, double, int, int)
  9.77      2.37     0.26 10352339     0.00     0.00  SegmentIntersector::addIntersections(Edge*, int, Edge*, int)
  4.89      2.50     0.13        2     0.07     0.07  CoordinateList::getMinMax2D(double*, double*, double*, double*)
  3.38      2.59     0.09        2     0.04     0.04  CoordinateList::indexOfMaxY()
  0.75      2.61     0.02        2     0.01     0.01  LineString::LineString(CoordinateList, PrecisionModel, int)
  0.38      2.62     0.01        6     0.00     0.00  RobustCGAlgorithms::RobustCGAlgorithms()
  0.38      2.63     0.01        2     0.01     0.01  LineString::isClosed()
  0.38      2.64     0.01        2     0.01     0.05  GeometryGraph::addPolygonRing(LinearRing*, int, int)
  0.38      2.65     0.01        2     0.01     0.01  CoordinateList::hasNullElement()
  0.38      2.66     0.01                             _GLOBAL__I__ZN18GeometryCollectionC2Ev


    int RobustLineIntersector::computeIntersect(Coordinate p1,Coordinate p2,
    Coordinate q1,Coordinate q2)
    {
        isProperVar=false;
 
            /**
             * for each endpoint,compute which side of the other
             * segment it lies, if both endpoints lie on the same side 
             * of the other segment,the segments do not intersect
             */

 // But first lets try a trivial reject
 double minq = min(q1.x, q2.x);
 double maxq = max(q1.x, q2.x);
 double minp = min(p1.x, p2.x);
 double maxp = max(p1.x, p2.x);

 if( minp > maxq )
     return DONT_INTERSECT;
 if( maxp < minq )
     return DONT_INTERSECT;
       
 minq = min(q1.y, q2.y);
 maxq = max(q1.y, q2.y);
 minp = min(p1.y, p2.y);
 maxp = max(p1.y, p2.y);

 if( minp > maxq )
     return DONT_INTERSECT;
 if( maxp < minq )
     return DONT_INTERSECT;

        int Pq1=RobustCGAlgorithms::orientationIndex(p1,p2,q1);
        int Pq2=RobustCGAlgorithms::orientationIndex(p1,p2,q2);
                
        if ((Pq1>0 && Pq2>0) || (Pq1<0 && Pq2<0)) {
     return DONT_INTERSECT;
        }
                
        int Qp1=RobustCGAlgorithms::orientationIndex(q1,q2,p1);
        int Qp2=RobustCGAlgorithms::orientationIndex(q1,q2,p2);
 
        if ((Qp1>0 && Qp2>0) || (Qp1<0 && Qp2<0)) {
            return DONT_INTERSECT;
        }
            // if collinear
        if ((Pq1==0) && (Pq2==0) && (Qp1==0) && (Qp2==0)) {
            return computeCollinearIntersection(p1,p2,q1,q2);
        }
            /**
             *  Check if the intersection is an endpoint.
             *  If it is,copy the endpoint as the intersection point.
             *  Copying the point rather than computing it ensures the
             *  point has the exact value, which is important for
             *  robustness.  It is sufficient to simply check for an
             *  endpoint which is on the other line,since at this point
             *  we know that the inputLines must intersect.
             */
        if ((Pq1==0) || (Pq2==0) || (Qp1==0) || (Qp2==0)) {
            isProperVar=false;
            if (Pq1==0) {
                intPt[0].setCoordinate(q1);
            }
            if (Pq2==0) {
                intPt[0].setCoordinate(q2);
            }
            if (Qp1==0) {
                intPt[0].setCoordinate(p1);
            }
            if (Qp2==0) {
                intPt[0].setCoordinate(p2);
            }
        } else {
            isProperVar=true;
            intPt[0].setCoordinate(intersection(p1,p2,q1,q2));
        }
        return DO_INTERSECT;
    }




From mbdavis at VividSolutions.com  Wed Nov 20 14:01:24 2002
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:05 2007
Subject: FW: [geos-devel] Profiling results
Message-ID: <5A94289A9268514C8D6C0F1FF44BA0270FD480@venus.VividSolutions.com>


Norman, your added tests in LineIntersector are indeed correct.  The reason we didn't implement them in RobustLineIntersector in the first place is that we almost always only call computeIntersect once other code has determined that the line segments have a high probability of having their envelopes overlap (that's the function of the sweepline index and the monotone chains, for instance).

It probably doesn't hurt a whole bunch to add these tests in, but it might be nice to provide two separate functions in the LineInteresector API, to avoid the overhead if you are pretty sure the lines' envelopes intersect.

I'm pretty mystified as to why the LineIntersection code is called so many times.  The indexing is supposed to prevent this.  Are you sure you haven't disable indexing in some way?

Yury, are you getting the same results as Norman for the number of calls to computeIntersect() ?

I guess we should instrument the Java code and see if its numbers compare.  I'll take a look at doing this.

Martin Davis, Senior Technical Specialist
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


> -----Original Message-----
> From: Norman Vine [mailto:nhv@cape.com]
> Sent: Wednesday, November 20, 2002 10:52 AM
> To: GEOS Development List
> Subject: [geos-devel] Profiling results
> 
> 
> Hi all,
> 
> While looking into why all the calls to signOfDet2x2()
> I experimented with an early out mechanism in
> RobustLineIntersector::computeIntersect(...)
> 
> I think that computeIntersect() is still 'correct'
> but would appreciate comments as to otherwise
>  < see below >
> 
> following results from a 2,000,000 point test
> < note new functions indexOfMaxY() and getMinMax2() 
>   are simple scans of the CoordinateList that 
>   reflect the time to traverse the List >
> 
> Cheers
> 
> Norman
> 
> < before >
>  81.21      6.31     6.31 28704650     0.00     0.00  
> RobustDeterminant::signOfDet2x2(double&, double&, double&, double&)
>  10.17      7.10     0.79 10352339     0.00     0.00  
> SegmentIntersector::addIntersections(Edge*, int, Edge*, int)
>   3.73      7.39     0.29        1     0.29     0.29  
> GeometryTestFactory::createSineStar(double, double, double, 
> double, int, int)
>   2.83      7.61     0.22        2     0.11     0.11  
> CoordinateList::getMinMax2D(double*, double*, double*, double*)
>   1.16      7.70     0.09        2     0.04     0.04  
> CoordinateList::indexOfMaxY()
>   0.26      7.72     0.02        2     0.01     0.02  
> LineString::LineString(CoordinateList, PrecisionModel, int)
>   0.13      7.73     0.01       19     0.00     0.00  
> PrecisionModel::PrecisionModel(PrecisionModel const&)
>   0.13      7.74     0.01        2     0.01     0.01  
> LineString::isClosed()
>   0.13      7.75     0.01        2     0.01     0.01  
> PlanarGraph::insertEdge(Edge*)
>   0.13      7.76     0.01        2     0.01     0.01  
> CoordinateList::hasNullElement()
>   0.13      7.77     0.01        2     0.01     0.01  
> EdgeIntersectionList::EdgeIntersectionList(Edge*)
> 
> < after >
>  66.92      1.78     1.78 17999884     0.00     0.00  
> RobustDeterminant::signOfDet2x2(double&, double&, double&, double&)
>  12.41      2.11     0.33        1     0.33     0.33  
> GeometryTestFactory::createSineStar(double, double, double, 
> double, int, int)
>   9.77      2.37     0.26 10352339     0.00     0.00  
> SegmentIntersector::addIntersections(Edge*, int, Edge*, int)
>   4.89      2.50     0.13        2     0.07     0.07  
> CoordinateList::getMinMax2D(double*, double*, double*, double*)
>   3.38      2.59     0.09        2     0.04     0.04  
> CoordinateList::indexOfMaxY()
>   0.75      2.61     0.02        2     0.01     0.01  
> LineString::LineString(CoordinateList, PrecisionModel, int)
>   0.38      2.62     0.01        6     0.00     0.00  
> RobustCGAlgorithms::RobustCGAlgorithms()
>   0.38      2.63     0.01        2     0.01     0.01  
> LineString::isClosed()
>   0.38      2.64     0.01        2     0.01     0.05  
> GeometryGraph::addPolygonRing(LinearRing*, int, int)
>   0.38      2.65     0.01        2     0.01     0.01  
> CoordinateList::hasNullElement()
>   0.38      2.66     0.01                             
> _GLOBAL__I__ZN18GeometryCollectionC2Ev
> 
> 
>     int RobustLineIntersector::computeIntersect(Coordinate 
> p1,Coordinate p2,
>     Coordinate q1,Coordinate q2)
>     {
>         isProperVar=false;
>  
>             /**
>              * for each endpoint,compute which side of the other
>              * segment it lies, if both endpoints lie on the 
> same side 
>              * of the other segment,the segments do not intersect
>              */
> 
>  // But first lets try a trivial reject
>  double minq = min(q1.x, q2.x);
>  double maxq = max(q1.x, q2.x);
>  double minp = min(p1.x, p2.x);
>  double maxp = max(p1.x, p2.x);
> 
>  if( minp > maxq )
>      return DONT_INTERSECT;
>  if( maxp < minq )
>      return DONT_INTERSECT;
>        
>  minq = min(q1.y, q2.y);
>  maxq = max(q1.y, q2.y);
>  minp = min(p1.y, p2.y);
>  maxp = max(p1.y, p2.y);
> 
>  if( minp > maxq )
>      return DONT_INTERSECT;
>  if( maxp < minq )
>      return DONT_INTERSECT;
> 
>         int Pq1=RobustCGAlgorithms::orientationIndex(p1,p2,q1);
>         int Pq2=RobustCGAlgorithms::orientationIndex(p1,p2,q2);
>                 
>         if ((Pq1>0 && Pq2>0) || (Pq1<0 && Pq2<0)) {
>      return DONT_INTERSECT;
>         }
>                 
>         int Qp1=RobustCGAlgorithms::orientationIndex(q1,q2,p1);
>         int Qp2=RobustCGAlgorithms::orientationIndex(q1,q2,p2);
>  
>         if ((Qp1>0 && Qp2>0) || (Qp1<0 && Qp2<0)) {
>             return DONT_INTERSECT;
>         }
>             // if collinear
>         if ((Pq1==0) && (Pq2==0) && (Qp1==0) && (Qp2==0)) {
>             return computeCollinearIntersection(p1,p2,q1,q2);
>         }
>             /**
>              *  Check if the intersection is an endpoint.
>              *  If it is,copy the endpoint as the intersection point.
>              *  Copying the point rather than computing it ensures the
>              *  point has the exact value, which is important for
>              *  robustness.  It is sufficient to simply check for an
>              *  endpoint which is on the other line,since at 
> this point
>              *  we know that the inputLines must intersect.
>              */
>         if ((Pq1==0) || (Pq2==0) || (Qp1==0) || (Qp2==0)) {
>             isProperVar=false;
>             if (Pq1==0) {
>                 intPt[0].setCoordinate(q1);
>             }
>             if (Pq2==0) {
>                 intPt[0].setCoordinate(q2);
>             }
>             if (Qp1==0) {
>                 intPt[0].setCoordinate(p1);
>             }
>             if (Qp2==0) {
>                 intPt[0].setCoordinate(p2);
>             }
>         } else {
>             isProperVar=true;
>             intPt[0].setCoordinate(intersection(p1,p2,q1,q2));
>         }
>         return DO_INTERSECT;
>     }
> 
> 
> 
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
> 

From mbdavis at VividSolutions.com  Wed Nov 20 14:30:11 2002
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Why many calls to signOfDet2x2 and addIntersections
Message-ID: <5A94289A9268514C8D6C0F1FF44BA02701DD6D@venus.VividSolutions.com>

Ok, after refreshing my brain about the JTS algorithms I can now shed some light on the mystery of why there are so many calls to RobustDeterminant::signOfDet2x2 and SegmentIntersector SegmentIntersector::addIntersections.

Both of these have to do with the constraints that the very general OGC spatial model places on the developer.  The OGC SFS allows any orientation for the rings of a polygon.  It also allows the holes in a polygon to touch the polygon shell at points which are not nodes.  Because of this, the first step during the processing of relate(Geom, Geom) is to analyze each argument geometry to determine (a) what orientation its rings are, and (b) whether its rings self-intersect at points.  To do this, a lot of processing needs to be carried out!  

In particular: 
- isCCW is called on each ring - which calls signOfDet2x2 n times (for each pair of consecutive line segments)
- computeSelfNodes is called on each arg geometry - which calls addIntersections a whole bunch of times (n^2 times if you have a dumb algorithm, or in JTS on average a linear number of times due to the indexing.)

SO...  ain't no way out of this one, unless you can convince OGC to change their model.  Which they ain't gonna do, since they (rightly) want it to be general enough for all users.

The only way around these expensive tests is to cache the orientation and intersection information for each Geometry.  This makes sense if you have a storage format in which you can maintain this cached information.  There's tricky design issues here too - for instance, the number of self-intersections may be as many as O(n)!  Some people prefer the Geometry format to be as small as possible - others want it to be fast.  Can't do both...  

Attached is a listing from JTS which shows counts for intersection tests for the self-node tests and the relate tests.  As you can see, the self-node tests dwarf the relate tests.

Probably the real message here is that JTS has lived quite happily doing this all the time.  If GEOS is slower than JTS we have to look elsewhere for the cause.

===========================================
n Pts: 1000
computeSelfNodes: SegmentIntersector # tests = 4054
computeSelfNodes: SegmentIntersector # tests = 4054
computeIM: # segment intersection tests: 234
   Executed in 9473 ms
n Pts: 2000
computeSelfNodes: SegmentIntersector # tests = 8242
computeSelfNodes: SegmentIntersector # tests = 8242
computeIM: # segment intersection tests: 286
   Executed in 80 ms
n Pts: 4000
computeSelfNodes: SegmentIntersector # tests = 16626
computeSelfNodes: SegmentIntersector # tests = 16626
computeIM: # segment intersection tests: 257
   Executed in 140 ms
n Pts: 8000
computeSelfNodes: SegmentIntersector # tests = 33346
computeSelfNodes: SegmentIntersector # tests = 33346
computeIM: # segment intersection tests: 261
   Executed in 301 ms
n Pts: 16000
computeSelfNodes: SegmentIntersector # tests = 66866
computeSelfNodes: SegmentIntersector # tests = 66866
computeIM: # segment intersection tests: 273
   Executed in 500 ms
n Pts: 32000 computeSelfNodes: SegmentIntersector # tests = 133890
computeSelfNodes: SegmentIntersector # tests = 133890
computeIM: # segment intersection tests: 256
   Executed in 881 ms
n Pts: 64000 computeSelfNodes: SegmentIntersector # tests = 267906
computeSelfNodes: SegmentIntersector # tests = 267906
computeIM: # segment intersection tests: 240
   Executed in 1713 ms
n Pts: 128000
computeSelfNodes: SegmentIntersector # tests = 535914
computeSelfNodes: SegmentIntersector # tests = 535914
computeIM: # segment intersection tests: 268
   Executed in 3395 ms
n Pts: 256000
computeSelfNodes: SegmentIntersector # tests = 1071946
computeSelfNodes: SegmentIntersector # tests = 1071946
computeIM: # segment intersection tests: 240
   Executed in 6588 ms


Martin Davis, Senior Technical Specialist
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


From dblasby at refractions.net  Wed Nov 20 14:50:11 2002
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Why many calls to signOfDet2x2 and addIntersections
References: <5A94289A9268514C8D6C0F1FF44BA02701DD6D@venus.VividSolutions.com>
Message-ID: <3DDBE773.B2753602@refractions.net>

> In particular:
> - isCCW is called on each ring - which calls signOfDet2x2 n times (for each pair of consecutive line segments)

You should be able to do this with only 1 signOfDet2x2.

(a)    Find the point with the highest Y value.
(b)    Form a  triangle from the  point before and the point after

    There are two cases:

                                            Pn
                      Pn+1                                   Pn-1

or

                                          Pn
                   Pn-1                                      Pn+1


You can find if its a left or right turn robustly using signOfDet2x2.

There is one gotcha - if Pn-1, Pn, Pn+1 all have the same Y value.  This is easy to find - there are no robustness problems (just use "=").  If
         Pn-1.getY() = Pn.getY() use Pn-2 instead  (you might have to try n-3, etc).

This back tracking is O(n),  but the whole algorthm is O(n) anyways (to find the Maximum Y value).

This should be way faster than O(n) signOfDet2x2 computations.

I havent convinced myself that this backtracking will allways work, but you could always go back to the slow solution in this case.

Comments,

dave


From dblasby at refractions.net  Wed Nov 20 15:28:38 2002
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Why many calls to signOfDet2x2 and addIntersections
References: <5A94289A9268514C8D6C0F1FF44BA02701DD6D@venus.VividSolutions.com>
	<3DDBE773.B2753602@refractions.net>
Message-ID: <3DDBF076.FBA66C39@refractions.net>

Oh- the backtracking will work, it just needs a little tweek:

Search of the first point that doesnt have the max Y value.  Rename this points Pn+1, and everything should work as before.

dave


From nhv at cape.com  Wed Nov 20 15:26:56 2002
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Why many calls to signOfDet2x2 and addIntersections
References: <5A94289A9268514C8D6C0F1FF44BA02701DD6D@venus.VividSolutions.com>
Message-ID: <06f601c290d3$2db8f330$0836ba8c@sfdev3>

Martin Davis writes:
>
> Ok, after refreshing my brain about the JTS algorithms I can now shed some light on the mystery of why there are so many calls to
RobustDeterminant::signOfDet2x2 and SegmentIntersector SegmentIntersector::addIntersections.

Martin

It seems from your instrumentation that the JAVA code
is making ~10 times npoints calls but it is hard to tell exactly
Could you please add some instrumentation inside of signOfDet2x2()
and post the results of the TOTAL calls per test.


> Probably the real message here is that JTS has lived quite happily doing this all the time.  If GEOS is slower than JTS we have to
look elsewhere for the cause.

FWIW- My current TestLineSweep is running about
~20% faster then the Java results you posted

this is computed by elapsed_time * 733 / 1100

where my 733/1100 represents the speed of
my machine vs your machine

Of course this doesn't take into account lots of things
like different processors or memry speed

Norman


From mbdavis at VividSolutions.com  Wed Nov 20 15:28:03 2002
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Why many calls to signOfDet2x2 and addIntersections
Message-ID: <5A94289A9268514C8D6C0F1FF44BA0270FD484@venus.VividSolutions.com>

My mistake - isCCW only calls signOfDet2x2 ONCE per ring.  (JTS does use an algorithm like the one you mention, Dave.)

Almost all signOfDet2x2 calls are due to the segment intersections tests in computeSelfNodes, I believe.

Martin Davis, Senior Technical Specialist
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


> -----Original Message-----
> From: David Blasby [mailto:dblasby@refractions.net]
> Sent: Wednesday, November 20, 2002 11:50 AM
> To: GEOS Development List
> Subject: Re: [geos-devel] Why many calls to signOfDet2x2 and
> addIntersections
> 
> 
> > In particular:
> > - isCCW is called on each ring - which calls signOfDet2x2 n 
> times (for each pair of consecutive line segments)
> 
> You should be able to do this with only 1 signOfDet2x2.
> 
> (a)    Find the point with the highest Y value.
> (b)    Form a  triangle from the  point before and the point after
> 
>     There are two cases:
> 
>                                             Pn
>                       Pn+1                                   Pn-1
> 
> or
> 
>                                           Pn
>                    Pn-1                                      Pn+1
> 
> 
> You can find if its a left or right turn robustly using signOfDet2x2.
> 
> There is one gotcha - if Pn-1, Pn, Pn+1 all have the same Y 
> value.  This is easy to find - there are no robustness 
> problems (just use "=").  If
>          Pn-1.getY() = Pn.getY() use Pn-2 instead  (you might 
> have to try n-3, etc).
> 
> This back tracking is O(n),  but the whole algorthm is O(n) 
> anyways (to find the Maximum Y value).
> 
> This should be way faster than O(n) signOfDet2x2 computations.
> 
> I havent convinced myself that this backtracking will allways 
> work, but you could always go back to the slow solution in this case.
> 
> Comments,
> 
> dave
> 
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
> 

From mbdavis at VividSolutions.com  Wed Nov 20 15:42:12 2002
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] count of signOfDet2x2 calls in JTS
Message-ID: <5A94289A9268514C8D6C0F1FF44BA0270FD486@venus.VividSolutions.com>

Here's the results.  (Note these are for the SineStar^2 test, comparing two offset sine stars of the same size).

Good news: there's lots of calls to signOfDet2x2 , so GEOS looks like it's mirroring JTS
Bad news: why so many calls? 

I'll try and figure out the reason for the bad news...   8^(

n Pts: 1000
   signOfDet2x2 calls: 35394
   Executed in 1642 ms
n Pts: 2000
   signOfDet2x2 calls: 71106
   Executed in 80 ms
n Pts: 4000
   signOfDet2x2 calls: 142062
   Executed in 120 ms
n Pts: 8000
   signOfDet2x2 calls: 283838
   Executed in 221 ms
n Pts: 16000
   signOfDet2x2 calls: 568046
   Executed in 410 ms
n Pts: 32000
   signOfDet2x2 calls: 1136170
   Executed in 680 ms
n Pts: 64000
   signOfDet2x2 calls: 2272234
   Executed in 1332 ms
n Pts: 128000
   signOfDet2x2 calls: 4544410
   Executed in 2683 ms
n Pts: 256000
   signOfDet2x2 calls: 9088554
   Executed in 5367 ms

Martin Davis, Senior Technical Specialist
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


From nhv at cape.com  Wed Nov 20 16:36:34 2002
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] count of signOfDet2x2 calls in JTS
References: <5A94289A9268514C8D6C0F1FF44BA0270FD486@venus.VividSolutions.com>
Message-ID: <083501c290dc$e6969bb0$0836ba8c@sfdev3>

Martin Davis writes:

> Here's the results.  (Note these are for the SineStar^2 test, comparing two offset sine stars of the same size).
> 
> Good news: there's lots of calls to signOfDet2x2 , so GEOS looks like it's mirroring JTS
> Bad news: why so many calls? 
> 
> I'll try and figure out the reason for the bad news...   8^(

Hmm...  the patch I posted should help a bit

Note there are two separate early out tricks

the first is the obvious 'trivial reject' 
the other is doing the orientationIndex() on 'Qp'
only after testing for an early reject on 'Pq'

this should save ~30% of the tests or better

Hopefully there are bigger gains to be had elsewhere too :-)

Norman



From mbdavis at VividSolutions.com  Wed Nov 20 18:57:46 2002
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Why many calls to signOfDet2x2 and addIntersections
Message-ID: <5A94289A9268514C8D6C0F1FF44BA02701DD6F@venus.VividSolutions.com>

Just for grins, I disabled the self-intersection check and reran the SineStarX2 test.  Times are below - they are up to 10 times faster!

I've been thinking a bit about this annoying requirement to test for self-intersections before performing any functions.  Strictly speaking, this is only required for linestrings (which can self-intersect) and *between* different rings of polygons - but not between a ring and itself (OGC rings can't self-intersect).  Currently JTS just checks *everything* for self-intersections.  Since many cases involve only polygons without holes, being a bit smarter about what gets checked could produce a substantial performance improvement.

I'll spend some time thinking about how to change JTS to implement this.. It's not totally trivial, but might not be too bad.

===============================
n Pts: 1000
   Executed in 1352 ms
n Pts: 2000
   Executed in 20 ms
n Pts: 4000
   Executed in 10 ms
n Pts: 8000
   Executed in 30 ms
n Pts: 16000
   Executed in 50 ms
n Pts: 32000
   Executed in 100 ms
n Pts: 64000
   Executed in 100 ms
n Pts: 128000
   Executed in 221 ms
n Pts: 256000
   Executed in 411 ms

Martin Davis, Senior Technical Specialist
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


From nhv at cape.com  Wed Nov 20 19:59:26 2002
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Why many calls to signOfDet2x2 and addIntersections
References: <5A94289A9268514C8D6C0F1FF44BA02701DD6F@venus.VividSolutions.com>
Message-ID: <098301c290f9$3e1a6990$0836ba8c@sfdev3>

Martin Davis writes:

> Just for grins, I disabled the self-intersection check and reran the SineStarX2 test.  
> Times are below - they are up to 10 times faster!

Ah  this is more like what I was expecting

>  Currently JTS just checks *everything* for self-intersections.  
> Since many cases involve only polygons without holes, being a bit smarter about 
> what gets checked could produce a substantial performance improvement.

FWIW IMHO trivial rejection tests and caching computations for reuse
are almost *allways* worth the time it takes 

cheers

norman

==========

    bool RobustCGAlgorithms::isPointInRing(Coordinate p,CoordinateList ring)
    {
        int crossings=0;    // number of segment/ray crossings
        int nPts=ring.getSize();
            /*
             *  For each segment l = (i-1, i),
             *  see if it crosses ray from test point in positive x direction.
             */
        double x1=ring.getAt(0).x-p.x;
        double y1=ring.getAt(0).y-p.y;
        for (int i=1;i<nPts;i++) {
            double x2 = x1;
            double y2 = y1;
            x1=ring.getAt(i).x-p.x;
            y1=ring.getAt(i).y-p.y;
            if (((y1>0) && (y2<=0)) || ((y2>0) && (y1<=0))) {
                    /*
                     *  segment straddles x axis, so compute intersection.
                     *  crosses ray if strictly positive intersection.
                     */
                if ( RobustDeterminant::signOfDet2x2(x1,y1,x2,y2)/(y2-y1)  >  0.0 ) {
                    crossings++;
                }
            }
        }
            /*
             *  p is inside if number of crossings is odd.
             */
        if ((crossings%2)==1) {
            return true;
        } else {
            return false;
        }
    }



From mbdavis at VividSolutions.com  Thu Nov 21 18:48:46 2002
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] JTS performance improvement for large polygons
Message-ID: <5A94289A9268514C8D6C0F1FF44BA0270FD4A8@venus.VividSolutions.com>

I've come up with a fairly easy update for JTS which eliminates the unecessary tests for ring self-intersection during spatial functions.  This will be shipped in the new version of JTS (although of course I can make it available for inclusion in GEOS at any time).

Note that this produces large gains for situations such as SineStar^2 for 255,000 points (a gain of 10x in performance).  However, the gains are less noticeable for small polygons (1000 points or less).  It also only matters if you actually have to test for intersections - if the polygons do not interact because their bounding boxes don't overlap, you of course don't see any improvement.

I've tested the new code in some practical situations involving testing many polygons for overlap, and it actually didn't make any difference. 

However, it's definitely good to tighten up the algorithm for the times it really is needed.

Martin Davis, Senior Technical Specialist
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


From ybychkov at direct.ca  Sun Nov 24 05:58:52 2002
From: ybychkov at direct.ca (Yury A. Bychkov)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Current project status
References: <5A94289A9268514C8D6C0F1FF44BA02701DD5F@venus.VividSolutions.com>
Message-ID: <006401c293a8$aa6f60d0$b9354d18@yury>

1. RobustLineIntersector has been updated.
2. MonotoneChainIndexer::getChainStartIndices was a biggest single contributor
to Coordinate() calls (~20% of total calls). I've replaced instances
CoordinateList with references to gauge performance increase (See results
below).
3. Currently I am redoing the CoordinateList (and calls to its methods) with
respect to the suggestions on the list.

Here are the performance results (P4-2.53):
No modifications:
 # overlapping MCs: 406
 # segment intersection tests: 226
 n Pts: 1000  Executed in     30 ms.
 # overlapping MCs: 406
 # segment intersection tests: 278
 n Pts: 2000  Executed in     50 ms.
 # overlapping MCs: 406
 # segment intersection tests: 248
 n Pts: 4000  Executed in    100 ms.
 # overlapping MCs: 406
 # segment intersection tests: 250
 n Pts: 8000  Executed in    150 ms.
 # overlapping MCs: 406
 # segment intersection tests: 272
 n Pts: 16000  Executed in    391 ms.
 # overlapping MCs: 406
 # segment intersection tests: 264
 n Pts: 32000  Executed in    751 ms.
 # overlapping MCs: 406
 # segment intersection tests: 236
 n Pts: 64000  Executed in   1513 ms.
 # overlapping MCs: 406
 # segment intersection tests: 264
 n Pts: 128000  Executed in   3395 ms.
 # overlapping MCs: 406
 # segment intersection tests: 238
 n Pts: 256000  Executed in   7120 ms.
 # overlapping MCs: 406
 # segment intersection tests: 232
 n Pts: 512000  Executed in  12788 ms.
 # overlapping MCs: 406
 # segment intersection tests: 232
 n Pts: 1024000  Executed in  25296 ms.

New RobustLineIntersector:
 # overlapping MCs: 406
 # segment intersection tests: 226
 n Pts: 1000  Executed in     20 ms.
 # overlapping MCs: 406
 # segment intersection tests: 278
 n Pts: 2000  Executed in     40 ms.
 # overlapping MCs: 406
 # segment intersection tests: 248
 n Pts: 4000  Executed in     90 ms.
 # overlapping MCs: 406
 # segment intersection tests: 250
 n Pts: 8000  Executed in    130 ms.
 # overlapping MCs: 406
 # segment intersection tests: 272
 n Pts: 16000  Executed in    311 ms.
 # overlapping MCs: 406
 # segment intersection tests: 264
 n Pts: 32000  Executed in    621 ms.
 # overlapping MCs: 406
 # segment intersection tests: 236
 n Pts: 64000  Executed in   1252 ms.
 # overlapping MCs: 406
 # segment intersection tests: 264
 n Pts: 128000  Executed in   2754 ms.
 # overlapping MCs: 406
 # segment intersection tests: 238
 n Pts: 256000  Executed in   5688 ms.
 # overlapping MCs: 406
 # segment intersection tests: 232
 n Pts: 512000  Executed in  10895 ms.
 # overlapping MCs: 406
 # segment intersection tests: 232
 n Pts: 1024000  Executed in  22042 ms.

CoordinateList instances replaced with references in MonotoneChainIndexer; some
tweaking of CoordinateList:
 # overlapping MCs: 406
 # segment intersection tests: 226
 n Pts: 1000  Executed in     20 ms.
 # overlapping MCs: 406
 # segment intersection tests: 278
 n Pts: 2000  Executed in     30 ms.
 # overlapping MCs: 406
 # segment intersection tests: 248
 n Pts: 4000  Executed in     70 ms.
 # overlapping MCs: 406
 # segment intersection tests: 250
 n Pts: 8000  Executed in    120 ms.
 # overlapping MCs: 406
 # segment intersection tests: 272
 n Pts: 16000  Executed in    270 ms.
 # overlapping MCs: 406
 # segment intersection tests: 264
 n Pts: 32000  Executed in    500 ms.
 # overlapping MCs: 406
 # segment intersection tests: 236
 n Pts: 64000  Executed in    991 ms.
 # overlapping MCs: 406
 # segment intersection tests: 264
 n Pts: 128000  Executed in   2023 ms.
 # overlapping MCs: 406
 # segment intersection tests: 238
 n Pts: 256000  Executed in   4276 ms.
 # overlapping MCs: 406
 # segment intersection tests: 232
 n Pts: 512000  Executed in   7861 ms.
 # overlapping MCs: 406
 # segment intersection tests: 232
 n Pts: 1024000  Executed in  15993 ms.


Yury



From mbdavis at VividSolutions.com  Sun Nov 24 17:37:19 2002
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Current project status
Message-ID: <5A94289A9268514C8D6C0F1FF44BA0270FD4C8@venus.VividSolutions.com>

So my take on the statistics below is that GEOS is now somewhat faster than JTS (at least, JTS before the self-intersection check speedup).  So we may be at the point of diminishing returns for increasing performance using the current algorithms.

The changes to incorporate the self-intersection check speedup are relatively minor - I think we should incorporate them now. I will send the code to Yury to port.

Martin Davis, Senior Technical Specialist
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


> -----Original Message-----
> From: Yury A. Bychkov [mailto:ybychkov@direct.ca]
> Sent: Sunday, November 24, 2002 2:59 AM
> To: geos-devel@geos.refractions.net
> Subject: [geos-devel] Current project status
> 
> 
> 1. RobustLineIntersector has been updated.
> 2. MonotoneChainIndexer::getChainStartIndices was a biggest 
> single contributor
> to Coordinate() calls (~20% of total calls). I've replaced instances
> CoordinateList with references to gauge performance increase 
> (See results
> below).
> 3. Currently I am redoing the CoordinateList (and calls to 
> its methods) with
> respect to the suggestions on the list.
> 
> Here are the performance results (P4-2.53):
> No modifications:
>  # overlapping MCs: 406
>  # segment intersection tests: 226
>  n Pts: 1000  Executed in     30 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 278
>  n Pts: 2000  Executed in     50 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 248
>  n Pts: 4000  Executed in    100 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 250
>  n Pts: 8000  Executed in    150 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 272
>  n Pts: 16000  Executed in    391 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 264
>  n Pts: 32000  Executed in    751 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 236
>  n Pts: 64000  Executed in   1513 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 264
>  n Pts: 128000  Executed in   3395 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 238
>  n Pts: 256000  Executed in   7120 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 232
>  n Pts: 512000  Executed in  12788 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 232
>  n Pts: 1024000  Executed in  25296 ms.
> 
> New RobustLineIntersector:
>  # overlapping MCs: 406
>  # segment intersection tests: 226
>  n Pts: 1000  Executed in     20 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 278
>  n Pts: 2000  Executed in     40 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 248
>  n Pts: 4000  Executed in     90 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 250
>  n Pts: 8000  Executed in    130 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 272
>  n Pts: 16000  Executed in    311 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 264
>  n Pts: 32000  Executed in    621 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 236
>  n Pts: 64000  Executed in   1252 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 264
>  n Pts: 128000  Executed in   2754 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 238
>  n Pts: 256000  Executed in   5688 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 232
>  n Pts: 512000  Executed in  10895 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 232
>  n Pts: 1024000  Executed in  22042 ms.
> 
> CoordinateList instances replaced with references in 
> MonotoneChainIndexer; some
> tweaking of CoordinateList:
>  # overlapping MCs: 406
>  # segment intersection tests: 226
>  n Pts: 1000  Executed in     20 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 278
>  n Pts: 2000  Executed in     30 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 248
>  n Pts: 4000  Executed in     70 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 250
>  n Pts: 8000  Executed in    120 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 272
>  n Pts: 16000  Executed in    270 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 264
>  n Pts: 32000  Executed in    500 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 236
>  n Pts: 64000  Executed in    991 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 264
>  n Pts: 128000  Executed in   2023 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 238
>  n Pts: 256000  Executed in   4276 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 232
>  n Pts: 512000  Executed in   7861 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 232
>  n Pts: 1024000  Executed in  15993 ms.
> 
> 
> Yury
> 
> 
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
> 

From ybychkov at direct.ca  Sun Nov 24 17:42:15 2002
From: ybychkov at direct.ca (Yury A. Bychkov)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Current project status
References: <5A94289A9268514C8D6C0F1FF44BA0270FD4C8@venus.VividSolutions.com>
Message-ID: <002501c2940a$bd35f910$b9354d18@yury>

There still seems to be a very large number of useless Coordinate() constructor
calls. I'd suggest waiting so see if I can eliminate a large portion of them
easily enough (I'll know if a couple of days). Then I can add self-intersection
speedups and we'll see what the performance will be.

Yury

----- Original Message -----
From: "Martin Davis" <mbdavis@VividSolutions.com>
To: "GEOS Development List" <geos-devel@geos.refractions.net>
Sent: Sunday, November 24, 2002 2:37 PM
Subject: RE: [geos-devel] Current project status


So my take on the statistics below is that GEOS is now somewhat faster than JTS
(at least, JTS before the self-intersection check speedup).  So we may be at the
point of diminishing returns for increasing performance using the current
algorithms.

The changes to incorporate the self-intersection check speedup are relatively
minor - I think we should incorporate them now. I will send the code to Yury to
port.

Martin Davis, Senior Technical Specialist
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


> -----Original Message-----
> From: Yury A. Bychkov [mailto:ybychkov@direct.ca]
> Sent: Sunday, November 24, 2002 2:59 AM
> To: geos-devel@geos.refractions.net
> Subject: [geos-devel] Current project status
>
>
> 1. RobustLineIntersector has been updated.
> 2. MonotoneChainIndexer::getChainStartIndices was a biggest
> single contributor
> to Coordinate() calls (~20% of total calls). I've replaced instances
> CoordinateList with references to gauge performance increase
> (See results
> below).
> 3. Currently I am redoing the CoordinateList (and calls to
> its methods) with
> respect to the suggestions on the list.
>
> Here are the performance results (P4-2.53):
> No modifications:
>  # overlapping MCs: 406
>  # segment intersection tests: 226
>  n Pts: 1000  Executed in     30 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 278
>  n Pts: 2000  Executed in     50 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 248
>  n Pts: 4000  Executed in    100 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 250
>  n Pts: 8000  Executed in    150 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 272
>  n Pts: 16000  Executed in    391 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 264
>  n Pts: 32000  Executed in    751 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 236
>  n Pts: 64000  Executed in   1513 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 264
>  n Pts: 128000  Executed in   3395 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 238
>  n Pts: 256000  Executed in   7120 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 232
>  n Pts: 512000  Executed in  12788 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 232
>  n Pts: 1024000  Executed in  25296 ms.
>
> New RobustLineIntersector:
>  # overlapping MCs: 406
>  # segment intersection tests: 226
>  n Pts: 1000  Executed in     20 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 278
>  n Pts: 2000  Executed in     40 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 248
>  n Pts: 4000  Executed in     90 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 250
>  n Pts: 8000  Executed in    130 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 272
>  n Pts: 16000  Executed in    311 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 264
>  n Pts: 32000  Executed in    621 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 236
>  n Pts: 64000  Executed in   1252 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 264
>  n Pts: 128000  Executed in   2754 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 238
>  n Pts: 256000  Executed in   5688 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 232
>  n Pts: 512000  Executed in  10895 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 232
>  n Pts: 1024000  Executed in  22042 ms.
>
> CoordinateList instances replaced with references in
> MonotoneChainIndexer; some
> tweaking of CoordinateList:
>  # overlapping MCs: 406
>  # segment intersection tests: 226
>  n Pts: 1000  Executed in     20 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 278
>  n Pts: 2000  Executed in     30 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 248
>  n Pts: 4000  Executed in     70 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 250
>  n Pts: 8000  Executed in    120 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 272
>  n Pts: 16000  Executed in    270 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 264
>  n Pts: 32000  Executed in    500 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 236
>  n Pts: 64000  Executed in    991 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 264
>  n Pts: 128000  Executed in   2023 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 238
>  n Pts: 256000  Executed in   4276 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 232
>  n Pts: 512000  Executed in   7861 ms.
>  # overlapping MCs: 406
>  # segment intersection tests: 232
>  n Pts: 1024000  Executed in  15993 ms.
>
>
> Yury
>
>
>
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
>

_______________________________________________
geos-devel mailing list
geos-devel@geos.refractions.net
http://geos.refractions.net/mailman/listinfo/geos-devel




From mbdavis at VividSolutions.com  Sun Nov 24 17:46:52 2002
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Current project status
Message-ID: <5A94289A9268514C8D6C0F1FF44BA0270FD4C9@venus.VividSolutions.com>

Yep, good idea.  My gut feel is that there should be very few calls to the Coordinate constructor - most accesses to Coordinates in the algorithms should be by reference.  So go to it - maybe I'll have to retrieve my C compiler from the garbage after all!

Martin Davis, Senior Technical Specialist
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


> -----Original Message-----
> From: Yury A. Bychkov [mailto:ybychkov@direct.ca]
> Sent: Sunday, November 24, 2002 2:42 PM
> To: GEOS Development List
> Subject: Re: [geos-devel] Current project status
> 
> 
> There still seems to be a very large number of useless 
> Coordinate() constructor
> calls. I'd suggest waiting so see if I can eliminate a large 
> portion of them
> easily enough (I'll know if a couple of days). Then I can add 
> self-intersection
> speedups and we'll see what the performance will be.
> 
> Yury
> 
> ----- Original Message -----
> From: "Martin Davis" <mbdavis@VividSolutions.com>
> To: "GEOS Development List" <geos-devel@geos.refractions.net>
> Sent: Sunday, November 24, 2002 2:37 PM
> Subject: RE: [geos-devel] Current project status
> 
> 
> So my take on the statistics below is that GEOS is now 
> somewhat faster than JTS
> (at least, JTS before the self-intersection check speedup).  
> So we may be at the
> point of diminishing returns for increasing performance using 
> the current
> algorithms.
> 
> The changes to incorporate the self-intersection check 
> speedup are relatively
> minor - I think we should incorporate them now. I will send 
> the code to Yury to
> port.
> 
> Martin Davis, Senior Technical Specialist
> Vivid Solutions Inc.
> Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
> Phone: (250) 385 6040    Fax: (250) 385 6046
> EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com
> 
> 
> > -----Original Message-----
> > From: Yury A. Bychkov [mailto:ybychkov@direct.ca]
> > Sent: Sunday, November 24, 2002 2:59 AM
> > To: geos-devel@geos.refractions.net
> > Subject: [geos-devel] Current project status
> >
> >
> > 1. RobustLineIntersector has been updated.
> > 2. MonotoneChainIndexer::getChainStartIndices was a biggest
> > single contributor
> > to Coordinate() calls (~20% of total calls). I've replaced instances
> > CoordinateList with references to gauge performance increase
> > (See results
> > below).
> > 3. Currently I am redoing the CoordinateList (and calls to
> > its methods) with
> > respect to the suggestions on the list.
> >
> > Here are the performance results (P4-2.53):
> > No modifications:
> >  # overlapping MCs: 406
> >  # segment intersection tests: 226
> >  n Pts: 1000  Executed in     30 ms.
> >  # overlapping MCs: 406
> >  # segment intersection tests: 278
> >  n Pts: 2000  Executed in     50 ms.
> >  # overlapping MCs: 406
> >  # segment intersection tests: 248
> >  n Pts: 4000  Executed in    100 ms.
> >  # overlapping MCs: 406
> >  # segment intersection tests: 250
> >  n Pts: 8000  Executed in    150 ms.
> >  # overlapping MCs: 406
> >  # segment intersection tests: 272
> >  n Pts: 16000  Executed in    391 ms.
> >  # overlapping MCs: 406
> >  # segment intersection tests: 264
> >  n Pts: 32000  Executed in    751 ms.
> >  # overlapping MCs: 406
> >  # segment intersection tests: 236
> >  n Pts: 64000  Executed in   1513 ms.
> >  # overlapping MCs: 406
> >  # segment intersection tests: 264
> >  n Pts: 128000  Executed in   3395 ms.
> >  # overlapping MCs: 406
> >  # segment intersection tests: 238
> >  n Pts: 256000  Executed in   7120 ms.
> >  # overlapping MCs: 406
> >  # segment intersection tests: 232
> >  n Pts: 512000  Executed in  12788 ms.
> >  # overlapping MCs: 406
> >  # segment intersection tests: 232
> >  n Pts: 1024000  Executed in  25296 ms.
> >
> > New RobustLineIntersector:
> >  # overlapping MCs: 406
> >  # segment intersection tests: 226
> >  n Pts: 1000  Executed in     20 ms.
> >  # overlapping MCs: 406
> >  # segment intersection tests: 278
> >  n Pts: 2000  Executed in     40 ms.
> >  # overlapping MCs: 406
> >  # segment intersection tests: 248
> >  n Pts: 4000  Executed in     90 ms.
> >  # overlapping MCs: 406
> >  # segment intersection tests: 250
> >  n Pts: 8000  Executed in    130 ms.
> >  # overlapping MCs: 406
> >  # segment intersection tests: 272
> >  n Pts: 16000  Executed in    311 ms.
> >  # overlapping MCs: 406
> >  # segment intersection tests: 264
> >  n Pts: 32000  Executed in    621 ms.
> >  # overlapping MCs: 406
> >  # segment intersection tests: 236
> >  n Pts: 64000  Executed in   1252 ms.
> >  # overlapping MCs: 406
> >  # segment intersection tests: 264
> >  n Pts: 128000  Executed in   2754 ms.
> >  # overlapping MCs: 406
> >  # segment intersection tests: 238
> >  n Pts: 256000  Executed in   5688 ms.
> >  # overlapping MCs: 406
> >  # segment intersection tests: 232
> >  n Pts: 512000  Executed in  10895 ms.
> >  # overlapping MCs: 406
> >  # segment intersection tests: 232
> >  n Pts: 1024000  Executed in  22042 ms.
> >
> > CoordinateList instances replaced with references in
> > MonotoneChainIndexer; some
> > tweaking of CoordinateList:
> >  # overlapping MCs: 406
> >  # segment intersection tests: 226
> >  n Pts: 1000  Executed in     20 ms.
> >  # overlapping MCs: 406
> >  # segment intersection tests: 278
> >  n Pts: 2000  Executed in     30 ms.
> >  # overlapping MCs: 406
> >  # segment intersection tests: 248
> >  n Pts: 4000  Executed in     70 ms.
> >  # overlapping MCs: 406
> >  # segment intersection tests: 250
> >  n Pts: 8000  Executed in    120 ms.
> >  # overlapping MCs: 406
> >  # segment intersection tests: 272
> >  n Pts: 16000  Executed in    270 ms.
> >  # overlapping MCs: 406
> >  # segment intersection tests: 264
> >  n Pts: 32000  Executed in    500 ms.
> >  # overlapping MCs: 406
> >  # segment intersection tests: 236
> >  n Pts: 64000  Executed in    991 ms.
> >  # overlapping MCs: 406
> >  # segment intersection tests: 264
> >  n Pts: 128000  Executed in   2023 ms.
> >  # overlapping MCs: 406
> >  # segment intersection tests: 238
> >  n Pts: 256000  Executed in   4276 ms.
> >  # overlapping MCs: 406
> >  # segment intersection tests: 232
> >  n Pts: 512000  Executed in   7861 ms.
> >  # overlapping MCs: 406
> >  # segment intersection tests: 232
> >  n Pts: 1024000  Executed in  15993 ms.
> >
> >
> > Yury
> >
> >
> >
> > _______________________________________________
> > geos-devel mailing list
> > geos-devel@geos.refractions.net
> > http://geos.refractions.net/mailman/listinfo/geos-devel
> >
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
> 
> 
> 
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
> 

From nhv at cape.com  Sun Nov 24 21:29:03 2002
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Current project status
References: <5A94289A9268514C8D6C0F1FF44BA0270FD4C8@venus.VividSolutions.com>
Message-ID: <038801c2942a$85181340$b137ba8c@sfdev3>

Martin Davis writes:
>
> So my take on the statistics below is that GEOS is now somewhat faster than JTS 
> 
> > Yury A. Bychkov wrote
> > 
> > Here are the performance results (P4-2.53):

> >  n Pts: 256000  Executed in   4276 ms.

This is better but still a lot slower then the Jave

ie 
on November 08 Martin Davis  wrote:

> I'm running on a 1.1 GHz machine, not a 1.9 GHz box
> n Pts: 256000   Executed in 5307 ms

and this is before my early reject patch !
which means you should be getting ~4000 ms with the early reject

so the way I see it is Yury's 'C' code is running at best 
at about 50% of the speed of the Java code.

Inlining the Coordinate, CoordinateList and Envelope Classes
    < all methods except the toString method >
will make up this differance

Out of curiosity has anyone used a memory checker
to make sure we aren't leaking ?

Cheers

Norman


< trials of a  'C' hacker follows >

Test 1 - code as from todays CVS
n Pts: 1000000  Executed in  81988 ms.
  %   cumulative   self              self     total           
 time   seconds   seconds    calls   s/call   s/call  name    
 54.55     20.15    20.15 364917628     0.00     0.00  Coordinate::Coordinate(Coordinate const&)
 20.19     27.61     7.46 157410776     0.00     0.00  CoordinateList::getAt(int)
  4.90     29.42     1.81 40942622     0.00     0.00  Envelope::init(double, double, double, double)
  2.79     30.45     1.03 10352452     0.00     0.00  SegmentIntersector::addIntersections(Edge*, int, Edge*, int)


Test 2 - with Coordinate and CoordinateList Inlined  < 30 % improvement >
n Pts: 1000000  Executed in  57642 ms.
  %   cumulative   self              self     total           
 time   seconds   seconds    calls   s/call   s/call  name    
 16.67      1.21     1.21        2     0.60     0.62  RobustCGAlgorithms::isOnLine(Coordinate, CoordinateList)
 15.84      2.36     1.15        2     0.57     0.57  Geometry::hasNullElements(CoordinateList)
 11.02      3.16     0.80 10352452     0.00     0.00  SegmentIntersector::addIntersections(Edge*, int, Edge*, int)
 10.61      3.93     0.77 40942622     0.00     0.00  Envelope::init(double, double, double, double)
  9.78      4.64     0.71 27295080     0.00     0.00  Envelope::init(Coordinate, Coordinate)


Test3 - Coordinate, CoordinateList, Envelope inlined
n Pts: 1000000  Executed in  40978 ms.
  %   cumulative   self              self     total           
 time   seconds   seconds    calls   s/call   s/call  name    
 25.87      2.22     2.22        2     1.11     1.15  RobustCGAlgorithms::isOnLine(Coordinate, CoordinateList)
 24.48      4.32     2.10        2     1.05     1.05  Geometry::hasNullElements(CoordinateList)
 20.75      6.10     1.78 10352452     0.00     0.00  SegmentIntersector::addIntersections(Edge*, int, Edge*, int)
  7.81      6.77     0.67 17999888     0.00     0.00  RobustCGAlgorithms::orientationIndex(Coordinate, Coordinate, Coordinate)
  7.69      7.43     0.66        4     0.17     0.17  RobustCGAlgorithms::isPointInRing(Coordinate, CoordinateList)
  2.80      7.67     0.24        2     0.12     0.12  RobustCGAlgorithms::isCCW(CoordinateList)
  2.80      7.91     0.24        2     0.12     0.12  GeometryTestFactory::createSineStar(double, double, double, double, int, int)


From nhv at cape.com  Sun Nov 24 23:53:51 2002
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Current project status
References: <5A94289A9268514C8D6C0F1FF44BA0270FD4C8@venus.VividSolutions.com>
	<038801c2942a$85181340$b137ba8c@sfdev3>
Message-ID: <046501c2943e$c035a6e0$b137ba8c@sfdev3>

FYI

To days CVS code with following classes inlined 
Coordinate, CoordinateList, Envelope, 
RobustCGAlgorithms, RobustLineIntersector

compiled with 
-O3 -fomit-frame-pointer

and tweak below

(PIII 733)

 Pts: 1000  Executed in     20 ms.
 Pts: 2000  Executed in     40 ms.
 Pts: 4000  Executed in     70 ms.
 Pts: 8000  Executed in    160 ms.
 Pts: 16000  Executed in    351 ms.
 Pts: 32000  Executed in    661 ms.
 Pts: 64000  Executed in   1302 ms.
 Pts: 128000  Executed in   2593 ms.
 Pts: 256000  Executed in   5267 ms.

Note Yury reported
 n Pts: 256000  Executed in   7120 ms.
on a (P4-2.53):

Norman 

// below I am assuming this means 
//  "is on line segment"  between getAt(i) and getAt(i-1)

bool RobustCGAlgorithms::isOnLine(Coordinate p,CoordinateList pt) {
 for(int i=1;i<pt.getSize();i++) {
  if( pt.inRange(p,i-1,i) ) {
   lineIntersector->computeIntersection(p,pt.getAt(i-1),pt.getAt(i));
   if (lineIntersector->hasIntersection()) {
    return true;
   }
  }
 }
 return false;
}


class CoordinateList 

public

 bool inXrange( double x, int idx1, int idx2) {
  if( x >= (*vect)[idx1].x )
   return x <= (*vect)[idx2].x;
  else if( x <= (*vect)[idx1].x )
   return x >= (*vect)[idx2].x;
  return false;
 }

 bool inYrange( double y, int idx1, int idx2) {
  if( y >= (*vect)[idx1].y )
   return y <= (*vect)[idx2].y;
  else if( y <= (*vect)[idx1].y )
   return y >= (*vect)[idx2].y;
  return false;
 }
 
 bool inRange( Coordinate &pt, int idx1, int idx2) {
  return( inXrange(pt.x,idx1,idx2) && inYrange(pt.y,idx1,idx2) );
 }


From ybychkov at direct.ca  Mon Nov 25 00:17:06 2002
From: ybychkov at direct.ca (Yury A. Bychkov)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Current project status
References: <5A94289A9268514C8D6C0F1FF44BA0270FD4C8@venus.VividSolutions.com>
	<046501c2943e$c035a6e0$b137ba8c@sfdev3>
Message-ID: <002201c29441$e739dfb0$b9354d18@yury>

Slight error. You didn't look far enough in my results. 7120 ms was for the
original version. The version that is in CVS now (before your inlining) has "n
Pts: 256000  Executed in   4276 ms".

Yury


----- Original Message -----
From: "Norman Vine" <nhv@cape.com>
To: "Norman Vine" <nhv@cape.com>; "GEOS Development List"
<geos-devel@geos.refractions.net>
Sent: Sunday, November 24, 2002 8:53 PM
Subject: Re: [geos-devel] Current project status


> FYI
>
> To days CVS code with following classes inlined
> Coordinate, CoordinateList, Envelope,
> RobustCGAlgorithms, RobustLineIntersector
>
> compiled with
> -O3 -fomit-frame-pointer
>
> and tweak below
>
> (PIII 733)
>
>  Pts: 1000  Executed in     20 ms.
>  Pts: 2000  Executed in     40 ms.
>  Pts: 4000  Executed in     70 ms.
>  Pts: 8000  Executed in    160 ms.
>  Pts: 16000  Executed in    351 ms.
>  Pts: 32000  Executed in    661 ms.
>  Pts: 64000  Executed in   1302 ms.
>  Pts: 128000  Executed in   2593 ms.
>  Pts: 256000  Executed in   5267 ms.
>
> Note Yury reported
>  n Pts: 256000  Executed in   7120 ms.
> on a (P4-2.53):
>
> Norman
>
> // below I am assuming this means
> //  "is on line segment"  between getAt(i) and getAt(i-1)
>
> bool RobustCGAlgorithms::isOnLine(Coordinate p,CoordinateList pt) {
>  for(int i=1;i<pt.getSize();i++) {
>   if( pt.inRange(p,i-1,i) ) {
>    lineIntersector->computeIntersection(p,pt.getAt(i-1),pt.getAt(i));
>    if (lineIntersector->hasIntersection()) {
>     return true;
>    }
>   }
>  }
>  return false;
> }
>
>
> class CoordinateList
>
> public
>
>  bool inXrange( double x, int idx1, int idx2) {
>   if( x >= (*vect)[idx1].x )
>    return x <= (*vect)[idx2].x;
>   else if( x <= (*vect)[idx1].x )
>    return x >= (*vect)[idx2].x;
>   return false;
>  }
>
>  bool inYrange( double y, int idx1, int idx2) {
>   if( y >= (*vect)[idx1].y )
>    return y <= (*vect)[idx2].y;
>   else if( y <= (*vect)[idx1].y )
>    return y >= (*vect)[idx2].y;
>   return false;
>  }
>
>  bool inRange( Coordinate &pt, int idx1, int idx2) {
>   return( inXrange(pt.x,idx1,idx2) && inYrange(pt.y,idx1,idx2) );
>  }
>
>
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
>
>



From nhv at cape.com  Mon Nov 25 00:31:44 2002
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Current project status
References: 
	<5A94289A9268514C8D6C0F1FF44BA0270FD4C8@venus.VividSolutions.com><046501c2943e$c035a6e0$b137ba8c@sfdev3>
	<002201c29441$e739dfb0$b9354d18@yury>
Message-ID: <049801c29443$f1db5c80$b137ba8c@sfdev3>

Yury A. Bychkov writes:

> Slight error. You didn't look far enough in my results. 7120 ms was for the
> original version. The version that is in CVS now (before your inlining) has "n
> Pts: 256000  Executed in   4276 ms".

Ooops ...

I didn't think I could had speeded it up that much

But the point is still valid

as I would expect that to be ~2000 ms with inlined the code

since your machine is much faster then mine

Cheers

Norman

From ybychkov at direct.ca  Mon Nov 25 00:33:28 2002
From: ybychkov at direct.ca (Yury A. Bychkov)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Current project status
References: <5A94289A9268514C8D6C0F1FF44BA0270FD4C8@venus.VividSolutions.com>
 <046501c2943e$c035a6e0$b137ba8c@sfdev3> <002201c29441$e739dfb0$b9354d18@yury>
 <049801c29443$f1db5c80$b137ba8c@sfdev3>
Message-ID: <005401c29444$2fb40890$b9354d18@yury>

Sure. I agree. After I'll finish modifying the code for CoordinateList and
Coordinate I'll inline as much of it as possible.

Yury

----- Original Message -----
From: "Norman Vine" <nhv@cape.com>
To: "GEOS Development List" <geos-devel@geos.refractions.net>
Sent: Sunday, November 24, 2002 9:31 PM
Subject: Re: [geos-devel] Current project status


> Yury A. Bychkov writes:
>
> > Slight error. You didn't look far enough in my results. 7120 ms was for the
> > original version. The version that is in CVS now (before your inlining) has
"n
> > Pts: 256000  Executed in   4276 ms".
>
> Ooops ...
>
> I didn't think I could had speeded it up that much
>
> But the point is still valid
>
> as I would expect that to be ~2000 ms with inlined the code
>
> since your machine is much faster then mine
>
> Cheers
>
> Norman
>
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
>
>



From nhv at cape.com  Mon Nov 25 00:48:48 2002
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Current project status
References: <5A94289A9268514C8D6C0F1FF44BA0270FD4C8@venus.VividSolutions.com>
	<046501c2943e$c035a6e0$b137ba8c@sfdev3> <002201c29441$e739dfb0$b9354d18@yury>
	<049801c29443$f1db5c80$b137ba8c@sfdev3> <005401c29444$2fb40890$b9354d18@yury>
Message-ID: <04b501c29446$53c18c10$b137ba8c@sfdev3>

Yury A. Bychkov writes:
>
> Sure. I agree. After I'll finish modifying the code for CoordinateList and
> Coordinate I'll inline as much of it as possible.

Yup, no point in doing to early

FYI - 
I have been using this to keep from filling
up the code with strings when inlining

class CoordinateList : public CoordinateListInterface {
public:
 enum {
  BOUNDS_ERROR,
  RETRIEVE_ERROR,
  CHANGE_ERROR,
  REMOVE_ERROR
 };

 Coordinate& getAt(int pos){
  if (pos < 0 || pos>vect->size()-1) 
   throw err_msg[BOUNDS_ERROR] ;
  current=pos;
  return (*vect)[current];
 }

private:
.....
 static char *err_msg[4];
}


then in Coordinate.cpp

char *CoordinateList::err_msg[] = {
   "CoordinateList exception: out of bounds\n",
   "CoordinateList exception: can't retrieve element\n",
   "CoordinateList exception: can't change element\n",
   "CoordinateList exception: can't remove element\n"
}; 


These are some helper functions that let me
pass iterating over a CoordinateList into
the class that seems to help too

ie things like
bool Geometry::hasNullElements(CoordinateList list){
 return list.hasNullElement();
}

bool CoordinateList::hasNullElement()
{
 int size = vect->size();
 for (int i=0; i<size; i++) {
   // I think this is true NHV
  if ((*vect)[i].x == DoubleNotANumber) {
   return true;
  }
 }
 return false;
}

bool CoordinateList::hasElement(Coordinate pt)
{
 int size = vect->size();
 for (int i = 0; i<size; i++) {
  if ((*vect)[i] == pt) {
   return true;
  }
 }
 return false;
}

int CoordinateList::indexOfMaxY()
{
 int index = 0;
 int size = vect->size();
 double tmp = (*vect)[0].y;
 for (int i=1; i<size; i++) {
  if ((*vect)[i].y > tmp) {
   tmp = (*vect)[i].y;
   index = i;
  }
 }
 return index;
}

int CoordinateList::indexOfMinY()
{
 int index = 0;
 int size = vect->size();
 double tmp = (*vect)[0].y;
 for (int i=1; i<size; i++) {
  if ((*vect)[i].y < tmp) {
   tmp = (*vect)[i].y;
   index = i;
  }
 }
 return index;
}

int CoordinateList::indexOfMaxX()
{
 int index = 0;
 int size = vect->size();
 double tmp = (*vect)[0].x;
 for (int i=1; i<size; i++) {
  if ((*vect)[i].x > tmp) {
   tmp = (*vect)[i].x;
   index = i;
  }
 }
 return index;
}

int CoordinateList::indexOfMinX()
{
 int index = 0;
 int size = vect->size();
 double tmp = (*vect)[0].x;
 for (int i=1; i<size; i++) {
  if ((*vect)[i].x < tmp) {
   tmp = (*vect)[i].x;
   index = i;
  }
 }
 return index;
}

void CoordinateList::getMinMax2D( double *minx, double *maxx, double *miny, double *maxy )
{
 double xmin = (*vect)[0].x;
 double ymin = (*vect)[0].y;
 double xmax = (*vect)[0].x;
 double ymax = (*vect)[0].y;
 int size = vect->size();
 for (int i=1; i<size; i++) {
  xmin = min(xmin, (*vect)[i].x); //min
  xmax = max(xmax, (*vect)[i].x);
  ymin = min(ymin, (*vect)[i].y);
  ymax = max(ymax, (*vect)[i].y);
 }
 *minx = xmin;
 *maxx = xmax;
 *miny = ymin;
 *maxy = ymax;
}

bool CoordinateList::equalsExact(CoordinateList *other )
{
 int size  = vect->size();
 if( size != other->getSize() )
  return false;
 for (int i = 0; i < size; i++) {
  if (!((*vect)[i] == other->getAt(i)))
   return false;
 }
 return true;
}





From mbdavis at VividSolutions.com  Tue Nov 26 12:34:20 2002
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:05 2007
Subject: [geos-devel] Summary of design decisions for CoordinateList
Message-ID: <5A94289A9268514C8D6C0F1FF44BA02701DD78@venus.VividSolutions.com>

Yury and I just discussed what remains to be done to finish the design and implementation of CoordinateList within GEOS.  This is a summary of the final design, in case anyone has comments.  (Note that it repeats some of the design requirements from the original discussion a couple of weeks ago).

==========================================
CoordinateList is an interface (abstract class) that encapsulates the actual implementation of lists of Coordinates. This allows clients with their own pointlist structures to pass them into GEOS without copying them.  

A concrete implementation BasicCoordinateList is provided to handle "native" GEOS CoordinateLists (based on vectors and GEOS Coordinates).  In addition, a sample implementation PointCoordinateList based on an array of struct { 3 x double } is provided as well, as an example of how users can write adapters for their own storage format.

[** Important] When GEOS methods create CoordinateLists (e.g. in the overlay functions and buffer) it will create instances of the native BasicCoordinateList.  Users will be responsible for copying the resulting points into the their own structures, as need be.  The reason for this decision is to avoid having to associate a factory class with every Geometry.  Also, constructed CoordinateLists are likely to be copied to somewhere else anyway by the client application, so this shouldn't pose much of a problem.

CoordinateLists are immutable - in the few cases in GEOS where it is required to change the value of one or many coordinates in a Geometry, a new CoordinateList will be created and the old one deleted.  

It is up to the implementation of CoordinateList subclasses how they handle the delete operator.  A CoordinateList that wrappers a client pointlist will probably not delete that memory when the wrapper object is deleted.  The native BasicCoordinateList *will* delete its list of points.  

For efficiency, CoordinateList point storage should be implemented as an array of Coordinate values (NOT a list of pointers to coordinates).

GEOS Geometry objects "own" their CoordinateLists.  All CoordinateLists are deleted when the Geometry itself is deleted.  CoordinateLists are not shared - when new Geometrys are constructed (e.g in the overlay methods) new CoordinateLists will be constructed internally for the new Geometry.

==========================================

Note: I guess we *could* make the CoordinateList factory class a singleton, so that a single instance of GEOS would also use the same format for CoordinateLists.   Any thoughts on this from the team?  It's easy to add this later, anyway.

Martin Davis, Senior Technical Specialist
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


