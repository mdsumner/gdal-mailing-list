From me at yury.ca  Wed May  7 05:09:18 2003
From: me at yury.ca (Yury A. Bychkov)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Status
Message-ID: <000a01c31478$64125560$b9354d18@yury>

All currently ported GEOS code has been upgraded to match JTS 1.3. New classes
(introduced in JTS 1.3) are being ported now. Note: Because of this the current
version from CVS does not compile.

Next to do:
1. Change all exceptions to classes.

Things left to port:
1. ConvexHull class from 'algorithm'
2. 'operation/distance' package
3. 'operation/buffer' package

Yury


From mmueller at intevation.de  Fri May  9 06:08:25 2003
From: mmueller at intevation.de (Martin =?ISO-8859-1?Q?M=FCller?=)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Memory leak
Message-ID: <1052474903.3813.31.camel@dhcp197.hq>

Hi there,

thank you for the good job you have done till now, and keep it on.
I just want to get some information about the memory leak problems in
geos. 
I'm developing an SFSQL compliant database interface for a geodata
viewer called thuban as diploma thesis. To make it SFSQL compliant I had
to use the cvs version of postgis with geos. 
Everything except for the memory leak seems to work fine, but I can't
test thuban with big maps. If I do a few redraws to fit it to the
canvas, or to zoom into the map, I have to select all geometries in a
region by using the intersects() function. That makes the postmaster
process run out of memory very fast.
If you are interested in thuban, you can get more information at
http://thuban.intevation.de The cvs doesn't contain thuban with the
database interface at the moment, but it will released as a branch in
some days I think. The branch will be merged later on.

So, when do you think you will fix the leak in geos?

Thanx for the help,

	Martin M?ller


-- 
_______________________________
"Microsoft isn't evil, they just make 
realy crappy operating systems." 

Linus Torwalds
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: application/pgp-signature
Size: 189 bytes
Desc: Dies ist ein digital signierter Nachrichtenteil
Url : http://lists.osgeo.org/pipermail/geos-devel/attachments/20030509/7e1266ab/attachment.bin
From mbdavis at VividSolutions.com  Fri May  9 12:12:29 2003
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Memory leak
Message-ID: <5A94289A9268514C8D6C0F1FF44BA0271DF5F4@venus.VividSolutions.com>

Currently the priority is porting JTS 1.3 to the GEOS codebase.  Memory issues will be addressed after that.  A rough estimate of when we'll start that work is mid-June.

Martin Davis, Senior Technical Architect
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


> -----Original Message-----
> From: Martin M?ller [mailto:mmueller@intevation.de]
> Sent: Friday, May 09, 2003 3:08 AM
> To: geos-devel@geos.refractions.net
> Subject: [geos-devel] Memory leak
> 
> 
> Hi there,
> 
> thank you for the good job you have done till now, and keep it on.
> I just want to get some information about the memory leak problems in
> geos. 
> I'm developing an SFSQL compliant database interface for a geodata
> viewer called thuban as diploma thesis. To make it SFSQL 
> compliant I had
> to use the cvs version of postgis with geos. 
> Everything except for the memory leak seems to work fine, but I can't
> test thuban with big maps. If I do a few redraws to fit it to the
> canvas, or to zoom into the map, I have to select all geometries in a
> region by using the intersects() function. That makes the postmaster
> process run out of memory very fast.
> If you are interested in thuban, you can get more information at
> http://thuban.intevation.de The cvs doesn't contain thuban with the
> database interface at the moment, but it will released as a branch in
> some days I think. The branch will be merged later on.
> 
> So, when do you think you will fix the leak in geos?
> 
> Thanx for the help,
> 
> 	Martin M?ller
> 
> 
> -- 
> _______________________________
> "Microsoft isn't evil, they just make 
> realy crappy operating systems." 
> 
> Linus Torwalds
> 
From dblasby at refractions.net  Mon May 12 16:37:47 2003
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Dealing with GEOS exceptions 
Message-ID: <3EC0061B.6080904@refractions.net>

Just before I left for holidays (I returned today), I tried to create a 
wrapper around the GEOS functions so that proper exception handling 
would occur.

Unfortunately, it failed.  The code is in CVS (i think) - 
headers/GeometryCAPI.h and util/GeometryCAPI.cpp. I've include some of 
it below so you could see what its doing.  

Unfortunately, this wrappers did not work.  It works in situations like 
this where there is no stack-unrolling-exception handling:

// this function always returns 0
int f()
{
    try
    {
            throw "an exception occurred";
            // never get here
    }
    catch (...)
    {
         return 0;
    }
    return 1;  // never get here either
}

If you try something like this, where there is a stack-unrolling, it 
doesnt work:

int g()
{
    throw "an exception occured";
// never get here
}

// this function will cause a SIGABORT and terminate.
int f()
{
    try
    {
            g();  // g() throws an exception
            // never get here
    }
    catch (...)
    {
         return 0;
    }
    return 1; // never get here
}

I'm out of simple solutions now.  The only thing I can think of trying 
is using the most
up-to-date gcc/g++ and libc/libc++.  Unfortunately, this isnt a very 
nice option (I'm not
even sure if it would work) because it would force everyone to use these 
programs
and libraries - that could be difficult.

Another solution would be to link postgresql with libc++ instead of
libc.  Unfortunately, this would force people to have a non-standard 
postgresql installation,
something I dont think is an option.

If anyone has *ANY* suggestions or thoughts, please let me know.


-------------------------------------------------------------------------------------

// This is just a simple wrapper for basic geometry functions.  See the
// Geometry type documentation for exact definition for these functions.
//
//
// Because some C programs might have trouble calling C++ (most notably
// postgresql, PERL, PYTHON, JAVA, etc...) when there is triple indirect
// access  (postgresql -> libpostgis -> libgeos).
// A more technical discussion of this bug is at 
http://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=37
933
//  Basically, if libc is loaded before libc++ exception handling might 
be comprimised.
// 
// This class solves this problem.  It basically wraps try..catch blocks 
around the obvious
// calls to GEOS functions.
//
// For functions that return a boolean (ie. g->isValid() or 
g1->disjoint(g2)), these functions
// return:
//     0  -- FALSE
//     1  -- TRUE
//     2  -- ERROR OCCURRED  * usually due to invalid geometry or 
robustness failure
//
//
//  For functions that return objects (ie. g->asText(), g1->relate(g2)), 
these functions
//  return either the appropriate object or NULL if an error occurred.
//
//
// Usage:
//  if you want to do
//     g1->relate(g2);
//
//  then you do:
//              GeometryCAPI *capi = new GeometryCAPI();
//              char result        =  capi->relate(g1,g2);
//              if (result ==2)
//              {
//                      //handle error
//              }
//
//
//  GeometryCAPI also handles geometry construction.  When you create a 
GeometryCAPI,
//  you also make a new GeometryFactory (see GeometryCAPI constructors 
vis-a-vis GeometryFactory).

...

        Geometry *GeometryCAPI::createPoint(Coordinate *c)
        {
                try{
                        Geometry *result =factory->createPoint(*c);
                        return result;
                }
                catch (...)
                {
                        return NULL;
                }
        }
....
char GeometryCAPI::touches(Geometry *g1, Geometry*g2)
{
        try {
                bool result;
                result =  g1->touches(g2);
                if (result)
                        return 1;
                else
                        return 0;
        }
        catch (...)
        {
                return 2;
        }
}




From me at yury.ca  Tue May 13 02:04:31 2003
From: me at yury.ca (Yury A. Bychkov)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Status
Message-ID: <011c01c31915$9a350740$b9354d18@yury>

1. Several classes from JTS 1.3 (STRtree,DoubleBits and similar) are still
giving me trouble, but hopefully I'll solve it soon.
2. 'operation/distance' has been ported.

Next to do:
1. Change all exceptions to classes.

Things left to port:
1. ConvexHull class from 'algorithm'
3. 'operation/buffer' package

Yury


From ben at vterrain.org  Thu May 15 19:26:54 2003
From: ben at vterrain.org (Ben Discoe)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] should it build?
Message-ID: <IHEAIHOJLJNLHCKGKJEDEEMPCEAA.ben@vterrain.org>


I tried out GEOS today, looking for an alternative to the simple features
implementation in OGR (http://gdal.velocet.ca/projects/opengis/)

I grabbed GEOS from CVS, and made a VC6 project file for it.  After working
through a few fixable compile issues, i hit this:

Geometry.cpp(305) : error C2065: 'BufferOp' : undeclared identifier

Indeed there is no Geometry::BufferOp.

Questions:

1. Is what's in CVS supposed to build?
2. If not, is there an archive of the last time it was building?
3. Does anyone want the compile fixes i made?

Thanks,
Ben
(VTP/TOPP)
http://vterrain.org/
http://openplans.org/


From me at yury.ca  Thu May 15 22:26:09 2003
From: me at yury.ca (Yury A. Bychkov)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] should it build?
References: <IHEAIHOJLJNLHCKGKJEDEEMPCEAA.ben@vterrain.org>
Message-ID: <003c01c31b52$9733d2d0$b9354d18@yury>

Hi Ben,

> 1. Is what's in CVS supposed to build?
The version currently in CVS is not supposed to build. I am currently modifying
some classes that are used in multiple places. As soon as that is finished I'll
commit a buildable version. That version however will not be complete, since the
project is still in development and some packages (e.g. operation/buffer) are
not ported yet.

> 2. If not, is there an archive of the last time it was building?
Sorry, as an oversight on my part, no buildable release was tagged. It'll be
fixed next time I have a compilable version. Maybe somebody else on the list
saved such a version though.

> 3. Does anyone want the compile fixes I made?
Yes. Can you email them to me at ybychkov-at-direct-dot-ca?

Thank you for interest in GEOS,
Yury


From dblasby at refractions.net  Thu May 22 13:17:32 2003
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Re: [postgis-users] GEOS / Predicates Update
In-Reply-To: <C381B891-8C74-11D7-948D-000393D33C2E@refractions.net>
References: <C381B891-8C74-11D7-948D-000393D33C2E@refractions.net>
Message-ID: <3ECD062C.6000908@refractions.net>

 >  - Try the very latest gcc, glibc, and libstdc++ libraries and see if 
 > the problem has been resolved.

I'd also like to ensure that the up-to-date linux libraries and 
compilers solve the problem.  I'd also like to know what happens on a 
cygwin/win32 system.


>   - Re-write some chunks of GEOS to not throw exceptions. This is bad 
> for two reasons.  It is a large amount of work, and it also is bad 
> design.  The exceptions are there for a reason, and replacing them with 
> large chains of null handling will be unpleasant.  There are some 
> "exception emulation" libraries for C which could make the process less 
> unpleasant, but it will still not be nice at all.

I'm voting for this option because I think the compiler-and-library 
version problem will solve itself over time (click your feet and say 
"there's no place like home").

There are remarkably few THROWs in GEOS - only about 63.  There are
only about 20 CATCHes.

The simpliest way to do the conversion would be to have the functions
return, say, NULL if an error occurred.  The calling function would have 
to check to see if the result is NULL - if it is it could propogate the 
error up.
For functions that have NULL as a valid result, you could return a 
simple object like this (excuse my java pseudo-code):
{
	boolean errorOccurred;
	Object result;
}
The calling function would check to see if result.errorOccurred is true. 
   This could be auto-matically handled using macros.  There are already 
existing exceptions-for-C open source projects that do something like this.

There are two problems with this:
1. I'm not sure how the code is layed out - there could be a large 
number of functions to check and modify.  It could also get ugly.
2. Libraries and things like templates may throw-errors-behind your back.


>   - Re-write GEOS entirely, and again, in C. This at least would be a 
> clean implementation of the algorithms, but it is even more work, and 
> would constitute yet another port of JTS which would have to be kept 
> synchronous with the JTS R&D over time.

I dont think this would be wise idea - its way too much work for too 
little gain.  Any C implementation would be uglier than C++ without
exceptions.


dave


From fvilla at zoo.uvm.edu  Thu May 22 14:24:12 2003
From: fvilla at zoo.uvm.edu (Ferdinando Villa)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Re: [postgis-users] GEOS / Predicates Update
In-Reply-To: <3ECD062C.6000908@refractions.net>
References: <C381B891-8C74-11D7-948D-000393D33C2E@refractions.net>
	 <3ECD062C.6000908@refractions.net>
Message-ID: <1053627852.26296.3.camel@basil>

> >   - Re-write some chunks of GEOS to not throw exceptions. This is bad 
> > for two reasons.  It is a large amount of work, and it also is bad 
> > design.  The exceptions are there for a reason, and replacing them with 
> > large chains of null handling will be unpleasant.  There are some 
> > "exception emulation" libraries for C which could make the process less 
> > unpleasant, but it will still not be nice at all.
> 
> I'm voting for this option because I think the compiler-and-library 
> version problem will solve itself over time (click your feet and say 
> "there's no place like home").
> 
> There are remarkably few THROWs in GEOS - only about 63.  There are
> only about 20 CATCHes.

...or maybe something like

template <typename return_value_of_func>
bool handle_error(GeosException* exc, return_value_of_func error_return)
	throw (GeosException*)
{
   if (geos::use_exceptions)
     throw exc;
   else
     delete exc;
   return error_return;
}

and instead of 
   throw new GeosException(...);
we write
   return handle_geos_error(new GeosException(...),
                            whatever_we_should_return);

may be a bit of a pain to use the return value and it's ugly, but it
would control it all with a single global var and leave the exceptions
as a default option.


> The simpliest way to do the conversion would be to have the functions
> return, say, NULL if an error occurred.  The calling function would have 
> to check to see if the result is NULL - if it is it could propogate the 
> error up.
> For functions that have NULL as a valid result, you could return a 
> simple object like this (excuse my java pseudo-code):
> {
> 	boolean errorOccurred;
> 	Object result;
> }
> The calling function would check to see if result.errorOccurred is true. 
>    This could be auto-matically handled using macros.  There are already 
> existing exceptions-for-C open source projects that do something like this.
> 
> There are two problems with this:
> 1. I'm not sure how the code is layed out - there could be a large 
> number of functions to check and modify.  It could also get ugly.
> 2. Libraries and things like templates may throw-errors-behind your back.
> 
> 
> >   - Re-write GEOS entirely, and again, in C. This at least would be a 
> > clean implementation of the algorithms, but it is even more work, and 
> > would constitute yet another port of JTS which would have to be kept 
> > synchronous with the JTS R&D over time.
> 
> I dont think this would be wise idea - its way too much work for too 
> little gain.  Any C implementation would be uglier than C++ without
> exceptions.
> 
> 
> dave
> 
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
-- 
ferdinando villa, ph.d.                    associate professor
gund institute for ecological economics, university of vermont
590 main street, burlington, vt 05405    phone: (802) 656-2972


From nhv at cape.com  Thu May 22 15:55:24 2003
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Re: [postgis-users] GEOS / Predicates Update
In-Reply-To: <1053627852.26296.3.camel@basil>
Message-ID: <EKEJIKAILPONGGENMBGACECMDIAA.nhv@cape.com>

Ferdinando Villa writes:
>
> > >   - Re-write some chunks of GEOS to not throw exceptions. This is bad
> > > for two reasons.  It is a large amount of work, and it also is bad
> > > design.  The exceptions are there for a reason, and replacing
> them with
> > > large chains of null handling will be unpleasant.  There are some
> > > "exception emulation" libraries for C which could make the
> process less
> > > unpleasant, but it will still not be nice at all.
> >
> > I'm voting for this option because I think the compiler-and-library
> > version problem will solve itself over time (click your feet and say
> > "there's no place like home").

> ...or maybe something like
>
> template <typename return_value_of_func>
> bool handle_error(GeosException* exc, return_value_of_func error_return)
> 	throw (GeosException*)
> {
>    if (geos::use_exceptions)
>      throw exc;
>    else
>      delete exc;
>    return error_return;
> }
>
> and instead of
>    throw new GeosException(...);
> we write
>    return handle_geos_error(new GeosException(...),
>                             whatever_we_should_return);
>
> may be a bit of a pain to use the return value and it's ugly, but it
> would control it all with a single global var and leave the exceptions
> as a default option.

I thnk that should work :)

But...  I can't help but wonder if the problem wouldn't automagically
disappear if we compiled the PostGIS code as C++ and made the
GEOS part of PostGIS a real C++ module that knew all about
handling exceptions

Cheers

Norman


From dblasby at refractions.net  Thu May 22 16:07:07 2003
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Re: [postgis-users] GEOS / Predicates Update
In-Reply-To: <EKEJIKAILPONGGENMBGACECMDIAA.nhv@cape.com>
References: <EKEJIKAILPONGGENMBGACECMDIAA.nhv@cape.com>
Message-ID: <3ECD2DEB.2050009@refractions.net>

> But...  I can't help but wonder if the problem wouldn't automagically
> disappear if we compiled the PostGIS code as C++ and made the
> GEOS part of PostGIS a real C++ module that knew all about
> handling exceptions

I have thought about this, but havent experimented with it.  I also 
experimented with statically linking the c++ library into postgis, but 
was unable to get it work (anyone know how to do it?).

It would be a good experiment to write a simple C++ plugin for 
postgresql and see if it has any problems.  If this works, there 
shouldnt be any difficult problems converting PostGIS to C++ - but it 
could be time consuming.

dave


From nhv at cape.com  Thu May 22 16:46:29 2003
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Re: [postgis-users] GEOS / Predicates Update
In-Reply-To: <3ECD2DEB.2050009@refractions.net>
Message-ID: <EKEJIKAILPONGGENMBGACECODIAA.nhv@cape.com>

David Blasby writes:
> 
> > But...  I can't help but wonder if the problem wouldn't automagically
> > disappear if we compiled the PostGIS code as C++ and made the
> > GEOS part of PostGIS a real C++ module that knew all about
> > handling exceptions
> 
> I have thought about this, but havent experimented with it.  I also 
> experimented with statically linking the c++ library into postgis, but 
> was unable to get it work (anyone know how to do it?).

You need to link with c++ not gcc
 
> It would be a good experiment to write a simple C++ plugin for 
> postgresql and see if it has any problems.  If this works, there 
> shouldnt be any difficult problems converting PostGIS to C++ - but it 
> could be time consuming.

Shouldn't be too much work as most of the existing code can be

#ifdef __cplusplus
extern "C" {
#endif
....
}

One thing I noticed whrn trying to compile the existing code with
C++ is that most of the allocs inside of PostGIS will need to be cast
appropriately  

i.e  instead of 
char *result = palloc(size);
char *result = (char *)palloc(size);

This should probably be being done anyway !

Another gottcha is in PostgesSQL it self and *requires* a change
that should probably be brought to the pgsql developers attention

postgresql-7.3.2-1\src\include\nodes\memnodes.h

typedef struct MemoryContextMethods
{
	void	   *(*alloc) (MemoryContext context, Size size);
	/* call this free_p in case someone #define's free() */
	void		(*free_p) (MemoryContext context, void *pointer);
	void	   *(*realloc) (MemoryContext context, void *pointer, Size size);
	void		(*init) (MemoryContext context);
	void		(*reset) (MemoryContext context);
	void		(*delete) (MemoryContext context);
                                    ^^^^^^^^^^
delete is a reserved word in C++ !!!

Cheers

Norman



From pramsey at refractions.net  Fri May 23 13:48:54 2003
From: pramsey at refractions.net (Paul Ramsey)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Exception Issues
Message-ID: <1053712134.3ece5f06c3ae1@www>

Yury, Martin,
  What do you think of Ferdinando's proposal for allowing option suppression of 
exceptions in GEOS? It seems that the most widely approved cart-track out of 
our current problems with exceptions in PostGIS is to have an exception-free 
mode in GEOS. Do you have any comments on the thoughts about this?

For reference, here is my problem summary and Dave's detailed description:

http://postgis.refractions.net/pipermail/postgis-users/2003-May/002493.html
http://postgis.refractions.net/pipermail/postgis-users/2003-May/002453.html

I would like to get a decision made so we can start on resolving the problem 
ASAP.

Thanks,
Paul




From nhv at cape.com  Fri May 23 15:04:50 2003
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Exception Issues
In-Reply-To: <1053712134.3ece5f06c3ae1@www>
Message-ID: <EKEJIKAILPONGGENMBGAIEFMDIAA.nhv@cape.com>

Paul Ramsey
>
> I would like to get a decision made so we can start on resolving the
problem
> ASAP.

have we tried compiling with -fexceptions yet ??

google("gcc c++ exceptions  mixed with c code")
returns
http://gcc.gnu.org/ml/gcc/2002-12/msg01606.html

here is the man page
http://gcc.gnu.org/onlinedocs/gcc-3.0.4/gcc_3.html#SEC53

HTH

Norman



From pramsey at refractions.net  Fri May 23 16:10:37 2003
From: pramsey at refractions.net (Paul Ramsey)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Exception Issues
In-Reply-To: <EKEJIKAILPONGGENMBGAIEFMDIAA.nhv@cape.com>
References: <EKEJIKAILPONGGENMBGAIEFMDIAA.nhv@cape.com>
Message-ID: <1053720637.3ece803db6513@www>

There's a fine plan... 
We have not tried that... if we need to recompile PostgreSQL as well though... 
might be problematic. Will look into it.
P.

Quoting Norman Vine <nhv@cape.com>:

> Paul Ramsey
> >
> > I would like to get a decision made so we can start on resolving the
> problem
> > ASAP.
> 
> have we tried compiling with -fexceptions yet ??
> 
> google("gcc c++ exceptions  mixed with c code")
> returns
> http://gcc.gnu.org/ml/gcc/2002-12/msg01606.html
> 
> here is the man page
> http://gcc.gnu.org/onlinedocs/gcc-3.0.4/gcc_3.html#SEC53
> 
> HTH
> 
> Norman
> 
> 
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
> 





From pramsey at refractions.net  Fri May 23 16:12:14 2003
From: pramsey at refractions.net (Paul Ramsey)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Exception Issues
In-Reply-To: <EKEJIKAILPONGGENMBGAIEFMDIAA.nhv@cape.com>
References: <EKEJIKAILPONGGENMBGAIEFMDIAA.nhv@cape.com>
Message-ID: <1053720734.3ece809e1d211@www>

Hrm. My PostgreSQL installation compiles with the following flags only. I fear 
we'll still have stack unwinding problems without a patch to PostgreSQL as 
well. What versions of gcc support -fexceptions I wonder?

-O2 -g -Wall -Wmissing-prototypes -Wmissing-declarations 

Quoting Norman Vine <nhv@cape.com>:
> 
> have we tried compiling with -fexceptions yet ??
> 





From dblasby at refractions.net  Fri May 23 17:32:49 2003
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Exception Issues
In-Reply-To: <1053720734.3ece809e1d211@www>
References: <EKEJIKAILPONGGENMBGAIEFMDIAA.nhv@cape.com>
	<1053720734.3ece809e1d211@www>
Message-ID: <3ECE9381.7010002@refractions.net>

>>have we tried compiling with -fexceptions yet ??

This has no effect - the system still crashes exactly as before.

I'm also doubtful about converting PostGIS to C++.  I believe the real 
problem is that postgresql isnt linked directl to postgis (or the C++ 
libraries) - it dynamically loads the .so when you run a 
postgis-required function.

dave


From pramsey at refractions.net  Mon May 26 00:29:34 2003
From: pramsey at refractions.net (Paul Ramsey)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Exception Issues
Message-ID: <A7033714-8F32-11D7-A8DB-000393D33C2E@refractions.net>

Martin, Yury,
Your comments on our exception woes would be most appreciated...
Paul

      Paul Ramsey
      Refractions Research
      Email: pramsey@refractions.net
      Phone: (250) 885-0632


From me at yury.ca  Mon May 26 03:13:45 2003
From: me at yury.ca (Yury A. Bychkov)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Exception Issues
References: <A7033714-8F32-11D7-A8DB-000393D33C2E@refractions.net>
Message-ID: <00ca01c32356$6c810420$b9354d18@yury>

Of course I would prefer the solution that didn't require any code changes in
GEOS (e.g. recompiling with some flag or something like this), but so far it
seems that this will be impossible. But barring that, it seems that Ferdinando's
solution would be easiest to implement.

Yury.
P.S. I am not a big expert on C, so I am not sure if any of the other solutions
is better.

----- Original Message ----- 
From: "Paul Ramsey" <pramsey@refractions.net>
To: "GEOS List" <geos-devel@geos.refractions.net>
Sent: Sunday, May 25, 2003 9:29 PM
Subject: [geos-devel] Exception Issues


> Martin, Yury,
> Your comments on our exception woes would be most appreciated...
> Paul
>
>       Paul Ramsey
>       Refractions Research
>       Email: pramsey@refractions.net
>       Phone: (250) 885-0632
>
>
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel


From me at yury.ca  Mon May 26 03:20:32 2003
From: me at yury.ca (Yury A. Bychkov)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Status
References: <011c01c31915$9a350740$b9354d18@yury>
Message-ID: <00d601c32357$4d33e780$b9354d18@yury>

1. Final bugs in GEOS 1.3 migration have been fixed and tested.
2. All exceptions are changed to classes.

Currently I am working on 'operation/buffer'.

Things left to port:
1. Finish 'operation/buffer' package
2. ConvexHull class from 'algorithm'

Yury

From mbdavis at VividSolutions.com  Mon May 26 12:03:26 2003
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Exception Issues
Message-ID: <5A94289A9268514C8D6C0F1FF44BA02722550B@venus.VividSolutions.com>

Well, IMO the optimal sequence of fixes to try is:

1. Fix the compiler/linker/PostgresQL to eliminate the problem with aborting on exceptions in loaded libraries.  
2. Hack GEOS to eliminate or optionalize (love that word!) the exceptions.

I'm not an expert on #1, but since there have been several people commenting on this who presumably do know what they're talking about I'm guessing that for some sad reason this is not really an option.  (Although it seems that there *is* a compiler which will remove the problem - is the problem that we can't recompile PostgresQL?)  

#2 is ugly IMHO, but I guess in the absence of #1 we have no choice.  The approach of defining a new "return-value-with-exception" class seems fairly benign, in the sense that it's invertible, it's clear where it's being used, and it automatically reveals places where return code values need to be checked.  (The invertibility is important - a simplistic method of removing exceptions would be almost invisible, but would eliminae the information needed to add them back in, for other uses of GEOS or once the compiler problems are fixed).

I think it's going to have to be your final call, Dave and Paul, since you're the guys who know whether there's any option of implementing #1.

Martin Davis, Senior Technical Architect
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


> -----Original Message-----
> From: Paul Ramsey [mailto:pramsey@refractions.net]
> Sent: Sunday, May 25, 2003 9:30 PM
> To: GEOS List
> Subject: [geos-devel] Exception Issues
> 
> 
> Martin, Yury,
> Your comments on our exception woes would be most appreciated...
> Paul
> 
>       Paul Ramsey
>       Refractions Research
>       Email: pramsey@refractions.net
>       Phone: (250) 885-0632
> 
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
> 

From nhv at cape.com  Tue May 27 08:52:50 2003
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Exception Issues
In-Reply-To: <5A94289A9268514C8D6C0F1FF44BA02722550B@venus.VividSolutions.com>
Message-ID: <EKEJIKAILPONGGENMBGAGELIDIAA.nhv@cape.com>

Martin Davis writes:
>
> Well, IMO the optimal sequence of fixes to try is:
>
> 1. Fix the compiler/linker/PostgresQL to eliminate the problem
> with aborting on exceptions in loaded libraries.
> 2. Hack GEOS to eliminate or optionalize (love that word!) the exceptions.
>

IMO I am not sure we really have any problem other then that

** C++ is not JAVA **  and GEOS is a very much an attempt at
a literal translation of a JAVA library to C++ where the underlying
JAVA machine handles much of what the C++ programmer has
to handle explicitly as is to be expected with a 'lower level' interface
to the 'bits themselves' there is some confusion as to how to handle
C++ exceptions, which are NOT the same thing as JAVA exceptions

Disclaimer I usually do not use the C++ exception mechanism
so buyer beware..

That said now that we have all of the PostGIS GEOS interaction
in a C++ not a C library we should be able to handle any "standard"
exception thrown by the GEOS code by including it within an appropriate
 try block

i.e

#include <exception>
#include <iostream>
#include <geos/util.h>

int wrapped_GEOS_CALL(..)
{
  try
  {
    GEOS_CALL(..);
  }
  // catch unhandled GEOS exceptions
  catch (GEOSException& ge)
  {
     std::cout << "GEOS Exception :" <<  ge.toString() <<std::endl;
     return X;
  }

  // Catch other unhandled standard exceptions
  catch ( std::exception& e)
  {
    std::cout << "Standard Exception: " << e.what() << std::endl;
    return X;
  }
  return(0);
}

Note this does nothing to try to ensure that the underlying
machine is left in an appropriate state for further computing
which I believe the JAVA machine will try to do for you

HTH

Norman


From mbdavis at VividSolutions.com  Tue May 27 11:53:01 2003
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Exception Issues
Message-ID: <5A94289A9268514C8D6C0F1FF44BA027225510@venus.VividSolutions.com>

> There is some confusion as to how to handle
> C++ exceptions, which are NOT the same thing as JAVA exceptions

<rant>
Norman, you could well be right here, if you are talking about the precise semantics of the C++ VS Java execution model.  The Java execution semantics are pretty well defined (witness the high level of portability of code between different JVMs).  C++ semantics are MUCH less well defined (witness the current problems with exceptions to do with the compiler?  the linker?  the dynamic loader?  - all these tools vary greatly between different implementations, in undocumented and unpredictable ways)   
</rant>

That said, it's my belief that both C++ and Java exceptions are designed to do pretty much the same thing - allow transfer of control and error information up through the execution stack with minimal impact on code which does not handle the error.  In C++ this is trickier than in Java, since you need to manually clean up memory resources as you unwind the stack.  (The <autoptr> thingie in STL is supposed to help with this).  But I think we can accomplish this with some reasonable diligence.

> That said now that we have all of the PostGIS GEOS interaction
> in a C++ not a C library we should be able to handle any "standard"
> exception thrown by the GEOS code by including it within an 
> appropriate  try block

As I understand it, the problem we have is such that we can't simply fix it by wrapping each GEOS function in a try block.  (In fact, I think this was proposed and tried when we first encountered the problem). The problem is deeper than that - it goes back to what I said earlier about unexpected and widely varying semantics of the C++ execution model.  In this case, the compiler or linker being used handle a throw as an abort - which is probably not be considered as adherence to the generally accepted model of C++ execution.

Martin Davis, Senior Technical Architect
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com

> 

From dblasby at refractions.net  Tue May 27 12:09:31 2003
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Exception Issues
In-Reply-To: <5A94289A9268514C8D6C0F1FF44BA027225510@venus.VividSolutions.com>
References: <5A94289A9268514C8D6C0F1FF44BA027225510@venus.VividSolutions.com>
Message-ID: <3ED38DBB.1080209@refractions.net>

I'm not 100% sure of the exact nature of the problem, but 
http://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=37933
has some more technical details.

To summarize the article, the problem is not with the C++ exception 
mechanism; it works just fine if you link your program to libc++.  The 
problem is when you link the main program to libc (which doesnt 
understand c++ exception handling).  When the c++ code throws and 
exception that has to unwind the stack (ie. leave the function that 
threw it) a problem occurs because the default unwind mechinism in
libc is SIGABRT (terminate the program).

If the same program were linked to libc++, then the default unwind 
mechanism would handle the exception properly.

Anyways, read the article and see if my summary is accurate.

This isnt an issue in most program - a C program that is using libgeos 
would link it in at compile time.  This will cause it to link to libc++ 
not libc.

In postgresql, it is compiled and linked to libc.  When it want to load 
in postgis, it just openes up the .so at runtime (not compile time).

dave


From mbdavis at VividSolutions.com  Tue May 27 12:18:54 2003
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Exception Issues
Message-ID: <5A94289A9268514C8D6C0F1FF44BA0271DF6C8@venus.VividSolutions.com>

Thanks for the succinct summary, Dave.  I took a look at the bug report, but it makes my brain hurt wading thru all that stuff.

Sigh...  I guess we better start thinking about how to remap exceptions in GEOS into something non-offensive.

Martin Davis, Senior Technical Architect
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


> -----Original Message-----
> From: David Blasby [mailto:dblasby@refractions.net]
> Sent: Tuesday, May 27, 2003 9:10 AM
> To: GEOS Development List
> Subject: Re: [geos-devel] Exception Issues
> 
> 
> I'm not 100% sure of the exact nature of the problem, but 
> http://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=37933
> has some more technical details.
> 
> To summarize the article, the problem is not with the C++ exception 
> mechanism; it works just fine if you link your program to 
> libc++.  The 
> problem is when you link the main program to libc (which doesnt 
> understand c++ exception handling).  When the c++ code throws and 
> exception that has to unwind the stack (ie. leave the function that 
> threw it) a problem occurs because the default unwind mechinism in
> libc is SIGABRT (terminate the program).
> 
> If the same program were linked to libc++, then the default unwind 
> mechanism would handle the exception properly.
> 
> Anyways, read the article and see if my summary is accurate.
> 
> This isnt an issue in most program - a C program that is 
> using libgeos 
> would link it in at compile time.  This will cause it to link 
> to libc++ 
> not libc.
> 
> In postgresql, it is compiled and linked to libc.  When it 
> want to load 
> in postgis, it just openes up the .so at runtime (not compile time).
> 
> dave
> 
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
> 

From nhv at cape.com  Tue May 27 12:46:38 2003
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Exception Issues
In-Reply-To: <3ED38DBB.1080209@refractions.net>
Message-ID: <EKEJIKAILPONGGENMBGAIEMDDIAA.nhv@cape.com>

David Blasby writes:
> 
> I'm not 100% sure of the exact nature of the problem, but 
> http://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=37933
> has some more technical details.
> 
> To summarize the article, the problem is not with the C++ exception 
> mechanism; it works just fine if you link your program to libc++.  The 
> problem is when you link the main program to libc (which doesnt 
> understand c++ exception handling).  When the c++ code throws and 
> exception that has to unwind the stack (ie. leave the function that 
> threw it) a problem occurs because the default unwind mechinism in
> libc is SIGABRT (terminate the program).
> 
> If the same program were linked to libc++, then the default unwind 
> mechanism would handle the exception properly.
> 
> Anyways, read the article and see if my summary is accurate.
> 
> This isnt an issue in most program - a C program that is using libgeos 
> would link it in at compile time.  This will cause it to link to libc++ 
> not libc.
> 
> In postgresql, it is compiled and linked to libc.  When it want to load 
> in postgis, it just openes up the .so at runtime (not compile time).

This should be easily solved by modifying the Postgresql link step 
to link as C++ instead of 'C'.  

This is allowable in that C++ is by the 'standard' defined as a 
superset of C

Note I believe that this should only be necessary for the PostGIS
DLL 

Norman

From dblasby at refractions.net  Tue May 27 12:49:37 2003
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Exception Issues
In-Reply-To: <EKEJIKAILPONGGENMBGAIEMDDIAA.nhv@cape.com>
References: <EKEJIKAILPONGGENMBGAIEMDDIAA.nhv@cape.com>
Message-ID: <3ED39721.5010104@refractions.net>

> This should be easily solved by modifying the Postgresql link step 
> to link as C++ instead of 'C'.  

Theoretically, this should work.  Perhaps paul could compile our 7.3 
development system with libc++ instead of libc and we could see if it works?


> Note I believe that this should only be necessary for the PostGIS
> DLL 

PostGIS already links to libc++ instead of libc.  At least I think it 
does (the postgis_geoswrapper.cpp needs libc++ to compile).

Oh, I'm wrong - it links to both:

[dblasby@hydra postgis]$ ldd libpostgis.so.0.8
         libstdc++-libc6.2-2.so.3 => /usr/lib/libstdc++-libc6.2-2.so.3 
(0x4003d000)
         libgeos.so.1 => /usr/local/lib/libgeos.so.1 (0x4008a000)
         libproj.so.0 => /usr/local/lib/libproj.so.0 (0x40144000)
         libc.so.6 => /lib/libc.so.6 (0x40174000)
         libm.so.6 => /lib/libm.so.6 (0x402b0000)
         /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x80000000)


Anyone know how to get it to *not* link to libc?  The link step looks like:

gcc -g -Wall -Wmissing-prototypes -Wmissing-declarations -g -I. 
-DFRONTEND -DSYSCONFDIR='"/opt/pgsql73/etc"'  -DUSE_VERSION=73 
-I/usr/local/include/geos -DUSE_GEOS -I/usr/local/include -DUSE_PROJ 
-fpic -shared -Wl,-soname,libpostgis.so.0 postgis_debug.o postgis_ops.o 
postgis_fn.o postgis_inout.o postgis_proj.o postgis_chip.o 
postgis_transform.o postgis_gist_72.o postgis_estimate.o postgis_geos.o 
postgis_geos_wrapper.o    -lstdc++ -L/usr/local/lib -lgeos 
-L/usr/local/lib -lproj   -Wl,-rpath,/opt/pgsql73/lib -o libpostgis.so.0.8


dave



From chodgson at refractions.net  Tue May 27 12:55:35 2003
From: chodgson at refractions.net (chodgson@refractions.net)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Exception Issues
In-Reply-To: <3ED39721.5010104@refractions.net>
References: <EKEJIKAILPONGGENMBGAIEMDDIAA.nhv@cape.com>
	<3ED39721.5010104@refractions.net>
Message-ID: <1054054535.3ed3988777c94@www>

My guess is that you should compile and link using g++ instead of gcc?

Chris

Quoting David Blasby <dblasby@refractions.net>:

> > This should be easily solved by modifying the Postgresql link step
> > to link as C++ instead of 'C'.
> 
> Theoretically, this should work.  Perhaps paul could compile our 7.3
> development system with libc++ instead of libc and we could see if it works?
> 
> 
> > Note I believe that this should only be necessary for the PostGIS
> > DLL
> 
> PostGIS already links to libc++ instead of libc.  At least I think it
> does (the postgis_geoswrapper.cpp needs libc++ to compile).
> 
> Oh, I'm wrong - it links to both:
> 
> [dblasby@hydra postgis]$ ldd libpostgis.so.0.8
>          libstdc++-libc6.2-2.so.3 => /usr/lib/libstdc++-libc6.2-2.so.3
> (0x4003d000)
>          libgeos.so.1 => /usr/local/lib/libgeos.so.1 (0x4008a000)
>          libproj.so.0 => /usr/local/lib/libproj.so.0 (0x40144000)
>          libc.so.6 => /lib/libc.so.6 (0x40174000)
>          libm.so.6 => /lib/libm.so.6 (0x402b0000)
>          /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x80000000)
> 
> 
> Anyone know how to get it to *not* link to libc?  The link step looks like:
> 
> gcc -g -Wall -Wmissing-prototypes -Wmissing-declarations -g -I.
> -DFRONTEND -DSYSCONFDIR='"/opt/pgsql73/etc"'  -DUSE_VERSION=73
> -I/usr/local/include/geos -DUSE_GEOS -I/usr/local/include -DUSE_PROJ
> -fpic -shared -Wl,-soname,libpostgis.so.0 postgis_debug.o postgis_ops.o
> postgis_fn.o postgis_inout.o postgis_proj.o postgis_chip.o
> postgis_transform.o postgis_gist_72.o postgis_estimate.o postgis_geos.o
> postgis_geos_wrapper.o    -lstdc++ -L/usr/local/lib -lgeos
> -L/usr/local/lib -lproj   -Wl,-rpath,/opt/pgsql73/lib -o libpostgis.so.0.8
> 
> 
> dave
> 
> 
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
> 





From nhv at cape.com  Tue May 27 13:00:26 2003
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Exception Issues
In-Reply-To: <3ED39721.5010104@refractions.net>
Message-ID: <EKEJIKAILPONGGENMBGAOEMFDIAA.nhv@cape.com>

David Blasby writes:
>
> > This should be easily solved by modifying the Postgresql link step
> > to link as C++ instead of 'C'.
>
> Theoretically, this should work.  Perhaps paul could compile our 7.3
> development system with libc++ instead of libc and we could see
> if it works?

> Anyone know how to get it to *not* link to libc?  The link step
> looks like:
>
> gcc -g -Wall -Wmissing-prototypes -Wmissing-declarations -g -I.
> -DFRONTEND -DSYSCONFDIR='"/opt/pgsql73/etc"'  -DUSE_VERSION=73
> -I/usr/local/include/geos -DUSE_GEOS -I/usr/local/include -DUSE_PROJ
> -fpic -shared -Wl,-soname,libpostgis.so.0 postgis_debug.o postgis_ops.o
> postgis_fn.o postgis_inout.o postgis_proj.o postgis_chip.o
> postgis_transform.o postgis_gist_72.o postgis_estimate.o postgis_geos.o
> postgis_geos_wrapper.o    -lstdc++ -L/usr/local/lib -lgeos
> -L/usr/local/lib -lproj   -Wl,-rpath,/opt/pgsql73/lib -o libpostgis.so.0.8


This is an easy one  :-)

 c++ -g -Wall -Wmissing-prototypes -Wmissing-declarations -g -I.
 -DFRONTEND -DSYSCONFDIR='"/opt/pgsql73/etc"'  -DUSE_VERSION=73
 -I/usr/local/include/geos -DUSE_GEOS -I/usr/local/include -DUSE_PROJ
 -fpic -shared -Wl,-soname,libpostgis.so.0 postgis_debug.o postgis_ops.o
 postgis_fn.o postgis_inout.o postgis_proj.o postgis_chip.o
 postgis_transform.o postgis_gist_72.o postgis_estimate.o postgis_geos.o
 postgis_geos_wrapper.o -L/usr/local/lib -lgeos
 -L/usr/local/lib -lproj   -Wl,-rpath,/opt/pgsql73/lib -o libpostgis.so.0.8

Cheers

Norman


From nhv at cape.com  Tue May 27 13:00:54 2003
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Exception Issues
In-Reply-To: <5A94289A9268514C8D6C0F1FF44BA027225510@venus.VividSolutions.com>
Message-ID: <EKEJIKAILPONGGENMBGACEMGDIAA.nhv@cape.com>

Martin Davis writes:
> 
> > There is some confusion as to how to handle
> > C++ exceptions, which are NOT the same thing as JAVA exceptions
> 
> <rant>
> Norman, you could well be right here, if you are talking about 
> the precise semantics of the C++ VS Java execution model.  The 
> Java execution semantics are pretty well defined (witness the 
> high level of portability of code between different JVMs).  C++ 
> semantics are MUCH less well defined (witness the current 
> problems with exceptions to do with the compiler?  the linker?  
> the dynamic loader?  - all these tools vary greatly between 
> different implementations, in undocumented and unpredictable ways)   
> </rant>

C++ semantics are *very* well defined, it is just that they may vary a bit
between implementations :-)

However I believe this has little bearing on our problem, which AFAICT, 
stems from the fact that once you declare a try block in C++ *all* the 
exception handlers that have been declared come into play, this includes 
the *standard* exceptions !

Our problem is that we were AFAICT never trying to catch any 
exceptions other then those defined by GEOS hence when a
standard exception was thrown it was never caught and therefore
the underlying C++ standard terminate() handler was called when
a standard exception was raised.

> That said, it's my belief that both C++ and Java exceptions are 
> designed to do pretty much the same thing - allow transfer of 
> control and error information up through the execution stack with 
> minimal impact on code which does not handle the error. 

YES

> In C++ 
> this is trickier than in Java, since you need to manually clean 
> up memory resources as you unwind the stack.  (The <autoptr> 
> thingie in STL is supposed to help with this).  But I think we 
> can accomplish this with some reasonable diligence.

IMO We should consider the <autoptr> thingie or its equivalant
in that once adopted it's use is efficient, transparent and prevents
unhandled exceptions in that an objects destructor will deallocate
memory as required  :-)
 
> > That said now that we have all of the PostGIS GEOS interaction
> > in a C++ not a C library we should be able to handle any "standard"
> > exception thrown by the GEOS code by including it within an 
> > appropriate  try block
> 
> As I understand it, the problem we have is such that we can't 
> simply fix it by wrapping each GEOS function in a try block.  (In 
> fact, I think this was proposed and tried when we first 
> encountered the problem). The problem is deeper than that - it 
> goes back to what I said earlier about unexpected and widely 
> varying semantics of the C++ execution model.  

I don't think so esp since the *only* C++ code we are considering
here is *all* contained inside GEOS and the PostGIS-GEOS wrapper
which we have *complete* control over.  ie PostgreSQL is only 'C'
and knows *nothing* about C++ exceptions and could care less about
them :-)

> In this case, the 
> compiler or linker being used handle a throw as an abort - which 
> is probably not be considered as adherence to the generally 
> accepted model of C++ execution.

It actually is calling the *default* exception handler which is 
essentially the 'C' abort().  This is only because when unwinding
the stack there is no appropriate handler found for the exception
being called and this is the required 'behavior as defined by the 
'C++ standard'.

In order for me to help much more in debugging this it would
help considerably if there was a common test suite that demonstrates
the problem.

At a minimum this would consist of
1) A common PostGIS data set
2) The PostGIS GEOS enabled SQL query that causes the behaviour
     on this data set

I will try to come up with this but please remember that any of my work 
on GEOS and PostGIS is done in my 'free' time and thus has 'free time' 
priority.

Cheers

Norman


From dblasby at refractions.net  Tue May 27 13:00:40 2003
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Exception Issues
In-Reply-To: <1054054535.3ed3988777c94@www>
References: <EKEJIKAILPONGGENMBGAIEMDDIAA.nhv@cape.com>
	<3ED39721.5010104@refractions.net> <1054054535.3ed3988777c94@www>
Message-ID: <3ED399B8.6080504@refractions.net>

chodgson@refractions.net wrote:
> My guess is that you should compile and link using g++ instead of gcc?

You cannot compile postgis with g++ because of the use of "delete" (a 
reserved word in c++) in the postgresql memory manager.  Thats a pain in 
the butt.

I tried just using linking using g++ instead of gcc, but it gives the 
same results (just in a different order).

[dblasby@hydra postgis]$ g++  -g -Wall -Wmissing-prototypes 
-Wmissing-declarations -g -I. -DFRONTEND 
-DSYSCONFDIR='"/opt/pgsql73/etc"'  -DUSE_VERSION=73 
-I/usr/local/include/geos -DUSE_GEOS -I/usr/local/include -DUSE_PROJ 
-fpic -shared -Wl,-soname,libpostgis.so.0 postgis_debug.o postgis_ops.o 
postgis_fn.o postgis_inout.o postgis_proj.o postgis_chip.o 
postgis_transform.o postgis_gist_72.o postgis_estimate.o postgis_geos.o 
postgis_geos_wrapper.o    -lstdc++ -L/usr/local/lib -lgeos 
-L/usr/local/lib -lproj   -Wl,-rpath,/opt/pgsql73/lib -o libpostgis.so.0.8

[dblasby@hydra postgis]$ ldd libpostgis.so.0.8
         libstdc++-libc6.2-2.so.3 => /usr/lib/libstdc++-libc6.2-2.so.3 
(0x4003d000)
         libgeos.so.1 => /usr/local/lib/libgeos.so.1 (0x4008a000)
         libproj.so.0 => /usr/local/lib/libproj.so.0 (0x40144000)
         libm.so.6 => /lib/libm.so.6 (0x40174000)
         libc.so.6 => /lib/libc.so.6 (0x40196000)
         /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x80000000)



From dblasby at refractions.net  Tue May 27 13:10:33 2003
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Exception Issues
In-Reply-To: <EKEJIKAILPONGGENMBGAOEMFDIAA.nhv@cape.com>
References: <EKEJIKAILPONGGENMBGAOEMFDIAA.nhv@cape.com>
Message-ID: <3ED39C09.40305@refractions.net>

> This is an easy one  :-)
> 
>  c++ -g -Wall -Wmissing-prototypes -Wmissing-declarations -g -I.
>  -DFRONTEND -DSYSCONFDIR='"/opt/pgsql73/etc"'  -DUSE_VERSION=73
>  -I/usr/local/include/geos -DUSE_GEOS -I/usr/local/include -DUSE_PROJ
>  -fpic -shared -Wl,-soname,libpostgis.so.0 postgis_debug.o postgis_ops.o
>  postgis_fn.o postgis_inout.o postgis_proj.o postgis_chip.o
>  postgis_transform.o postgis_gist_72.o postgis_estimate.o postgis_geos.o
>  postgis_geos_wrapper.o -L/usr/local/lib -lgeos
>  -L/usr/local/lib -lproj   -Wl,-rpath,/opt/pgsql73/lib -o libpostgis.so.0.8

I still get the same links (c and c++).

[dblasby@hydra postgis]$  c++ -g -Wall -Wmissing-prototypes 
-Wmissing-declarations -g -I.  -DFRONTEND 
-DSYSCONFDIR='"/opt/pgsql73/etc"'  -DUSE_VERSION=73 
-I/usr/local/include/geos -DUSE_GEOS -I/usr/local/include -DUSE_PROJ 
-fpic -shared -Wl,-soname,libpostgis.so.0 postgis_debug.o postgis_ops.o 
   postgis_fn.o postgis_inout.o postgis_proj.o postgis_chip.o 
postgis_transform.o postgis_gist_72.o postgis_estimate.o postgis_geos.o 
   postgis_geos_wrapper.o -L/usr/local/lib -lgeos   -L/usr/local/lib 
-lproj   -Wl,-rpath,/opt/pgsql73/lib -o libpostgis.so.0.8
[dblasby@hydra postgis]$ ldd libpostgis.so.0.8
         libgeos.so.1 => /usr/local/lib/libgeos.so.1 (0x4003d000)
         libproj.so.0 => /usr/local/lib/libproj.so.0 (0x400f6000)
         libstdc++-libc6.2-2.so.3 => /usr/lib/libstdc++-libc6.2-2.so.3 
(0x40127000)
         libm.so.6 => /lib/libm.so.6 (0x40174000)
         libc.so.6 => /lib/libc.so.6 (0x40196000)
         /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x80000000)




From dblasby at refractions.net  Tue May 27 16:27:24 2003
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Exception Issues
In-Reply-To: <EKEJIKAILPONGGENMBGACEMGDIAA.nhv@cape.com>
References: <EKEJIKAILPONGGENMBGACEMGDIAA.nhv@cape.com>
Message-ID: <3ED3CA2C.8030109@refractions.net>

Norman,

You've got some good ideas here, I thought I'd try to summarize what 
I've done so far so you dont re-invent the wheel.

<spew mode>


================================
Here's a test C++ program.  It tries to relate "LINESTRING(0 0,0 0)" to 
itself.  This is an invalid geometry and causes an exception which is 
caught.  It catches an 'anonymous - "catch (...)"' exception.  The 
output is:

in try block
about to cause an exception
anonymous exeception

NOTE: this program is linked to both libc and libc++.

int main(int argC, char* argV[])
{

     WKTReader *r = new WKTReader();
     GeometryFactory *geomFactory;
     Geometry *g1, *g2,*g3, *g4 ;

     geomFactory= new GeometryFactory( new PrecisionModel(), -1);

     try{
         cout << "in try block " <<endl;

         g1 = r->read("LINESTRING(0 0,0 0)");
         g2 = r->read("LINESTRING(0 0,0 0)");


         cout << "about to cause an exception" << endl;
         IntersectionMatrix *im = g1->relate(g2);
         cout << "finished relate"<< endl;

     }
     catch (exception e)
     {
         cout << "caught exception"<<endl;
         cout << e.what() << endl;
     }
     catch (char *s)
     {
       cout << "caught string exception:"<<s<<endl;
     }
     catch (...)
     {
         cout << "anonymous exeception"<< endl;
     }
}

=========================================
I thought that I might be able to catch exceptions if I modified the 
GEOS source code.  I did an experiment like this:

Added a function to the GEOS geometry.cpp like this:

void throwError()
{
    cout << "about to throw an error" << endl;

    try {
   	 throw "weee an error\n";
    }
    catch (...)
    {
        cout <<"caught an error"<<endl;
    }
}

Amazingly, when I call this GEOS frunction from postgis, IT CATCHES THE 
ERROR!!

I was very happy with this and wrote GeometryCAPI (see attached) that 
would wrap all the important GEOS functions.  Unfortunately, this didnt
work.  The throwError() function doesnt actually involve a 
stack-unwinding, so the exceptionhandling works.  If you add these 2 
functions to GEOS Geometry.cpp:

void throwError2()
{
    cout << "in throwError2() - about to call throwError3()" << endl;

    try {
   	 throwError3();
    }
    catch (...)
    {
        cout <<"throwError2():caught an error"<<endl;
    }
}

void throwError3()
{
	throw "throwError3 error";
}

This doesnt work - when you call throwError2(), a stack unwinding takes 
place and a SIGABRT is caused.  Double-plus-ungood.

===================================

Next we tried compiling postgresql and postgis with the -fexceptions 
option.  This didnt have any any effect - SIBABRT is still sent during a 
stack-unwind.

===================================

My current working version (NOT commited to CVS) uses the GeometryCAPI 
method of calling GEOS.

To use my version:
1. Get the most recent GEOS - if it has util/GeometryCAPI.cpp great!  If 
not, you'll have to add it (attached).
2. replace the postgis_geos.c and postgis_geos_wrapper.cpp  in your 
postgis installation.

Basically, when postgis want to do a relate, it calls 
postgis_geos_wrapper.cpp::GEOSrelate(Geometry *g1, Geometry*g2).  This 
calls GeometryCAPI::relate(Geometry *g1, Geometry*g2).  This calls the
actual GEOS relate function.  All exception should be caught in the GEOS 
c++ code before it gets near postgis or postgresql.


The postgis_geos_wrapper.cpp::GEOSrelate(Geometry *g1, Geometry*g2) is 
very simple.  NOTE: this should never encounter an exception from 
GeometryCAPI - the try block here is just redunant.

char *GEOSrelate(Geometry *g1, Geometry*g2)
{
         try {
                 char *result = geometryCAPI->relate(g1,g2);

                 return result;
         }
         catch (...)
         {
                 return NULL;
         }
}

GeometryCAPI::relate(Geometry *g1, Geometry*g2) is also simple - it 
tries to catch errors thrown by GEOS.  It also prints out a little bit 
of debugging.

//callers responsiblity to free the char* this returns
char *GeometryCAPI::relate(Geometry *g1, Geometry*g2)
{
     try {
cout << "In GeometryCAPI::relate and about to g1->relate(g2) " << endl;

         IntersectionMatrix *im = g1->relate(g2);
cout << "past relate" << endl;

         string s;
         char *result;
         if (im == NULL)
                 return NULL;

         s= im->toString();
         result = (char*) malloc( s.length() + 1);
         strcpy(result, s.c_str() );
         return result;
     }
     catch (...)
     {

cout << "caught error in GeometryCAPI::relate" << endl;
         return NULL;
     }
}


The actual postgis function is a little more complex - but its mostly 
just debugging code.  It never gets past the "GEOSrelate(g1, g2);" line.

PG_FUNCTION_INFO_V1(relate_full);
Datum relate_full(PG_FUNCTION_ARGS)
{
     GEOMETRY        *geom1 = (GEOMETRY *) 
PG_DETOAST_DATUM(PG_GETARG_DATUM(0));
     GEOMETRY        *geom2 = (GEOMETRY *) 
PG_DETOAST_DATUM(PG_GETARG_DATUM(1));

     Geometry *g1,*g2;
     char    *relate_str;
     int len;
     char *result;

elog(NOTICE,"in relate_full()");

     errorIfGeometryCollection(geom1,geom2);


     initGEOS(MAXIMUM_ALIGNOF);

elog(NOTICE,"GEOS init()");

     g1 =    POSTGIS2GEOS(geom1 );
     g2 =    POSTGIS2GEOS(geom2 );

elog(NOTICE,"constructed geometries ");


if ((g1==NULL) || (g2 == NULL))
     elog(NOTICE,"g1 or g2 are null");

elog(NOTICE,GEOSasText(g1));
elog(NOTICE,GEOSasText(g2));

elog(NOTICE,"valid g1 = %i", GEOSisvalid(g1));
elog(NOTICE,"valid g2 = %i",GEOSisvalid(g2));

elog(NOTICE,"about to relate()");
        relate_str = GEOSrelate(g1, g2);

elog(NOTICE,"finished relate()");

     GEOSdeleteGeometry(g1);
     GEOSdeleteGeometry(g2);



     if (relate_str == NULL)
     {
         //free(relate_str);
         elog(ERROR,"GEOS relate() threw an error!");
         PG_RETURN_NULL(); //never get here
     }


     len = strlen(relate_str) + 4;

     result= palloc(len);
     *((int *) result) = len;

     memcpy(result +4, relate_str, len-4);

     free(relate_str);


     PG_RETURN_POINTER(result);
}


If look at the postgresql console while executing a simple query like:

select relate('LINESTRING(0 0,0 0)'::geometry,'LINESTRING(0 0,0 
0)'::geometry);

You'll see something like:

[postgres@hydra init.d]$ /opt/pgsql73/bin/postmaster -i -D 
/raid/pgdata/pgsql_devel_73
LOG:  database system was shut down at 2003-05-27 13:12:41 PDT
LOG:  checkpoint record is at 0/E955D68
LOG:  redo record is at 0/E955D68; undo record is at 0/0; shutdown TRUE
LOG:  next transaction id: 6708; next oid: 577113
LOG:  database system is ready
NOTICE:  in relate_full()
NOTICE:  GEOS init()
NOTICE:  constructed geometries
NOTICE:  LINESTRING (0.0000000000000000 0.0000000000000000, 
0.0000000000000000 0.0000000000000000)
NOTICE:  LINESTRING (0.0000000000000000 0.0000000000000000, 
0.0000000000000000 0.0000000000000000)
NOTICE:  valid g1 = 0
NOTICE:  valid g2 = 0
NOTICE:  about to relate()
In GeometryCAPI::relate and about to g1->relate(g2)
LOG:  server process (pid 11062) was terminated by signal 6


Signal 6 is SIGABRT.

===================================

</spew>

attached: GeometryCAPI.h     (inside GEOS)
           GeometryCAPI.cpp   (inside GEOS)
           postgis_geos_wrapper.cpp  (inside postgis)
           postgis_geos.c            (inside postgis)


What we havent tried:

1. linking postgresql to libc++.  This should work, but we dont want to 
have a special 'postgis' version of postgresql hanging around.
2. removing exceptions from GEOS.  This could be quite a bit of work
3. Try a newer compiler/libc
4. see if this problem occurs on other platforms.



-------------------------------------------------------
nhv@cape.com wrote:

> Our problem is that we were AFAICT never trying to catch any 
> exceptions other then those defined by GEOS hence when a
> standard exception was thrown it was never caught and therefore
> the underlying C++ standard terminate() handler was called when
> a standard exception was raised.

Yes - we are trying to catch all exceptions using the "catch (...)" 
symantic.  I think the real problem is that the default exception 
handler is supposed to pop the exception up the call stack, but the 
exception handler that is in libc doesnt know how to do that and will 
immediately SIGABRT.

> At a minimum this would consist of
> 1) A common PostGIS data set
> 2) The PostGIS GEOS enabled SQL query that causes the behaviour
>      on this data set

select relate('LINESTRING(0 0,0 0)'::geometry,'LINESTRING(0 0,0 
0)'::geometry);

If you can catch this, we should be off to the races.


Any thoughts?

dave




-------------- next part --------------
#include "geom.h"
#include "stdio.h"
#include "GeometryCAPI.h"


//---------------------------------------------------------------------------
// constructors

GeometryCAPI::GeometryCAPI(void)
{
	factory = new GeometryFactory( new PrecisionModel(), -1); // NOTE: SRID will have to be changed after geometry creation
	SRID = -1;
}

GeometryCAPI::GeometryCAPI(PrecisionModel *pm)
{
	factory = new GeometryFactory( pm, -1); // NOTE: SRID will have to be changed after geometry creation
	SRID = -1;
}

GeometryCAPI::GeometryCAPI(PrecisionModel *pm,int srid)
{
	factory = new GeometryFactory( pm, SRID); // NOTE: SRID will have to be changed after geometry creation
	SRID = srid;
}



//---------------------------------------------------------------------------
// geometryFactory functions

	void GeometryCAPI::setSRID(Geometry *g, int srid)
	{
		try{
			g->setSRID(srid);
		}
		catch (...)
		{
			//do nothing
		}	
	}

	Geometry *GeometryCAPI::makeBox(Envelope* envelope)
	{
		try{
			Geometry *result =factory->toGeometry(envelope, factory->getPrecisionModel() , SRID );
			return result;
		}
		catch (...)
		{
			return NULL;
		}
	}

	Geometry *GeometryCAPI::buildGeometry(vector<Geometry *> *subGeos)
	{
		try{
			Geometry *result =factory->buildGeometry(subGeos);
			return result;
		}
		catch (...)
		{
			return NULL;
		}

	}

	Geometry *GeometryCAPI::createPoint(Coordinate *c)
	{
		try{
			Geometry *result =factory->createPoint(*c);
			return result;
		}
		catch (...)
		{
			return NULL;
		}
	}

	Geometry *GeometryCAPI::createMultiPolygon(vector<Geometry *> *polys)
	{
		try{
			Geometry *result =factory->createMultiPolygon(polys);
			return result;
		}
		catch (...)
		{
			return NULL;
		}
	}

	Geometry *GeometryCAPI::createMultiLineString(vector<Geometry *> *lines)
	{
		try{
			Geometry *result =factory->createMultiLineString(lines);
			return result;
		}
		catch (...)
		{
			return NULL;
		}

	}

	Geometry *GeometryCAPI::createMultiPoint(vector<Geometry *> *points)
	{
		try{
			Geometry *result =factory->createMultiPoint(points);
			return result;
		}
		catch (...)
		{
			return NULL;
		}
	}

	Geometry *GeometryCAPI::createLinearRing(BasicCoordinateList *pts)
	{
		try{
			Geometry *result =factory->createLinearRing(pts);
			return result;
		}
		catch (...)
		{
			return NULL;
		}
	}

	Geometry *GeometryCAPI::createPolygon(LinearRing *outer, vector<Geometry *> *innerRings)
	{
		try{
			Geometry *result =factory->createPolygon(outer,innerRings);
			return result;
		}
		catch (...)
		{
			return NULL;
		}
	}

	Geometry *GeometryCAPI::createLineString(BasicCoordinateList *pts)
	{
		try{
			Geometry *result =factory->createLineString(pts);
			return result;
		}
		catch (...)
		{
			return NULL;
		}
	}

//---------------------------------------------------------------------------
// relate-type functions
//-----------------------------------------------------------
// relate()-related functions
//  return 0 = false, 1 = true, 2 = error occured
//-----------------------------------------------------------

char GeometryCAPI::disjoint(Geometry *g1, Geometry*g2)
{
	try {
		bool result;
		result = g1->disjoint(g2);
		if (result)
			return 1;
		else 
			return 0;
	}
	catch (...)
	{
		return 2;
	}
}

char GeometryCAPI::touches(Geometry *g1, Geometry*g2)
{
	try {
		bool result;
		result =  g1->touches(g2);
		if (result)
			return 1;
		else 
			return 0;
	}
	catch (...)
	{
		return 2;
	}
}

char GeometryCAPI::intersects(Geometry *g1, Geometry*g2)
{
	try {
		bool result;
		result = g1->intersects(g2);
		if (result)
			return 1;
		else 
			return 0;
	}
	catch (...)
	{
		return 2;
	}
}

char GeometryCAPI::crosses(Geometry *g1, Geometry*g2)
{
	try {
		bool result;
		result = g1->crosses(g2);
		if (result)
			return 1;
		else 
			return 0;
	}
	catch (...)
	{
		return 2;
	}
}

char GeometryCAPI::within(Geometry *g1, Geometry*g2)
{
	try {
		bool result;
		result = g1->within(g2);
		if (result)
			return 1;
		else 
			return 0;
	}
	catch (...)
	{
		return 2;
	}
}

// call g1->contains(g2) 
// returns 0 = false
//         1 = true
//         2 = error was trapped
char GeometryCAPI::contains(Geometry *g1, Geometry*g2)
{
	try {
		bool result;
		result = g1->contains(g2);
		if (result)
			return 1;
		else 
			return 0;
	}
	catch (...)
	{
		return 2;
	}
}

char GeometryCAPI::overlaps(Geometry *g1, Geometry*g2)
{
	try {
		bool result;
		result = g1->overlaps(g2);
		if (result)
			return 1;
		else 
			return 0;
	}
	catch (...)
	{
		return 2;
	}
}


//-------------------------------------------------------------------
// low-level relate functions
//------------------------------------------------------------------

char GeometryCAPI::relatePattern(Geometry *g1, Geometry*g2,char *pat)
{
	try {
		bool result;
		string s = pat;
		result = g1->relate(g2,pat);
		if (result)
				return 1;
		else 
				return 0;
	}
	catch (...)
	{
		return 2;
	}
}


//callers responsiblity to free the char* this returns
char *GeometryCAPI::relate(Geometry *g1, Geometry*g2)
{
	try {
cout << "In GeometryCAPI::relate and about to g1->relate(g2) " << endl;

		IntersectionMatrix *im = g1->relate(g2);
cout << "past relate" << endl;

		string s;
		char *result;
		if (im == NULL)
				return NULL;

		s= im->toString();
		result = (char*) malloc( s.length() + 1);
		strcpy(result, s.c_str() );
		return result;
	}
	catch (...)
	{

cout << "caught error in GeometryCAPI::relate" << endl;
		return NULL;
	}
}



//-----------------------------------------------------------------
// isValid
//-----------------------------------------------------------------


char GeometryCAPI::isValid(Geometry *g1)
{
	try {
		bool result;
		result =g1->isValid();
		if (result)
			return 1;
		else 
			return 0;
	}
	catch (...)
	{
		return 2;
	}

}


//-----------------------------------------------------------------
// general purpose
//-----------------------------------------------------------------


//callers responsibility to free the char* result.
char *GeometryCAPI::asText(Geometry *g1)
{
	try
	{
		string s = g1->toString();


		char *result;
		result = (char*) malloc( s.length() + 1);
		strcpy(result, s.c_str() );
		return result;
	}
	catch (...)
	{
		return NULL;
	}
}

//-------------------------------------------------------------------
// memory management functions
//------------------------------------------------------------------


//BUG:: this leaks memory, but delete kills the PrecisionModel for ALL the geometries
void GeometryCAPI::deleteGeometry(Geometry *a)
{
	try{
//	delete a;
	}
	catch(...)
	{
		// do nothing!
	}
}

void GeometryCAPI::deleteChar(char *a)
{
	try{
		free(a);
	}
	catch(...)
	{
		// do nothing!
	}

}

-------------- next part --------------


// This is just a simple wrapper for basic geometry functions.  See the 
// Geometry type documentation for exact definition for these functions.
//
//
// Because some C programs might have trouble calling C++ (most notably
// postgresql, PERL, PYTHON, JAVA, etc...) when there is triple indirect
// access  (postgresql -> libpostgis -> libgeos).
// A more technical discussion of this bug is at http://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=37933 
//  Basically, if libc is loaded before libc++ exception handling might be comprimised.
//  
// This class solves this problem.  It basically wraps try..catch blocks around the obvious
// calls to GEOS functions.
//
// For functions that return a boolean (ie. g->isValid() or g1->disjoint(g2)), these functions
// return:
//     0  -- FALSE
//     1  -- TRUE
//     2  -- ERROR OCCURRED  * usually due to invalid geometry or robustness failure
//
//
//  For functions that return objects (ie. g->asText(), g1->relate(g2)), these functions
//  return either the appropriate object or NULL if an error occurred.
//
//
// Usage:
//  if you want to do 
//     g1->relate(g2);
//
//  then you do:
//		GeometryCAPI *capi = new GeometryCAPI();
//		char result        =  capi->relate(g1,g2);
//      if (result ==2)
//		{
//			//handle error
//		}
//
//
//  GeometryCAPI also handles geometry construction.  When you create a GeometryCAPI,
//  you also make a new GeometryFactory (see GeometryCAPI constructors vis-a-vis GeometryFactory).


class GeometryCAPI
{
public:
			//relate() related functions  - 0=false, 1=true, 2=error
	char disjoint(Geometry *g1, Geometry*g2);
	char touches(Geometry *g1, Geometry*g2);
	char intersects(Geometry *g1, Geometry*g2);
	char crosses(Geometry *g1, Geometry*g2);
	char within(Geometry *g1, Geometry*g2);
	char contains(Geometry *g1, Geometry*g2);
	char overlaps(Geometry *g1, Geometry*g2);
	char relatePattern(Geometry *g1, Geometry*g2,char *pat);

	char isValid(Geometry *g1);


	char *asText(Geometry *g1);


	char *relate(Geometry *g1, Geometry*g2);

		//memory management  ERROR = no action
	void deleteGeometry(Geometry *a);
	void deleteChar(char *a);

		//constructors
	GeometryCAPI();                    //make GeometryFactory( new PrecisionModel(), -1)
	GeometryCAPI(PrecisionModel*);     //make GeometryFactory(<PrecisionModel>, -1)
	GeometryCAPI(PrecisionModel*,int); //make GeometryFactory(<PrecisionModel>, #)


		// geometryFactory-type methods (c.f. GeometryFactory for what these functions do)
		// returns NULL = ERROR occured

	Geometry *makeBox(Envelope*);  // make a polygon representing the envelope
	Geometry *buildGeometry(vector<Geometry *>*); // make a geometrycollection (or multi*)
	Geometry *createPoint(Coordinate *);
	Geometry *createMultiPolygon(vector<Geometry *>*);
	Geometry *createMultiLineString(vector<Geometry *>*);
	Geometry *createMultiPoint(vector<Geometry *>*);
	Geometry *createLinearRing(BasicCoordinateList*);
	Geometry *createPolygon(LinearRing*, vector<Geometry *>*);
	Geometry *createLineString(BasicCoordinateList*);


	void setSRID(Geometry *g1, int SRID); // ERROR = no action

	

private:
	GeometryFactory *factory;
	int   SRID;
};
-------------- next part --------------
//  g++ postgis_GEOSwrapper.cpp -c -I/usr/local/include  -I/usr/local/include/geos -I/usr/local/src/postgresql-7.2.3//src/include


#include <stdio.h>

#include <string>
#include <iostream>
#include <fstream>

//#include "geom.h"
//#include "util.h"
//#include "graph.h"
#include "io.h"
#include "GeometryCAPI.h"
//#include "opRelate.h"



//WARNING THIS *MUST* BE SET CORRECTLY.
int MAXIMUM_ALIGNOF = -999999;    // to be set during initialization - this will be either 4 (intel) or 8 (sparc)

//for getting things to align properly  double are on 8byte align on solaris machines, and 4bytes on intel

#define TYPEALIGN(ALIGNVAL,LEN) (((long)(LEN) + (ALIGNVAL-1)) & ~(ALIGNVAL-1))
#define MAXALIGN(LEN)           TYPEALIGN(MAXIMUM_ALIGNOF, (LEN))

typedef  int int32;

typedef struct
{
	double		x,y,z;  //for lat/long   x=long, y=lat
} POINT3D;

typedef struct
{
	POINT3D		LLB,URT; /* corner POINT3Ds on long diagonal */
} BOX3D;

typedef struct
{
	int32 	npoints; // how many points in the line
	int32 	junk;	   // double-word alignment
	POINT3D  	points[1]; // array of actual points
} LINE3D;


typedef struct
{
	int32 	nrings;	 // how many rings in this polygon
	int32		npoints[1]; //how many points in each ring
	/* could be 4 byes of filler here to make sure points[] is
         double-word aligned*/
	POINT3D  	points[1]; // array of actual points
} POLYGON3D;



//###########################################################

extern "C" char *GEOSrelate(Geometry *g1, Geometry*g2);
extern "C" void initGEOS(int maxalign);


extern "C" void GEOSdeleteChar(char *a);
extern "C" void GEOSdeleteGeometry(Geometry *a);
extern "C" char GEOSrelatePattern(Geometry *g1, Geometry*g2,char *pat);
extern "C" char GEOSrelateDisjoint(Geometry *g1, Geometry*g2);
extern "C" char GEOSrelateTouches(Geometry *g1, Geometry*g2);
extern "C" char GEOSrelateIntersects(Geometry *g1, Geometry*g2);
extern "C" char GEOSrelateCrosses(Geometry *g1, Geometry*g2);
extern "C" char GEOSrelateWithin(Geometry *g1, Geometry*g2);
extern "C" char GEOSrelateContains(Geometry *g1, Geometry*g2);
extern "C" char GEOSrelateOverlaps(Geometry *g1, Geometry*g2);


extern "C" Geometry *PostGIS2GEOS_point(POINT3D *point,int SRID, bool is3d);
extern "C" Geometry *PostGIS2GEOS_linestring(LINE3D *line,int SRID, bool is3d);
extern "C" Geometry *PostGIS2GEOS_polygon(POLYGON3D *polygon,int SRID, bool is3d);
extern "C" Geometry *PostGIS2GEOS_multipolygon(POLYGON3D **polygons,int npolys, int SRID, bool is3d);
extern "C" Geometry *PostGIS2GEOS_multilinestring(LINE3D **lines,int nlines, int SRID, bool is3d);
extern "C" Geometry *PostGIS2GEOS_multipoint(POINT3D **points,int npoints, int SRID, bool is3d);

extern "C" Geometry *PostGIS2GEOS_box3d(BOX3D *box, int SRID);
extern "C" Geometry *PostGIS2GEOS_collection(Geometry **geoms, int ngeoms,int SRID, bool is3d);

extern "C" char GEOSisvalid(Geometry *g1);


extern "C" char *GEOSasText(Geometry *g1);

extern "C" char *throw_exception(Geometry *g);


//###########################################################

GeometryCAPI *geometryCAPI = NULL;

void initGEOS (int maxalign)
{
	if (geometryCAPI == NULL)
	{
		geometryCAPI = new GeometryCAPI( new PrecisionModel(), -1); // NOTE: SRID will have to be changed after geometry creation
		MAXIMUM_ALIGNOF = maxalign;
	}
}

// ------------------------------------------------------------------------------
// geometry constuctors - return NULL if there was an error
//-------------------------------------------------------------------------------

		//note: you lose the 3d from this!
Geometry *PostGIS2GEOS_box3d(BOX3D *box, int SRID)
{
	try {
		Geometry *g;
		Envelope *envelope = new Envelope(box->LLB.x,box->URT.x ,box->LLB.y,box->URT.y);
		g = geometryCAPI->makeBox(envelope);
		if (g==NULL)
			return NULL;
		geometryCAPI->setSRID(g,SRID);
		delete envelope;
		return g;
	}
	catch (...)
	{
		return NULL;
	}
}

Geometry *PostGIS2GEOS_collection(Geometry **geoms, int ngeoms,int SRID, bool is3d)
{
	try
	{
		Geometry *g;
		int t;
		vector<Geometry *> *subGeos=new vector<Geometry *>;

		for (t =0; t< ngeoms; t++)
		{
			subGeos->push_back(geoms[t]);	
		}
		g = geometryCAPI->buildGeometry(subGeos);
		if (g==NULL)
			return NULL;
		g->setSRID(SRID);
		return g;
	}
	catch (...)
	{
		return NULL;
	}
}

Geometry *PostGIS2GEOS_point(POINT3D *point,int SRID, bool is3d)
{
	try
	{
			Coordinate *c;

			if (is3d)
				c = new Coordinate(point->x, point->y);	
			else
				c = new Coordinate(point->x, point->y, point->z);
			Geometry *g = geometryCAPI->createPoint(c);
			if (g==NULL)
				return NULL;
			g->setSRID(SRID);
			return g;
		}
	catch (...)
	{
		return NULL;
	}
}


Geometry *PostGIS2GEOS_linestring(LINE3D *line,int SRID, bool is3d)
{
	try{

			int t;
			Coordinate c;

			//build coordinatelist & pre-allocate space
			BasicCoordinateList  *coords = new BasicCoordinateList(line->npoints);
			if (is3d)
			{
				for (t=0;t<line->npoints;t++)
				{
					c.x = line->points[t].x;
					c.y = line->points[t].y;
					c.z = line->points[t].z;
					coords->setAt( c ,t);
				}

			}
			else  //make 2d points
			{
				for (t=0;t<line->npoints;t++)
				{
					c.x = line->points[t].x;
					c.y = line->points[t].y;
					c.z = DoubleNotANumber;
					coords->setAt( c ,t);
				}

			}
			Geometry *g = geometryCAPI->createLineString(coords);
			if (g==NULL)
				return NULL;
			g->setSRID(SRID);
			return g;
		}
	catch (...)
	{
		return NULL;
	}
}

	//polygons is an array of pointers to polygons
Geometry *PostGIS2GEOS_multipolygon(POLYGON3D **polygons,int npolys, int SRID, bool is3d)
{
	try
	{
			int t;
			vector<Geometry *> *subPolys=new vector<Geometry *>;
			Geometry *g;

			for (t =0; t< npolys; t++)
			{
				subPolys->push_back(PostGIS2GEOS_polygon(polygons[t], SRID,is3d ));	
			}
			g = geometryCAPI->createMultiPolygon(subPolys);
			if (g== NULL)
				return NULL;
			g->setSRID(SRID);
			return g;
		}
	catch (...)
	{
		return NULL;
	}
}

	//lines is an array of pointers to line3d
Geometry *PostGIS2GEOS_multilinestring(LINE3D **lines,int nlines, int SRID, bool is3d)
{
	try
	{
			int t;
			vector<Geometry *> *subLines =new vector<Geometry *>;
			Geometry *g;

			for (t =0; t< nlines; t++)
			{
				subLines->push_back(PostGIS2GEOS_linestring(lines[t], SRID,is3d ));	
			}
			g = geometryCAPI->createMultiLineString(subLines);
			if (g==NULL)
				return NULL;
			g->setSRID(SRID);
			return g;
		}
	catch (...)
	{
		return NULL;
	}
}

Geometry *PostGIS2GEOS_multipoint(POINT3D **points,int npoints, int SRID, bool is3d)
{
	try
	{
			int t;
			vector<Geometry *> *subPoints =new vector<Geometry *>;
			Geometry *g;

			for (t =0; t< npoints; t++)
			{
				subPoints->push_back(PostGIS2GEOS_point(points[t], SRID,is3d ));	
			}
			g = geometryCAPI->createMultiPoint(subPoints);
			if (g==NULL)
				return NULL;
			g->setSRID(SRID);
			return g;
		}
	catch (...)
	{
		return NULL;
	}

}


Geometry *PostGIS2GEOS_polygon(POLYGON3D *polygon,int SRID, bool is3d)
{
	try
	{
		POINT3D *pts;
		Coordinate c;
		int  ring,t;
		Geometry *g;
		LinearRing *outerRing;
		LinearRing *innerRing;
		BasicCoordinateList *cl;
		int pointOffset =0; // first point that we're looking at.  a POLYGON3D has all its points smooshed together
		vector<Geometry *> *innerRings=new vector<Geometry *>;


		pts = (POINT3D *) ( (char *)&(polygon->npoints[polygon->nrings] )  );
		pts = (POINT3D *) MAXALIGN(pts);
	
			// make outerRing
			cl = new BasicCoordinateList(polygon->npoints[0]);
			if (is3d)
			{
				for(t=0;t<polygon->npoints[0];t++)
				{
						c.x = pts[t].x;
						c.y = pts[t].y;
						c.z = pts[t].z;
						cl->setAt( c ,t);
				}
			}
			else
			{
				for(t=0;t<polygon->npoints[0];t++)
				{
						c.x = pts[t].x;
						c.y = pts[t].y;
						c.z = DoubleNotANumber;
						cl->setAt( c ,t);
				}
			}
			outerRing = (LinearRing*) geometryCAPI->createLinearRing(cl);
			if (outerRing == NULL)
				return NULL;
			outerRing->setSRID(SRID);
			pointOffset = polygon->npoints[0];

		for(ring =1; ring< polygon->nrings; ring++)
		{
			cl = new BasicCoordinateList(polygon->npoints[ring]);
			if (is3d)
			{
				for(t=0;t<polygon->npoints[ring];t++)
				{
						c.x = pts[t+pointOffset].x;
						c.y = pts[t+pointOffset].y;
						c.z = pts[t+pointOffset].z;
						cl->setAt( c ,t);
				}
			}
			else
			{
				for(t=0;t<polygon->npoints[ring];t++)
				{
						c.x = pts[t+pointOffset].x;
						c.y = pts[t+pointOffset].y;
						c.z = DoubleNotANumber;
						cl->setAt( c ,t);
				}
			}
			innerRing = (LinearRing *) geometryCAPI->createLinearRing(cl);
			if (innerRing == NULL)
				return NULL;
			innerRing->setSRID(SRID);
			innerRings->push_back(innerRing);
			pointOffset += polygon->npoints[ring];
		}

		g = geometryCAPI->createPolygon(outerRing, innerRings);
		if (g==NULL)
			return NULL;
		g->setSRID(SRID);
		return g;
		}
	catch (...)
	{
		return NULL;
	}
}

//-----------------------------------------------------------
// relate()-related functions
//  return 0 = false, 1 = true, 2 = error occured
//-----------------------------------------------------------

char GEOSrelateDisjoint(Geometry *g1, Geometry*g2)
{
	try {
		bool result;
		result = geometryCAPI->disjoint(g1,g2);
		return result;
	}
	catch (...)
	{
		return 2;
	}
}

char GEOSrelateTouches(Geometry *g1, Geometry*g2)
{
	try {
		bool result;
		result =  geometryCAPI->touches(g1,g2);
		return result;
	}
	catch (...)
	{
		return 2;
	}
}

char GEOSrelateIntersects(Geometry *g1, Geometry*g2)
{
	try {
		bool result;
		result = geometryCAPI->intersects(g1,g2);
		return result;
	}
	catch (...)
	{
		return 2;
	}
}

char GEOSrelateCrosses(Geometry *g1, Geometry*g2)
{
	try {
		bool result;
		result = geometryCAPI->crosses(g1,g2);
		return result;
	}
	catch (...)
	{
		return 2;
	}
}

char GEOSrelateWithin(Geometry *g1, Geometry*g2)
{
	try {
		bool result;
		result = geometryCAPI->within(g1,g2);
		return result;
	}
	catch (...)
	{
		return 2;
	}
}

// call g1->contains(g2) 
// returns 0 = false
//         1 = true
//         2 = error was trapped
char GEOSrelateContains(Geometry *g1, Geometry*g2)
{
	try {
		bool result;
		result = geometryCAPI->contains(g1,g2);
		return result;
	}
	catch (...)
	{
		return 2;
	}
}

char GEOSrelateOverlaps(Geometry *g1, Geometry*g2)
{
	try {
		bool result;
		result = geometryCAPI->overlaps(g1,g2);
		return result;
	}
	catch (...)
	{
		return 2;
	}
}


//-------------------------------------------------------------------
// low-level relate functions
//------------------------------------------------------------------

char GEOSrelatePattern(Geometry *g1, Geometry*g2,char *pat)
{
	try {
		bool result;
		string s = pat;
		result = geometryCAPI->relatePattern(g1,g2,pat);
		return result;
	}
	catch (...)
	{
		return 2;
	}
}

char *GEOSrelate(Geometry *g1, Geometry*g2)
{

	try {

		char *result = geometryCAPI->relate(g1,g2);

		return result;
	}
	catch (...)
	{
		return NULL;
	}
}



//-----------------------------------------------------------------
// isValid
//-----------------------------------------------------------------


char GEOSisvalid(Geometry *g1)
{
	try {
		bool result;
		result =geometryCAPI->isValid(g1);
		return result;
	}
	catch (...)
	{
		return 2;
	}

}


//-----------------------------------------------------------------
// general purpose
//-----------------------------------------------------------------

char *GEOSasText(Geometry *g1)
{
	try
	{
		char * result = geometryCAPI->asText(g1);
		return result;
	}
	catch (...)
	{
		return NULL;
	}
}

//-------------------------------------------------------------------
// memory management functions
//------------------------------------------------------------------


//BUG:: this leaks memory, but delete kills the PrecisionModel for ALL the geometries
void GEOSdeleteGeometry(Geometry *a)
{
	try{
		geometryCAPI->deleteGeometry(a);
	}
	catch(...)
	{
		// do nothing!
	}
}

void GEOSdeleteChar(char *a)
{
	try{
		geometryCAPI->deleteChar(a);
	}
	catch(...)
	{
		// do nothing!
	}

}

-------------- next part --------------


//--------------------------------------------------------------------------
//  
#ifdef USE_GEOS

#include "postgres.h"


#include <math.h>
#include <float.h>
#include <string.h>
#include <stdio.h>
#include <errno.h>

#include "fmgr.h"

#include "postgis.h"
#include "utils/elog.h"

#include "access/gist.h"
#include "access/itup.h"
#include "access/rtree.h"

#include "utils/builtins.h"



typedef  struct Geometry Geometry;


extern const char * createGEOSPoint(POINT3D *pt);
extern void initGEOS(int maxalign);
extern char *GEOSrelate(Geometry *g1, Geometry*g2);
extern char GEOSrelatePattern(Geometry *g1, Geometry*g2,char *pat);
extern  char GEOSrelateDisjoint(Geometry *g1, Geometry*g2);
extern  char GEOSrelateTouches(Geometry *g1, Geometry*g2);
extern  char GEOSrelateIntersects(Geometry *g1, Geometry*g2);
extern  char GEOSrelateCrosses(Geometry *g1, Geometry*g2);
extern  char GEOSrelateWithin(Geometry *g1, Geometry*g2);
extern  char GEOSrelateContains(Geometry *g1, Geometry*g2);
extern  char GEOSrelateOverlaps(Geometry *g1, Geometry*g2);

extern char *GEOSasText(Geometry *g1);


extern void GEOSdeleteChar(char *a);
extern void GEOSdeleteGeometry(Geometry *a);

extern  Geometry *PostGIS2GEOS_point(POINT3D *point,int SRID, bool is3d);
extern  Geometry *PostGIS2GEOS_linestring(LINE3D *line,int SRID, bool is3d);
extern  Geometry *PostGIS2GEOS_polygon(POLYGON3D *polygon,int SRID, bool is3d);
extern  Geometry *PostGIS2GEOS_multipolygon(POLYGON3D **polygons,int npolys, int SRID, bool is3d);
extern Geometry *PostGIS2GEOS_multilinestring(LINE3D **lines,int nlines, int SRID, bool is3d);
extern Geometry *PostGIS2GEOS_multipoint(POINT3D **points,int npoints, int SRID, bool is3d);
extern Geometry *PostGIS2GEOS_box3d(BOX3D *box, int SRID);
extern Geometry *PostGIS2GEOS_collection(Geometry **geoms, int ngeoms,int SRID, bool is3d);

extern char GEOSisvalid(Geometry *g1);



extern char *throw_exception(Geometry *g);



Datum relate_full(PG_FUNCTION_ARGS);
Datum relate_pattern(PG_FUNCTION_ARGS);
Datum disjoint(PG_FUNCTION_ARGS);
Datum touches(PG_FUNCTION_ARGS);
Datum intersects(PG_FUNCTION_ARGS);
Datum crosses(PG_FUNCTION_ARGS);
Datum within(PG_FUNCTION_ARGS);
Datum contains(PG_FUNCTION_ARGS);
Datum overlaps(PG_FUNCTION_ARGS);
Datum isvalid(PG_FUNCTION_ARGS);
 

Geometry *POSTGIS2GEOS(GEOMETRY *g);
void errorIfGeometryCollection(GEOMETRY *g1, GEOMETRY *g2);

// return a GEOS Geometry from a POSTGIS GEOMETRY

 
void errorIfGeometryCollection(GEOMETRY *g1, GEOMETRY *g2)
{
	if (  (g1->type == COLLECTIONTYPE) || (g2->type == COLLECTIONTYPE) )
		elog(ERROR,"Relate Operation called with a GEOMETRYCOLLECTION type.  This is unsupported");
}

PG_FUNCTION_INFO_V1(isvalid);
Datum isvalid(PG_FUNCTION_ARGS) 
{
		GEOMETRY		*geom1 = (GEOMETRY *)  PG_DETOAST_DATUM(PG_GETARG_DATUM(0));
		bool result;
		Geometry *g1;

		initGEOS(MAXIMUM_ALIGNOF);

		g1 = 	POSTGIS2GEOS(geom1 );

		result = GEOSisvalid(g1);
		GEOSdeleteGeometry(g1);
	if (result == 2)
	{
		elog(ERROR,"GEOS isvalid() threw an error!");
		PG_RETURN_NULL(); //never get here
	}


	PG_RETURN_BOOL(result);
}


// overlaps(GEOMETRY g1,GEOMETRY g2)
// returns  if GEOS::g1->overlaps(g2) returns true
// throws an error (elog(ERROR,...)) if GEOS throws an error
PG_FUNCTION_INFO_V1(overlaps);
Datum overlaps(PG_FUNCTION_ARGS)
{
	GEOMETRY		*geom1 = (GEOMETRY *)  PG_DETOAST_DATUM(PG_GETARG_DATUM(0));
	GEOMETRY		*geom2 = (GEOMETRY *)  PG_DETOAST_DATUM(PG_GETARG_DATUM(1));


	Geometry *g1,*g2;
	bool result;

	errorIfGeometryCollection(geom1,geom2);
	initGEOS(MAXIMUM_ALIGNOF);

	g1 = 	POSTGIS2GEOS(geom1 );
	g2 = 	POSTGIS2GEOS(geom2 );

	GEOSdeleteGeometry(g1);
	GEOSdeleteGeometry(g2);

	result = GEOSrelateOverlaps(g1,g2);
	if (result == 2)
	{
		elog(ERROR,"GEOS overlaps() threw an error!");
		PG_RETURN_NULL(); //never get here
	}

	PG_RETURN_BOOL(result);
}



PG_FUNCTION_INFO_V1(contains);
Datum contains(PG_FUNCTION_ARGS)
{
	GEOMETRY		*geom1 = (GEOMETRY *)  PG_DETOAST_DATUM(PG_GETARG_DATUM(0));
	GEOMETRY		*geom2 = (GEOMETRY *)  PG_DETOAST_DATUM(PG_GETARG_DATUM(1));


	Geometry *g1,*g2;
	bool result;

	errorIfGeometryCollection(geom1,geom2);
	initGEOS(MAXIMUM_ALIGNOF);

	g1 = 	POSTGIS2GEOS(geom1 );
	g2 = 	POSTGIS2GEOS(geom2 );

	GEOSdeleteGeometry(g1);
	GEOSdeleteGeometry(g2);

	result = GEOSrelateContains(g1,g2);
	if (result == 2)
	{
		elog(ERROR,"GEOS contains() threw an error!");
		PG_RETURN_NULL(); //never get here
	}



	PG_RETURN_BOOL(result);
}


PG_FUNCTION_INFO_V1(within);
Datum within(PG_FUNCTION_ARGS)
{
	GEOMETRY		*geom1 = (GEOMETRY *)  PG_DETOAST_DATUM(PG_GETARG_DATUM(0));
	GEOMETRY		*geom2 = (GEOMETRY *)  PG_DETOAST_DATUM(PG_GETARG_DATUM(1));


	Geometry *g1,*g2;
	bool result;

	errorIfGeometryCollection(geom1,geom2);
	initGEOS(MAXIMUM_ALIGNOF);

	g1 = 	POSTGIS2GEOS(geom1 );
	g2 = 	POSTGIS2GEOS(geom2 );

	GEOSdeleteGeometry(g1);
	GEOSdeleteGeometry(g2);
	result = GEOSrelateWithin(g1,g2);
	if (result == 2)
	{
		elog(ERROR,"GEOS within() threw an error!");
		PG_RETURN_NULL(); //never get here
	}



	PG_RETURN_BOOL(result);
}



PG_FUNCTION_INFO_V1(crosses);
Datum crosses(PG_FUNCTION_ARGS)
{
	GEOMETRY		*geom1 = (GEOMETRY *)  PG_DETOAST_DATUM(PG_GETARG_DATUM(0));
	GEOMETRY		*geom2 = (GEOMETRY *)  PG_DETOAST_DATUM(PG_GETARG_DATUM(1));


	Geometry *g1,*g2;
	bool result;

	errorIfGeometryCollection(geom1,geom2);
	initGEOS(MAXIMUM_ALIGNOF);

	g1 = 	POSTGIS2GEOS(geom1 );
	g2 = 	POSTGIS2GEOS(geom2 );

	GEOSdeleteGeometry(g1);
	GEOSdeleteGeometry(g2);

	result = GEOSrelateCrosses(g1,g2);
	if (result == 2)
	{
		elog(ERROR,"GEOS crosses() threw an error!");
		PG_RETURN_NULL(); //never get here
	}



	PG_RETURN_BOOL(result);
}



PG_FUNCTION_INFO_V1(intersects);
Datum intersects(PG_FUNCTION_ARGS)
{
	GEOMETRY		*geom1 = (GEOMETRY *)  PG_DETOAST_DATUM(PG_GETARG_DATUM(0));
	GEOMETRY		*geom2 = (GEOMETRY *)  PG_DETOAST_DATUM(PG_GETARG_DATUM(1));


	Geometry *g1,*g2;
	bool result;

	errorIfGeometryCollection(geom1,geom2);
	initGEOS(MAXIMUM_ALIGNOF);

	g1 = 	POSTGIS2GEOS(geom1 );
	g2 = 	POSTGIS2GEOS(geom2 );

	GEOSdeleteGeometry(g1);
	GEOSdeleteGeometry(g2);

	result = GEOSrelateIntersects(g1,g2);
	if (result == 2)
	{
		elog(ERROR,"GEOS intersects() threw an error!");
		PG_RETURN_NULL(); //never get here
	}



	PG_RETURN_BOOL(result);
}


PG_FUNCTION_INFO_V1(touches);
Datum touches(PG_FUNCTION_ARGS)
{
	GEOMETRY		*geom1 = (GEOMETRY *)  PG_DETOAST_DATUM(PG_GETARG_DATUM(0));
	GEOMETRY		*geom2 = (GEOMETRY *)  PG_DETOAST_DATUM(PG_GETARG_DATUM(1));


	Geometry *g1,*g2;
	bool result;

	errorIfGeometryCollection(geom1,geom2);
	initGEOS(MAXIMUM_ALIGNOF);

	g1 = 	POSTGIS2GEOS(geom1 );
	g2 = 	POSTGIS2GEOS(geom2 );

	GEOSdeleteGeometry(g1);
	GEOSdeleteGeometry(g2);

	result = GEOSrelateTouches(g1,g2);
	if (result == 2)
	{
		elog(ERROR,"GEOS touches() threw an error!");
		PG_RETURN_NULL(); //never get here
	}



	PG_RETURN_BOOL(result);
}


PG_FUNCTION_INFO_V1(disjoint);
Datum disjoint(PG_FUNCTION_ARGS)
{
	GEOMETRY		*geom1 = (GEOMETRY *)  PG_DETOAST_DATUM(PG_GETARG_DATUM(0));
	GEOMETRY		*geom2 = (GEOMETRY *)  PG_DETOAST_DATUM(PG_GETARG_DATUM(1));


	Geometry *g1,*g2;
	bool result;

	errorIfGeometryCollection(geom1,geom2);
	initGEOS(MAXIMUM_ALIGNOF);

	g1 = 	POSTGIS2GEOS(geom1 );
	g2 = 	POSTGIS2GEOS(geom2 );


	result = GEOSrelateDisjoint(g1,g2);
	GEOSdeleteGeometry(g1);
	GEOSdeleteGeometry(g2);

	if (result == 2)
	{
		elog(ERROR,"GEOS disjoin() threw an error!");
		PG_RETURN_NULL(); //never get here
	}

	PG_RETURN_BOOL(result);
}


PG_FUNCTION_INFO_V1(relate_pattern);
Datum relate_pattern(PG_FUNCTION_ARGS)
{
	GEOMETRY		*geom1 = (GEOMETRY *)  PG_DETOAST_DATUM(PG_GETARG_DATUM(0));
	GEOMETRY		*geom2 = (GEOMETRY *)  PG_DETOAST_DATUM(PG_GETARG_DATUM(1));
	char *patt;
	bool result;

	Geometry *g1,*g2;


	errorIfGeometryCollection(geom1,geom2);
	initGEOS(MAXIMUM_ALIGNOF);

	g1 = 	POSTGIS2GEOS(geom1 );
	g2 = 	POSTGIS2GEOS(geom2 );


	patt =  DatumGetCString(DirectFunctionCall1(textout,
                        PointerGetDatum(PG_GETARG_DATUM(2))));

	result = GEOSrelatePattern(g1,g2,patt);
	GEOSdeleteGeometry(g1);
	GEOSdeleteGeometry(g2);
	pfree(patt);

	if (result == 2)
	{
		elog(ERROR,"GEOS relate_pattern() threw an error!");
		PG_RETURN_NULL(); //never get here
	}

	PG_RETURN_BOOL(result);


}



PG_FUNCTION_INFO_V1(relate_full);
Datum relate_full(PG_FUNCTION_ARGS)
{
	GEOMETRY		*geom1 = (GEOMETRY *)  PG_DETOAST_DATUM(PG_GETARG_DATUM(0));
	GEOMETRY		*geom2 = (GEOMETRY *)  PG_DETOAST_DATUM(PG_GETARG_DATUM(1));

	Geometry *g1,*g2;
	char	*relate_str;
	int len;
	char *result;

elog(NOTICE,"in relate_full()");

	errorIfGeometryCollection(geom1,geom2);


	initGEOS(MAXIMUM_ALIGNOF);

elog(NOTICE,"GEOS init()");

	g1 = 	POSTGIS2GEOS(geom1 );
	g2 = 	POSTGIS2GEOS(geom2 );

elog(NOTICE,"constructed geometries ");





if ((g1==NULL) || (g2 == NULL))
	elog(NOTICE,"g1 or g2 are null");

elog(NOTICE,GEOSasText(g1));
elog(NOTICE,GEOSasText(g2));

elog(NOTICE,"valid g1 = %i", GEOSisvalid(g1));
elog(NOTICE,"valid g2 = %i",GEOSisvalid(g2));

elog(NOTICE,"about to relate()");


		relate_str = GEOSrelate(g1, g2);

elog(NOTICE,"finished relate()");

	GEOSdeleteGeometry(g1);
	GEOSdeleteGeometry(g2);



	if (relate_str == NULL)
	{
		//free(relate_str);
		elog(ERROR,"GEOS relate() threw an error!");
		PG_RETURN_NULL(); //never get here
	}


	len = strlen(relate_str) + 4;

	result= palloc(len);
	*((int *) result) = len;

	memcpy(result +4, relate_str, len-4);

	free(relate_str);


	PG_RETURN_POINTER(result);
}


//BBOXONLYTYPE -> returns as a 2d polygon
Geometry *POSTGIS2GEOS(GEOMETRY *g)
{
	POINT3D *pt;
	LINE3D *line;
	POLYGON3D *poly;
	POLYGON3D **polys;
	LINE3D **lines;
	POINT3D **points;
	Geometry **geoms;
	Geometry *geos;
	char     *obj;
	int      obj_type;
	int t;
	Geometry	*result;

	int32 *offsets1 = (int32 *) ( ((char *) &(g->objType[0] ))+ sizeof(int32) * g->nobjs ) ;

	switch(g->type)
	{
		case POINTTYPE:	
							pt = (POINT3D*) ((char *) g +offsets1[0]) ;
							result =  PostGIS2GEOS_point(pt,g->SRID,g->is3d);
							if (result == NULL)
							{
								elog(ERROR,"Couldnt convert the postgis geometry to GEOS!");
							}
							return result;
							break;
		case LINETYPE:		
							line = (LINE3D*) ((char *) g +offsets1[0]) ;
							result =  PostGIS2GEOS_linestring(line,g->SRID,g->is3d);
							if (result == NULL)
							{
								elog(ERROR,"Couldnt convert the postgis geometry to GEOS!");
							}
							return result;
							break;
		case POLYGONTYPE:   
							poly = (POLYGON3D*) ((char *) g +offsets1[0]) ;
							result =  PostGIS2GEOS_polygon(poly,g->SRID,g->is3d);
							if (result == NULL)
							{
								elog(ERROR,"Couldnt convert the postgis geometry to GEOS!");
							}
							return result;
							break;
		case MULTIPOLYGONTYPE:
									//make an array of POLYGON3Ds
							polys = (POLYGON3D**) palloc(sizeof (POLYGON3D*) * g->nobjs);
							for (t=0;t<g->nobjs;t++)
							{
								polys[t] = 	(POLYGON3D*) ((char *) g +offsets1[t]) ;
							}
							geos= PostGIS2GEOS_multipolygon(polys, g->nobjs, g->SRID,g->is3d);
							pfree(polys);
							if (geos == NULL)
							{
								elog(ERROR,"Couldnt convert the postgis geometry to GEOS!");
							}
							return geos;
							break;
		case MULTILINETYPE:
								//make an array of POLYGON3Ds
							lines = (LINE3D**) palloc(sizeof (LINE3D*) * g->nobjs);
							for (t=0;t<g->nobjs;t++)
							{
								lines[t] = 	(LINE3D*) ((char *) g +offsets1[t]) ;
							}
							geos= PostGIS2GEOS_multilinestring(lines, g->nobjs, g->SRID,g->is3d);
							pfree(lines);
							if (geos == NULL)
							{
								elog(ERROR,"Couldnt convert the postgis geometry to GEOS!");
							}
							return geos;
							break;
		case MULTIPOINTTYPE:
								//make an array of POINT3Ds
							points = (POINT3D**) palloc(sizeof (POINT3D*) * g->nobjs);
							for (t=0;t<g->nobjs;t++)
							{
								points[t] = 	(POINT3D*) ((char *) g +offsets1[t]) ;
							}
							geos= PostGIS2GEOS_multipoint(points, g->nobjs,g->SRID,g->is3d);
							pfree(points);
							if (geos == NULL)
							{
								elog(ERROR,"Couldnt convert the postgis geometry to GEOS!");
							}
							return geos;
							break;
		case BBOXONLYTYPE:
							result =   PostGIS2GEOS_box3d(&g->bvol, g->SRID);
							if (result == NULL)
							{
								elog(ERROR,"Couldnt convert the postgis geometry to GEOS!");
							}
							return result;
							break;
		case COLLECTIONTYPE:
								//make an array of GEOS Geometrys
							geoms = (Geometry**) palloc(sizeof (Geometry*) * g->nobjs);
							for (t=0;t<g->nobjs;t++)
							{
								obj = ((char *) g +offsets1[t]);
								obj_type =  g->objType[t];
								switch (obj_type)
								{
									case POINTTYPE:
													pt = (POINT3D*) obj ;
													geoms[t] = PostGIS2GEOS_point(pt,g->SRID,g->is3d);
													if (geoms[t] == NULL)
													{
														pfree(geoms);
														elog(ERROR,"Couldnt convert the postgis geometry to GEOS!");
														return NULL;
													}
													break;
									case LINETYPE:
													line = (LINE3D*) obj ;
													geoms[t] = PostGIS2GEOS_linestring(line,g->SRID,g->is3d);
													if (geoms[t] == NULL)
													{
														pfree(geoms);
														elog(ERROR,"Couldnt convert the postgis geometry to GEOS!");
														return NULL;
													}
													break;
									case POLYGONTYPE:
													poly = (POLYGON3D*) obj ;
													geoms[t] = PostGIS2GEOS_polygon(poly,g->SRID,g->is3d);
													if (geoms[t] == NULL)
													{
														pfree(geoms);
														elog(ERROR,"Couldnt convert the postgis geometry to GEOS!");
														return NULL;
													}
													break;
								}
							}
							geos= PostGIS2GEOS_collection(geoms,g->nobjs,g->SRID,g->is3d);
							pfree(geoms);
							if (geos == NULL)
							{
								elog(ERROR,"Couldnt convert the postgis geometry to GEOS!");
							}
							return geos; 
							break;

	}
	return NULL;
}




//----------------------------------------------------------------------------
// NULL implementation here
// ---------------------------------------------------------------------------
#else


#include "postgres.h"


#include <math.h>
#include <float.h>
#include <string.h>
#include <stdio.h>
#include <errno.h>

#include "fmgr.h"


Datum relate_full(PG_FUNCTION_ARGS);
Datum relate_pattern(PG_FUNCTION_ARGS);
Datum disjoint(PG_FUNCTION_ARGS);
Datum touches(PG_FUNCTION_ARGS);
Datum intersects(PG_FUNCTION_ARGS);
Datum crosses(PG_FUNCTION_ARGS);
Datum within(PG_FUNCTION_ARGS);
Datum contains(PG_FUNCTION_ARGS);
Datum overlaps(PG_FUNCTION_ARGS);
Datum isvalid(PG_FUNCTION_ARGS);

PG_FUNCTION_INFO_V1(relate_full);
Datum relate_full(PG_FUNCTION_ARGS)
{
	elog(ERROR,"relate_full:: operation not implemented - compile PostGIS with GEOS support");
	PG_RETURN_NULL(); // never get here
}
PG_FUNCTION_INFO_V1(relate_pattern);
Datum relate_pattern(PG_FUNCTION_ARGS)
{
	elog(ERROR,"relate_pattern:: operation not implemented - compile PostGIS with GEOS support");
	PG_RETURN_NULL(); // never get here
}
PG_FUNCTION_INFO_V1(disjoint);
Datum disjoint(PG_FUNCTION_ARGS)
{
	elog(ERROR,"disjoint:: operation not implemented - compile PostGIS with GEOS support");
	PG_RETURN_NULL(); // never get here
}
PG_FUNCTION_INFO_V1(intersects);
Datum intersects(PG_FUNCTION_ARGS)
{
	elog(ERROR,"intersects:: operation not implemented - compile PostGIS with GEOS support");
	PG_RETURN_NULL(); // never get here
}
PG_FUNCTION_INFO_V1(touches);
Datum touches(PG_FUNCTION_ARGS)
{
	elog(ERROR,"touches:: operation not implemented - compile PostGIS with GEOS support");
	PG_RETURN_NULL(); // never get here
}
PG_FUNCTION_INFO_V1(crosses);
Datum crosses(PG_FUNCTION_ARGS)
{
	elog(ERROR,"crosses:: operation not implemented - compile PostGIS with GEOS support");
	PG_RETURN_NULL(); // never get here
}
PG_FUNCTION_INFO_V1(within);
Datum within(PG_FUNCTION_ARGS)
{
	elog(ERROR,"within:: operation not implemented - compile PostGIS with GEOS support");
	PG_RETURN_NULL(); // never get here
}
PG_FUNCTION_INFO_V1(contains);
Datum contains(PG_FUNCTION_ARGS)
{
	elog(ERROR,"contains:: operation not implemented - compile PostGIS with GEOS support");
	PG_RETURN_NULL(); // never get here
}
PG_FUNCTION_INFO_V1(overlaps);
Datum overlaps(PG_FUNCTION_ARGS)
{
	elog(ERROR,"overlaps:: operation not implemented - compile PostGIS with GEOS support");
	PG_RETURN_NULL(); // never get here
}
PG_FUNCTION_INFO_V1(isvalid);
Datum isvalid(PG_FUNCTION_ARGS)
{
	elog(ERROR,"isvalid:: operation not implemented - compile PostGIS with GEOS support");
	PG_RETURN_NULL(); // never get here
}

#endif

From dblasby at refractions.net  Tue May 27 17:31:42 2003
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Exception Issues
In-Reply-To: <3ED3CA2C.8030109@refractions.net>
References: <EKEJIKAILPONGGENMBGACEMGDIAA.nhv@cape.com>
	<3ED3CA2C.8030109@refractions.net>
Message-ID: <3ED3D93E.8030809@refractions.net>

> What we havent tried:
> 
> 1. linking postgresql to libc++.  This should work, but we dont want to have a special 'postgis' version of postgresql hanging around. 

I did this - works like a charm (I think).

Compile postgresql with something like:

LDFLAGS=-lstdc++ ./configure --prefix=/opt/pgsql73 --with-debug
make clean;make; make install



dblasby=# select relate('LINESTRING(0 0,0 0)'::geometry, 'LINESTRING(0 
0,0 0)'::geometry );
NOTICE:  in relate_full()
NOTICE:  GEOS init()
NOTICE:  constructed geometries
NOTICE:  LINESTRING (0.0000000000000000 0.0000000000000000, 
0.0000000000000000 0.0000000000000000)
NOTICE:  LINESTRING (0.0000000000000000 0.0000000000000000, 
0.0000000000000000 0.0000000000000000)
NOTICE:  valid g1 = 0
NOTICE:  valid g2 = 0
NOTICE:  about to relate()
NOTICE:  finished relate()
ERROR:  GEOS relate() threw an error!


and the server output:

[postgres@hydra init.d]$ /opt/pgsql73/bin/postmaster -i -D 
/raid/pgdata/pgsql_devel_73
LOG:  database system was shut down at 2003-05-27 14:24:27 PDT
LOG:  checkpoint record is at 0/E955DA8
LOG:  redo record is at 0/E955DA8; undo record is at 0/0; shutdown TRUE
LOG:  next transaction id: 6708; next oid: 577113
LOG:  database system is ready
FATAL:  Database "geos" does not exist in the system catalog.
NOTICE:  in relate_full()
NOTICE:  GEOS init()
NOTICE:  constructed geometries
NOTICE:  LINESTRING (0.0000000000000000 0.0000000000000000, 
0.0000000000000000 0.0000000000000000)
NOTICE:  LINESTRING (0.0000000000000000 0.0000000000000000, 
0.0000000000000000 0.0000000000000000)
NOTICE:  valid g1 = 0
NOTICE:  valid g2 = 0
NOTICE:  about to relate()
In GeometryCAPI::relate and about to g1->relate(g2)
caught error in GeometryCAPI::relate
NOTICE:  finished relate()
ERROR:  GEOS relate() threw an error!



dave


From nhv at cape.com  Tue May 27 17:58:11 2003
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Exception Issues
In-Reply-To: <3ED3D93E.8030809@refractions.net>
Message-ID: <EKEJIKAILPONGGENMBGAKENDDIAA.nhv@cape.com>

David Blasby writes:
> 
> > What we havent tried:
> > 
> > 1. linking postgresql to libc++.  This should work, but we dont 
> want to have a special 'postgis' version of postgresql hanging around. 
> 
> I did this - works like a charm (I think).

good show :-))))

Questions:

1) What version of gcc are you using

2) What happens if you link PostgreSQL against -lsupc++
    instead of -lstdc++

Norman



From dblasby at refractions.net  Tue May 27 18:01:44 2003
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Exception Issues
In-Reply-To: <EKEJIKAILPONGGENMBGAKENDDIAA.nhv@cape.com>
References: <EKEJIKAILPONGGENMBGAKENDDIAA.nhv@cape.com>
Message-ID: <3ED3E048.2040903@refractions.net>

> Questions:
> 
> 1) What version of gcc are you using

2.96


> 2) What happens if you link PostgreSQL against -lsupc++
>     instead of -lstdc++

I dont think we have that library.  What is it?

dave


From nhv at cape.com  Tue May 27 18:21:12 2003
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Exception Issues
In-Reply-To: <3ED3E048.2040903@refractions.net>
Message-ID: <EKEJIKAILPONGGENMBGAKENEDIAA.nhv@cape.com>

David Blasby writes:
> 
> > Questions:
> > 
> > 1) What version of gcc are you using
> 
> 2.96

FWIW AFAIK:
2.96 is a Redhat variaty and is not an official release of gcc

also the current 3.2 is I believe *much* more C++ standard compliant

> > 2) What happens if you link PostgreSQL against -lsupc++
> >     instead of -lstdc++
> 
> I dont think we have that library.  What is it?

here is a 'good' explanation
http://gcc.gnu.org/ml/gcc/2000-12/msg00714.html

Note this is part of gcc since 3.0
http://gcc.gnu.org/gcc-3.0/features.html

HTH

Norman




From dblasby at refractions.net  Tue May 27 18:34:47 2003
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] GEOS with PostGIS - how to
Message-ID: <3ED3E807.6010409@refractions.net>

We have gotten GEOS to work (with exceptions) with PostGIS.

The solution is quite simple - you have to link the C++ standard library 
into postgresql.  For a complete technical discussion on this, see the 
previous messages in the GEOS mailing list.

THIS IS EXPERIMENTAL

Linking stdc++ (the c++ standard library) into postgresql is done by 
setting the LDFLAGS environment variable and running configure.

1. move to your postgresql source directory
2. LDFLAGS=-lstdc++ ./configure <whatever options you want to compile 
postgresql with>
3. make clean;make; make install
4. verify that your postmaster has libstdc++:
     [postgres@hydra init.d]$ ldd /opt/pgsql73/bin/postmaster
         libstdc++-libc6.2-2.so.3 => /usr/lib/libstdc++-libc6.2-2.so.3 
(0x40028000)
         libz.so.1 => /lib/libz.so.1 (0x40075000)
         libreadline.so.4.2 => /lib/libreadline.so.4.2 (0x40084000)
         libncurses.so.5 => /lib/libncurses.so.5 (0x400ae000)
         libcrypt.so.1 => /lib/libcrypt.so.1 (0x400ef000)
         libresolv.so.2 => /lib/libresolv.so.2 (0x4011c000)
         libnsl.so.1 => /lib/libnsl.so.1 (0x4012e000)
         libdl.so.2 => /lib/libdl.so.2 (0x40144000)
         libm.so.6 => /lib/libm.so.6 (0x40147000)
         libc.so.6 => /lib/libc.so.6 (0x40169000)
         libgpm.so.1 => /usr/lib/libgpm.so.1 (0x402a6000)
         /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)


   NOTICE "libstdc++-libc6.2-2.so.3" in the list.

Next you need the most up-to-date postgis.

1. checkout the postgis CVS archive
2. compile and install
3. there are several new GEOS related functions, so I suggest you run 
the postgis.sql install file into a new database.

To test:

dblasby=# select disjoint('LINESTRING(0 0,0 0)'::geometry, 'LINESTRING(0 
0,0 1)'::geometry );
ERROR:  GEOS disjoin() threw an error!


More test are available:

1. cd to the postgis regress directory
2. load the  isvalid test data with something like:
	psql  dblasby < isvalid_test
3. load the relate test data with something like:
	psql  dblasby <  relate_test
4. you should see two new tables in your database 'validtest' and 
'relate_test'.
5. run these tests - you should get the same answers:
dblasby=# select count(*) from relate_test WHERE  relate (g1,g2) <> result;
  count
-------
      0
(1 row)
dblasby=# select count(*) from relate_test WHERE  relate (g1,g2) = result;
  count
-------
    555
(1 row)
dblasby=# select count(*) from validtest WHERE isvalid(g) = result;
  count
-------
    799
(1 row)
dblasby=# select count(*) from validtest WHERE isvalid(g) <> result;
  count
-------
      7
(1 row)


NOTE: the 7 "errors" in the validtest are okay - repeated points in JTS 
1.2 are invalid, but valid in 1.3.  GEOS is currently based on JTS 1.2, 
but the test results are based on JTS 1.3.


Please report to this list that you have successfully installed it and 
it works on your system.


dave
ps. I have not changed how postgis includes the new functions like 
norman suggested in "RE: [geos-devel] Re: [postgis-users] GEOS / 
Predicates Update" to the postgis mailing list.  Thats a todo.



From dblasby at refractions.net  Tue May 27 18:36:58 2003
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] GEOS Todo
In-Reply-To: <3ED3E807.6010409@refractions.net>
References: <3ED3E807.6010409@refractions.net>
Message-ID: <3ED3E88A.9020807@refractions.net>

There are two outstanding issues in GEOS:

1. memory management.  This is high priority.

2. GEOS writes out debugging information like this:

# segment intersection tests: 0
# overlapping MCs: 0

Could this be removed or made optional?

dave


From pramsey at refractions.net  Tue May 27 18:40:34 2003
From: pramsey at refractions.net (Paul Ramsey)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] GEOS with PostGIS - how to
In-Reply-To: <3ED3E807.6010409@refractions.net>
References: <3ED3E807.6010409@refractions.net>
Message-ID: <1054075233.3ed3e96200022@www>

Dave,
For our own PostGIS/GEOS implementation, do we still have an outstanding memory 
management issue? I believe we were not deleting GEOS geometries, and thus 
leaking memory.
Paul

Quoting David Blasby <dblasby@refractions.net>:

> We have gotten GEOS to work (with exceptions) with PostGIS.
> 
> The solution is quite simple - you have to link the C++ standard library
> into postgresql.  For a complete technical discussion on this, see the
> previous messages in the GEOS mailing list.
> 
> THIS IS EXPERIMENTAL
> 
> Linking stdc++ (the c++ standard library) into postgresql is done by
> setting the LDFLAGS environment variable and running configure.
> 
> 1. move to your postgresql source directory
> 2. LDFLAGS=-lstdc++ ./configure <whatever options you want to compile
> postgresql with>
> 3. make clean;make; make install
> 4. verify that your postmaster has libstdc++:
>      [postgres@hydra init.d]$ ldd /opt/pgsql73/bin/postmaster
>          libstdc++-libc6.2-2.so.3 => /usr/lib/libstdc++-libc6.2-2.so.3
> (0x40028000)
>          libz.so.1 => /lib/libz.so.1 (0x40075000)
>          libreadline.so.4.2 => /lib/libreadline.so.4.2 (0x40084000)
>          libncurses.so.5 => /lib/libncurses.so.5 (0x400ae000)
>          libcrypt.so.1 => /lib/libcrypt.so.1 (0x400ef000)
>          libresolv.so.2 => /lib/libresolv.so.2 (0x4011c000)
>          libnsl.so.1 => /lib/libnsl.so.1 (0x4012e000)
>          libdl.so.2 => /lib/libdl.so.2 (0x40144000)
>          libm.so.6 => /lib/libm.so.6 (0x40147000)
>          libc.so.6 => /lib/libc.so.6 (0x40169000)
>          libgpm.so.1 => /usr/lib/libgpm.so.1 (0x402a6000)
>          /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
> 
> 
>    NOTICE "libstdc++-libc6.2-2.so.3" in the list.
> 
> Next you need the most up-to-date postgis.
> 
> 1. checkout the postgis CVS archive
> 2. compile and install
> 3. there are several new GEOS related functions, so I suggest you run
> the postgis.sql install file into a new database.
> 
> To test:
> 
> dblasby=# select disjoint('LINESTRING(0 0,0 0)'::geometry, 'LINESTRING(0
> 0,0 1)'::geometry );
> ERROR:  GEOS disjoin() threw an error!
> 
> 
> More test are available:
> 
> 1. cd to the postgis regress directory
> 2. load the  isvalid test data with something like:
> 	psql  dblasby < isvalid_test
> 3. load the relate test data with something like:
> 	psql  dblasby <  relate_test
> 4. you should see two new tables in your database 'validtest' and
> 'relate_test'.
> 5. run these tests - you should get the same answers:
> dblasby=# select count(*) from relate_test WHERE  relate (g1,g2) <> result;
>   count
> -------
>       0
> (1 row)
> dblasby=# select count(*) from relate_test WHERE  relate (g1,g2) = result;
>   count
> -------
>     555
> (1 row)
> dblasby=# select count(*) from validtest WHERE isvalid(g) = result;
>   count
> -------
>     799
> (1 row)
> dblasby=# select count(*) from validtest WHERE isvalid(g) <> result;
>   count
> -------
>       7
> (1 row)
> 
> 
> NOTE: the 7 "errors" in the validtest are okay - repeated points in JTS
> 1.2 are invalid, but valid in 1.3.  GEOS is currently based on JTS 1.2,
> but the test results are based on JTS 1.3.
> 
> 
> Please report to this list that you have successfully installed it and
> it works on your system.
> 
> 
> dave
> ps. I have not changed how postgis includes the new functions like
> norman suggested in "RE: [geos-devel] Re: [postgis-users] GEOS /
> Predicates Update" to the postgis mailing list.  Thats a todo.
> 
> 
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
> 





From dblasby at refractions.net  Tue May 27 18:43:08 2003
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] GEOS with PostGIS - how to
In-Reply-To: <1054075233.3ed3e96200022@www>
References: <3ED3E807.6010409@refractions.net> <1054075233.3ed3e96200022@www>
Message-ID: <3ED3E9FC.4000904@refractions.net>

Paul Ramsey wrote:
> Dave,
> For our own PostGIS/GEOS implementation, do we still have an outstanding memory 
> management issue? I believe we were not deleting GEOS geometries, and thus 
> leaking memory.

Yes - it still leakes memory like a leaky sieve.  Thats on Yuri's todo list.

dave


From nhv at cape.com  Tue May 27 18:49:16 2003
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] GEOS Todo
In-Reply-To: <3ED3E88A.9020807@refractions.net>
Message-ID: <EKEJIKAILPONGGENMBGAAENGDIAA.nhv@cape.com>

David Blasby writes:
> 
> There are two outstanding issues in GEOS:
> 
> 1. memory management.  This is high priority.

Using the c++ autoptr or a homegrown equivalant
would help *alot* here
 
> 2. GEOS writes out debugging information like this:

3: Moving everything into a GEOS namespace

This is the easiest and *best* method of preventing
namespace clashes which will happen eventually if 
this 'good software practice' isn't followed

The longer this modification is postponed the more difficult 
and disruptive the change will become

Cheers

Norman


From mbdavis at VividSolutions.com  Tue May 27 18:49:23 2003
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] GEOS Todo
Message-ID: <5A94289A9268514C8D6C0F1FF44BA0271DF6DB@venus.VividSolutions.com>

That's great news about getting GEOS to work with PostGIS.  Excellent work, guys!

I agree with the tasks...  I'd say removing the debug information is task 1 (or actually, wrapping it in a #ifdef DEBUG might be better).  Memory management is more critical, but a whole lot more time-consuming.  Note to follow on that...

Martin Davis, Senior Technical Architect
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


> -----Original Message-----
> From: David Blasby [mailto:dblasby@refractions.net]
> Sent: Tuesday, May 27, 2003 3:37 PM
> To: GEOS Development List
> Subject: [geos-devel] GEOS Todo
> 
> 
> There are two outstanding issues in GEOS:
> 
> 1. memory management.  This is high priority.
> 
> 2. GEOS writes out debugging information like this:
> 
> # segment intersection tests: 0
> # overlapping MCs: 0
> 
> Could this be removed or made optional?
> 
> dave
> 
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
> 

From dblasby at refractions.net  Tue May 27 19:02:32 2003
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] GEOS Todo
In-Reply-To: <EKEJIKAILPONGGENMBGAAENGDIAA.nhv@cape.com>
References: <EKEJIKAILPONGGENMBGAAENGDIAA.nhv@cape.com>
Message-ID: <3ED3EE88.60306@refractions.net>

Norman Vine wrote:
> David Blasby writes:
> 
>>There are two outstanding issues in GEOS:
>>
>>1. memory management.  This is high priority.
> 
> 
> Using the c++ autoptr or a homegrown equivalant
> would help *alot* here

This is even more basic - if you delete any one Geometry you will 
usually delete the PrecisionModel of *all* your Geometries.

There was discussion a little while ago about this when we first started 
porting GEOS to PostGIS.

As it stands right now, you cannot delete *any* GEOS geometry or you're 
royally screwed.

For catching the smaller leaks, a few people mentioned a really good 
opensource memory-leak-fixer program.  I cannot remember the name.

dave

ps. cf message with subjects;
"[geos-devel] problems with C/C++- getting warmer! (Reader Frees too 
much?)"
"RE: [geos-devel] Status (New Example)"
"[geos-devel] WKTreader is broken"
"RE: [geos-devel] Deleting PrecisionModels"


From mbdavis at VividSolutions.com  Tue May 27 19:05:32 2003
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] GEOS Task List
Message-ID: <5A94289A9268514C8D6C0F1FF44BA0271DF6DC@venus.VividSolutions.com>

Here's a summary of the tasks for GEOS (once the porting has been completed, which should be RSN).  Some notes for the developer(s) are included.

1. Remove debugging output
- Should just comment out for now

2. Fix problem with deleting Geometries causing deletion of Precision Model
- This will involve keeping the PrecisionModel as a instance variable (value object) within each Geometry, instead of keeping a reference to it.

3. Fix memory leaks.  This includes ensure code will not leak memory when exceptions are thrown.
- This will likely require heavy use of the STL <auto_ptr> construct, as well as MSVC memory-leak detection tools

3. Implement GEOS namespace

If anyone has anything else to add, let me know.

Martin Davis, Senior Technical Architect
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


From pramsey at refractions.net  Tue May 27 19:08:48 2003
From: pramsey at refractions.net (Paul Ramsey)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] GEOS Todo
In-Reply-To: <3ED3EE88.60306@refractions.net>
References: <EKEJIKAILPONGGENMBGAAENGDIAA.nhv@cape.com>
	<3ED3EE88.60306@refractions.net>
Message-ID: <1054076928.3ed3f0009339b@www>

Quoting David Blasby <dblasby@refractions.net>:

> For catching the smaller leaks, a few people mentioned a really good
> opensource memory-leak-fixer program.  I cannot remember the name.
 
valgrind

We should run PostGIS through it before going 0.8 as well.
Paul



From dblasby at refractions.net  Tue May 27 19:14:49 2003
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] GEOS Todo
In-Reply-To: <1054076928.3ed3f0009339b@www>
References: <EKEJIKAILPONGGENMBGAAENGDIAA.nhv@cape.com>
	<3ED3EE88.60306@refractions.net> <1054076928.3ed3f0009339b@www>
Message-ID: <3ED3F169.9040200@refractions.net>

Paul Ramsey wrote:

> We should run PostGIS through it before going 0.8 as well.

This could be difficult because postgis uses the postgresql memory 
manager.  It should be impossible for postgis to leak memory past a SQL 
statement.

dave


From nhv at cape.com  Tue May 27 19:23:21 2003
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] GEOS Todo
In-Reply-To: <3ED3EE88.60306@refractions.net>
Message-ID: <EKEJIKAILPONGGENMBGAIENIDIAA.nhv@cape.com>

David Blasby
> 
> Norman Vine wrote:
> > David Blasby writes:
> > 
> >>There are two outstanding issues in GEOS:
> >>
> >>1. memory management.  This is high priority.
> > 
> > 
> > Using the c++ autoptr or a homegrown equivalant
> > would help *alot* here
> 
> This is even more basic - if you delete any one Geometry you will 
> usually delete the PrecisionModel of *all* your Geometries.

This is easily worked around by having a Geomety bump the 
Precision Model Object refcnt in its constructor and decrementing 
the refcnt in its destructor

Another perhaps *faster* method is to have the Precison Model 
refcnt bumped twice by the higheest level invoking function 

This will ensure that the Precison Model refcnt will never fall to zero
hence not be deleted by any operations before the hifh level calling
routine is reasy to return at which time it decrements the extera refcnt.
 
> For catching the smaller leaks, a few people mentioned a really good 
> opensource memory-leak-fixer program.  I cannot remember the name.

On Linux Valgrind is becoming the defacto standard in some camps

Cheers

Norman

From nhv at cape.com  Tue May 27 19:38:43 2003
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] GEOS Todo
In-Reply-To: <EKEJIKAILPONGGENMBGAIENIDIAA.nhv@cape.com>
Message-ID: <EKEJIKAILPONGGENMBGAIENJDIAA.nhv@cape.com>

Norman Vine wrote:

< I really need to start using a spell checker :-) >

> > > Using the c++ autoptr or a homegrown equivalant
> > > would help *alot* here
> > 
> > This is even more basic - if you delete any one Geometry you will 
> > usually delete the PrecisionModel of *all* your Geometries.
> 

This is easily worked around by having a Geomety bump the 
Precision Model Object refcnt in its constructor and decrementing 
the refcnt in its destructor

Another perhaps *faster* method is to have the Precison Model 
refcnt bumped twice by the highest level invoking function 
 
This will ensure that the Precison Model refcnt will never fall to zero
hence not be deleted by any operations before the high level calling
routine is ready to return at which time it decrements the extra refcnt.

Norman



From fvilla at zoo.uvm.edu  Tue May 27 19:31:43 2003
From: fvilla at zoo.uvm.edu (Ferdinando Villa)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] GEOS Todo
In-Reply-To: <EKEJIKAILPONGGENMBGAIENIDIAA.nhv@cape.com>
References: <EKEJIKAILPONGGENMBGAIENIDIAA.nhv@cape.com>
Message-ID: <1054078278.1256.7.camel@basil>

the Boost library (www.boost.org) has a shared_ptr that sounds like a
good match for the precision model thing. The various boost smart
pointers can be taken from boost rather easily and incorporated - it's
all in template headers. It's got local and shared pointers for both
scalars and arrays, plus a zillion of other useful things.

This stuff tends to get tricky with multiple threads - are we
considering thread safety in GEOS? It's going to be important for some
applications (notably mine). Boost has good thread support. 

On Tue, 2003-05-27 at 19:23, Norman Vine wrote:
> This is easily worked around by having a Geomety bump the 
> Precision Model Object refcnt in its constructor and decrementing 
> the refcnt in its destructor
> 
> Another perhaps *faster* method is to have the Precison Model 
> refcnt bumped twice by the higheest level invoking function 

> On Linux Valgrind is becoming the defacto standard in some camps

Valgrind is great. I also have a license for Parasoft's insure++ ($$$)
that does a few more things (when it works) including coverage analysis
that helps greatly in optimization, and precise allocation mapping. I
can run GEOS test cases through it when I'm back to the office (Jun 20)
and post the leak and coverage reports.

ferdinando

> Cheers
> 
> Norman
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
-- 
ferdinando villa, ph.d.                    associate professor
gund institute for ecological economics, university of vermont
590 main street, burlington, vt 05405    phone: (802) 656-2972


From mbdavis at VividSolutions.com  Tue May 27 19:48:07 2003
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Issues with smart pointers and threads?
Message-ID: <5A94289A9268514C8D6C0F1FF44BA0271DF6DE@venus.VividSolutions.com>

> This stuff tends to get tricky with multiple threads - are we
> considering thread safety in GEOS? It's going to be important for some
> applications (notably mine). Boost has good thread support. 

We'd like GEOS to be thread safe, of course.  What exactly are the issues involved with using smart pointers in conjunction with threads?  I would have assumed that as long as allocated memory was *not* shared between threads, you are safe in letting it get deleted when a smart pointer goes out of scope.  In GEOS, memory allocation should be completely thread-local - memory is only allocated in the context of Geometry methods, which are called by a single thread.

Martin Davis, Senior Technical Architect
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com

> 

From dblasby at refractions.net  Tue May 27 20:12:12 2003
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Issues with smart pointers and threads?
In-Reply-To: <5A94289A9268514C8D6C0F1FF44BA0271DF6DE@venus.VividSolutions.com>
References: <5A94289A9268514C8D6C0F1FF44BA0271DF6DE@venus.VividSolutions.com>
Message-ID: <3ED3FEDC.4070408@refractions.net>

I'm a bit concerned with using the reference counting since it could 
cause us some grief.  However, if this open source reference counter is 
good this might be easy.

Personally, I think wasting a wee bit of space for the precision model 
in a geometry isnt going to be that big a deal.

As for thread-safety, consider this:

Single threaded application makes a PrecisionModel.
This application forks 2 threads that both have access to this 
PrecisionModel.
Both threads create a bunch of geometries using the PrecisionModel.

If your reference counting is *not* thread-safe (ie. protected by a 
semephore), then there is a race condition if both threads try to 
increment the reference count at the same time.

dave


From nhv at cape.com  Tue May 27 20:29:54 2003
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Issues with smart pointers and threads?
In-Reply-To: <3ED3FEDC.4070408@refractions.net>
Message-ID: <EKEJIKAILPONGGENMBGAMENLDIAA.nhv@cape.com>

David Blasby writes:
>
> I'm a bit concerned with using the reference counting since it could
> cause us some grief.  However, if this open source reference counter is
> good this might be easy.

See
http://www.boost.org/libs/smart_ptr/smart_ptr.htm

Note: Followiing snipped from www.boost.org

"""The Boost web site provides free peer-reviewed portable C++ source
libraries.
The emphasis is on libraries which work well with the C++ Standard Library.
One goal is to establish "existing practice" and provide reference
implementations
so that the Boost libraries are suitable for eventual standardization.
Some of the libraries have already been proposed for inclusion in the
C++ Standards Committee's upcoming C++ Standard Library Technical Report.

Although Boost was begun by members of the C++ Standards Committee Library
Working Group, membership has expanded to include nearly two thousand
members
of the C++ community at large.""""

Cheers

Norman


From fvilla at zoo.uvm.edu  Tue May 27 20:22:43 2003
From: fvilla at zoo.uvm.edu (Ferdinando Villa)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Issues with smart pointers and threads?
In-Reply-To: <3ED3FEDC.4070408@refractions.net>
References: 
	 <5A94289A9268514C8D6C0F1FF44BA0271DF6DE@venus.VividSolutions.com>
	 <3ED3FEDC.4070408@refractions.net>
Message-ID: <1054081362.1461.17.camel@basil>

Right - it only matters if two+ threads can share a reference counted
pointer. Then you need to serialize the counter increment or you're in
big trouble. Most OS have kernel support for atomic increment that makes
it fast, and open sources implementations abound. If we're not going to
share geometries between threads then that's not necessary, but I don't
see how we can enforce that or why should we. I can think of various
applications where sharing geometries between threads or not could mean
major differences in efficiency.

We can use policy-based design to define the threading model at compile
time (that's what boost does) so that locking does not occur unless the
application needs it (even if there's good support from the OS, it's
going to be expensive compared to not doing it at all). As long as we
use some kind of template-based smart pointer instead of a custom
reference counter, we can always plug it in later unless postgis needs
it from the start - I'm happy to help, after June 20...

ciao 
f

On Tue, 2003-05-27 at 20:12, David Blasby wrote:
> I'm a bit concerned with using the reference counting since it could 
> cause us some grief.  However, if this open source reference counter is 
> good this might be easy.
> 
> Personally, I think wasting a wee bit of space for the precision model 
> in a geometry isnt going to be that big a deal.
> 
> As for thread-safety, consider this:
> 
> Single threaded application makes a PrecisionModel.
> This application forks 2 threads that both have access to this 
> PrecisionModel.
> Both threads create a bunch of geometries using the PrecisionModel.
> 
> If your reference counting is *not* thread-safe (ie. protected by a 
> semephore), then there is a race condition if both threads try to 
> increment the reference count at the same time.
> 
> dave
> 
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
-- 
Ferdinando Villa <fvilla@zoo.uvm.edu>
University of Vermont


From mbdavis at VividSolutions.com  Tue May 27 20:28:27 2003
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Issues with smart pointers and threads?
Message-ID: <5A94289A9268514C8D6C0F1FF44BA027225512@venus.VividSolutions.com>

I agree, Dave - I think that reference counting is going to be a lot harder to implement, debug, and verify than simply using value objects.  I'd prefer to avoid as much complexity as possible in GEOS - dealing with the algorithm side of things is complex enough.  

Martin Davis, Senior Technical Architect
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


> -----Original Message-----
> From: David Blasby [mailto:dblasby@refractions.net]
> Sent: Tuesday, May 27, 2003 5:12 PM
> To: GEOS Development List
> Subject: Re: [geos-devel] Issues with smart pointers and threads?
> 
> 
> I'm a bit concerned with using the reference counting since it could 
> cause us some grief.  However, if this open source reference 
> counter is 
> good this might be easy.
> 
> Personally, I think wasting a wee bit of space for the 
> precision model 
> in a geometry isnt going to be that big a deal.
> 
> As for thread-safety, consider this:
> 
> Single threaded application makes a PrecisionModel.
> This application forks 2 threads that both have access to this 
> PrecisionModel.
> Both threads create a bunch of geometries using the PrecisionModel.
> 
> If your reference counting is *not* thread-safe (ie. protected by a 
> semephore), then there is a race condition if both threads try to 
> increment the reference count at the same time.
> 
> dave
> 
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
> 

From pramsey at refractions.net  Wed May 28 01:09:11 2003
From: pramsey at refractions.net (Paul Ramsey)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] GNU Changes
Message-ID: <8471D250-90CA-11D7-AAF4-000393D33C2E@refractions.net>

Yury, beware, I have made a passel of GNU compatibility changes in the 
CVS.

Also, I have a problem:
The automake / autoconf build process is currently set up to assemble 
all the object files in the source/geom directory, then link them into 
a library. Fine, except we are now getting name collisions between 
objects from different parts of the source tree, namely from

automake: source/geom/Makefile.am: object `Node.lo' created by 
`../index/bintree/Node.cpp' and `../graph/Node.cpp'
automake: source/geom/Makefile.am: object `Interval.lo' created by 
`../index/strtree/Interval.cpp' and `../index/bintree/Interval.cpp'

The result is unbuildableness.  So, either we get a couple distinct 
names, or figure out a way to marshall the objects within their home 
directories yet still build a unitary library. (I think the reason we 
ended up marshalling everything into source/geom was to get a single 
libgeos.so as a build result.)

Help from the automake/autoconf gurus most appreciated.
P.

      Paul Ramsey
      Refractions Research
      Email: pramsey@refractions.net
      Phone: (250) 885-0632


From nhv at cape.com  Wed May 28 03:51:38 2003
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Issues with smart pointers and threads?
In-Reply-To: <5A94289A9268514C8D6C0F1FF44BA027225512@venus.VividSolutions.com>
Message-ID: <EKEJIKAILPONGGENMBGACEODDIAA.nhv@cape.com>

Martin Davis writes:
> 
> I agree, Dave - I think that reference counting is going to be a 
> lot harder to implement, debug, and verify than simply using 
> value objects.  I'd prefer to avoid as much complexity as 
> possible in GEOS - dealing with the algorithm side of things is 
> complex enough.  

The beauty of the auto_ptr auto_ref approach is that once
you accept the fact that it works much of the memory allocation 
deallocation bookwork is taken care of for you auto magically
by the compiler and is guaranteed to be done correctly in an
'exception safe way', and in general the resulting code is *much* 
cleaner.

I do realize that it takes a bit of a leap of faith to accept this :-)

A judicous typeedef or two can help hide the complexity also
http://www.gderek.lolo.com.pl/c++-faq/exceptions.html

Cheers

Norman

From fvilla at zoo.uvm.edu  Wed May 28 08:54:48 2003
From: fvilla at zoo.uvm.edu (Ferdinando Villa)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Issues with smart pointers and threads?
In-Reply-To: <EKEJIKAILPONGGENMBGACEODDIAA.nhv@cape.com>
References: <EKEJIKAILPONGGENMBGACEODDIAA.nhv@cape.com>
Message-ID: <1054126488.1333.12.camel@basil>

On Wed, 2003-05-28 at 03:51, Norman Vine wrote:
> The beauty of the auto_ptr auto_ref approach is that once
> you accept the fact that it works much of the memory allocation 
> deallocation bookwork is taken care of for you auto magically
> by the compiler and is guaranteed to be done correctly in an
> 'exception safe way', and in general the resulting code is *much* 
> cleaner.
> 

Just like Java! :) Smart pointers are probably the only thing that NEVER
gave me a headache in years and years of C++ coding. On the other hand,
back to the shared PrecisionModel thing, a precision model is three
doubles and an int... and the copy constructor does a fabs and a couple
assignments. Once the constructor and setScale are inlined (please)
constructing one shouldn't really be slower than assigning a pointer and
incrementing a counter - and would probably be faster than doing that
with locking. So I guess it's your call - particularly if this is the
only place in GEOS where this is needed.

ciao f

> I do realize that it takes a bit of a leap of faith to accept this :-)
> 
> A judicous typeedef or two can help hide the complexity also
> http://www.gderek.lolo.com.pl/c++-faq/exceptions.html
> 
> Cheers
> 
> Norman
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
-- 
ferdinando villa, ph.d.                    associate professor
gund institute for ecological economics, university of vermont
590 main street, burlington, vt 05405    phone: (802) 656-2972


From fvilla at zoo.uvm.edu  Wed May 28 09:02:10 2003
From: fvilla at zoo.uvm.edu (Ferdinando Villa)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] GNU Changes
In-Reply-To: <8471D250-90CA-11D7-AAF4-000393D33C2E@refractions.net>
References: <8471D250-90CA-11D7-AAF4-000393D33C2E@refractions.net>
Message-ID: <1054126930.1333.18.camel@basil>

I'd just call the files different names. As pointed out in the past,
merging objects from different development trees into one library is not
a clean approach automake-wise - I'd very much prefer building separate
libraries (and use `geos-config --libs` to extract the link parameters,
which is much simpler than doing -Lgeos and having to figure out where
prefix is), or building one library with all the sources in one
directory (which would avoid naming problems from the start). Anyway the
solution here is simple - change filenames...

ciao f

On Wed, 2003-05-28 at 01:09, Paul Ramsey wrote:
> Yury, beware, I have made a passel of GNU compatibility changes in the 
> CVS.
> 
> Also, I have a problem:
> The automake / autoconf build process is currently set up to assemble 
> all the object files in the source/geom directory, then link them into 
> a library. Fine, except we are now getting name collisions between 
> objects from different parts of the source tree, namely from
> 
> automake: source/geom/Makefile.am: object `Node.lo' created by 
> `../index/bintree/Node.cpp' and `../graph/Node.cpp'
> automake: source/geom/Makefile.am: object `Interval.lo' created by 
> `../index/strtree/Interval.cpp' and `../index/bintree/Interval.cpp'
> 
> The result is unbuildableness.  So, either we get a couple distinct 
> names, or figure out a way to marshall the objects within their home 
> directories yet still build a unitary library. (I think the reason we 
> ended up marshalling everything into source/geom was to get a single 
> libgeos.so as a build result.)
> 
> Help from the automake/autoconf gurus most appreciated.
> P.
> 
>       Paul Ramsey
>       Refractions Research
>       Email: pramsey@refractions.net
>       Phone: (250) 885-0632
> 
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
-- 
ferdinando villa, ph.d.                    associate professor
gund institute for ecological economics, university of vermont
590 main street, burlington, vt 05405    phone: (802) 656-2972


From pramsey at refractions.net  Wed May 28 10:49:09 2003
From: pramsey at refractions.net (Paul Ramsey)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] GNU Changes
In-Reply-To: <1054126930.1333.18.camel@basil>
Message-ID: <89C6B7E0-911B-11D7-B6CC-000393D33C2E@refractions.net>

Yury,
Could you do the file name changes?
Thanks,
Paul

On Wednesday, May 28, 2003, at 06:02 AM, Ferdinando Villa wrote:

> I'd just call the files different names. As pointed out in the past,
> merging objects from different development trees into one library is 
> not
> a clean approach automake-wise - I'd very much prefer building separate
> libraries (and use `geos-config --libs` to extract the link parameters,
> which is much simpler than doing -Lgeos and having to figure out where
> prefix is), or building one library with all the sources in one
> directory (which would avoid naming problems from the start). Anyway 
> the
> solution here is simple - change filenames...
>
> ciao f
>
> On Wed, 2003-05-28 at 01:09, Paul Ramsey wrote:
>> Yury, beware, I have made a passel of GNU compatibility changes in the
>> CVS.
>>
>> Also, I have a problem:
>> The automake / autoconf build process is currently set up to assemble
>> all the object files in the source/geom directory, then link them into
>> a library. Fine, except we are now getting name collisions between
>> objects from different parts of the source tree, namely from
>>
>> automake: source/geom/Makefile.am: object `Node.lo' created by
>> `../index/bintree/Node.cpp' and `../graph/Node.cpp'
>> automake: source/geom/Makefile.am: object `Interval.lo' created by
>> `../index/strtree/Interval.cpp' and `../index/bintree/Interval.cpp'
>>
>> The result is unbuildableness.  So, either we get a couple distinct
>> names, or figure out a way to marshall the objects within their home
>> directories yet still build a unitary library. (I think the reason we
>> ended up marshalling everything into source/geom was to get a single
>> libgeos.so as a build result.)
>>
>> Help from the automake/autoconf gurus most appreciated.
>> P.
>>
>>       Paul Ramsey
>>       Refractions Research
>>       Email: pramsey@refractions.net
>>       Phone: (250) 885-0632
>>
>>
>> _______________________________________________
>> geos-devel mailing list
>> geos-devel@geos.refractions.net
>> http://geos.refractions.net/mailman/listinfo/geos-devel
> -- 
> ferdinando villa, ph.d.                    associate professor
> gund institute for ecological economics, university of vermont
> 590 main street, burlington, vt 05405    phone: (802) 656-2972
>
>
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
>
      Paul Ramsey
      Refractions Research
      Email: pramsey@refractions.net
      Phone: (250) 885-0632


From me at yury.ca  Wed May 28 18:22:29 2003
From: me at yury.ca (Yury A. Bychkov)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] GNU Changes
References: <89C6B7E0-911B-11D7-B6CC-000393D33C2E@refractions.net>
Message-ID: <00d901c32567$a3d7e480$b9354d18@yury>

That was a CVS error. For some reason the Node.cpp and Interval.cpp did not get
deleted from CVS when I renamed them to BinTreeNode.cpp and BinTreeInterval.cpp.
I've deleted them from CVS now, so that should work.
I've also changed strtree/Interval.cpp, because your compatibility changes
conflicted with a variable name, so that should work now as well.

Yury

----- Original Message ----- 
From: "Paul Ramsey" <pramsey@refractions.net>
To: "GEOS Development List" <geos-devel@geos.refractions.net>
Sent: Wednesday, May 28, 2003 7:49 AM
Subject: Re: [geos-devel] GNU Changes


> Yury,
> Could you do the file name changes?
> Thanks,
> Paul
>
> On Wednesday, May 28, 2003, at 06:02 AM, Ferdinando Villa wrote:
>
> > I'd just call the files different names. As pointed out in the past,
> > merging objects from different development trees into one library is
> > not
> > a clean approach automake-wise - I'd very much prefer building separate
> > libraries (and use `geos-config --libs` to extract the link parameters,
> > which is much simpler than doing -Lgeos and having to figure out where
> > prefix is), or building one library with all the sources in one
> > directory (which would avoid naming problems from the start). Anyway
> > the
> > solution here is simple - change filenames...
> >
> > ciao f
> >
> > On Wed, 2003-05-28 at 01:09, Paul Ramsey wrote:
> >> Yury, beware, I have made a passel of GNU compatibility changes in the
> >> CVS.
> >>
> >> Also, I have a problem:
> >> The automake / autoconf build process is currently set up to assemble
> >> all the object files in the source/geom directory, then link them into
> >> a library. Fine, except we are now getting name collisions between
> >> objects from different parts of the source tree, namely from
> >>
> >> automake: source/geom/Makefile.am: object `Node.lo' created by
> >> `../index/bintree/Node.cpp' and `../graph/Node.cpp'
> >> automake: source/geom/Makefile.am: object `Interval.lo' created by
> >> `../index/strtree/Interval.cpp' and `../index/bintree/Interval.cpp'
> >>
> >> The result is unbuildableness.  So, either we get a couple distinct
> >> names, or figure out a way to marshall the objects within their home
> >> directories yet still build a unitary library. (I think the reason we
> >> ended up marshalling everything into source/geom was to get a single
> >> libgeos.so as a build result.)
> >>
> >> Help from the automake/autoconf gurus most appreciated.
> >> P.
> >>
> >>       Paul Ramsey
> >>       Refractions Research
> >>       Email: pramsey@refractions.net
> >>       Phone: (250) 885-0632
> >>
> >>
> >> _______________________________________________
> >> geos-devel mailing list
> >> geos-devel@geos.refractions.net
> >> http://geos.refractions.net/mailman/listinfo/geos-devel
> > -- 
> > ferdinando villa, ph.d.                    associate professor
> > gund institute for ecological economics, university of vermont
> > 590 main street, burlington, vt 05405    phone: (802) 656-2972
> >
> >
> > _______________________________________________
> > geos-devel mailing list
> > geos-devel@geos.refractions.net
> > http://geos.refractions.net/mailman/listinfo/geos-devel
> >
>       Paul Ramsey
>       Refractions Research
>       Email: pramsey@refractions.net
>       Phone: (250) 885-0632
>
>
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel


From nhv at cape.com  Wed May 28 18:40:47 2003
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:07 2007
Subject: FW: [geos-devel] Issues with smart pointers and threads?
Message-ID: <EKEJIKAILPONGGENMBGAAEAHDJAA.nhv@cape.com>

Oops ... This was meant for the list

> -----Original Message-----
> From: Norman Vine [mailto:nhv@cape.com]
> Sent: Wednesday, May 28, 2003 9:30 AM
> To: Ferdinando Villa
> Subject: RE: [geos-devel] Issues with smart pointers and threads?
>
>
> Ferdinando Villa
> >
> > On Wed, 2003-05-28 at 03:51, Norman Vine wrote:
> > > The beauty of the auto_ptr auto_ref approach is that once
> > > you accept the fact that it works much of the memory allocation
> > > deallocation bookwork is taken care of for you auto magically
> > > by the compiler and is guaranteed to be done correctly in an
> > > 'exception safe way', and in general the resulting code is *much*
> > > cleaner.
> > >
> >
> > Just like Java! :)
>
> Oooh..  that is a good selling point I forgot to mention :-)
>
> >> Smart pointers are probably the only thing that NEVER
> > gave me a headache in years and years of C++ coding. On the other hand,
> > back to the shared PrecisionModel thing, a precision model is three
> > doubles and an int... and the copy constructor does a fabs and a couple
> > assignments. Once the constructor and setScale are inlined (please)
> > constructing one shouldn't really be slower than assigning a pointer and
> > incrementing a counter - and would probably be faster than doing that
> > with locking. So I guess it's your call - particularly if this is the
> > only place in GEOS where this is needed.
>
> Actually 'Smart Pointers' would help GEOS in many places.
>
> IMO It would behoove us to make a GEOSbase type from which all
> GEOS classes were derived and this base type would of course be nothing
> more then a templated 'smart pointer' class.
>
> This way we could just forget about memory deallocation as it would
> all be elegantly handled for us, JLJ.  < Just Like Java >
>
> Cheers
>
> Norman
>


From mbdavis at VividSolutions.com  Wed May 28 20:01:38 2003
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Smart Pointers solve all MM problems?
Message-ID: <5A94289A9268514C8D6C0F1FF44BA027225516@venus.VividSolutions.com>

Hmm...  I can't quite bring myself to believe it's this easy.  If memory management was simply a matter of implementing smart pointers, why have people spent so many years improving GC algorithms?

I'm not clear on whether you're saying that SmartPointers should include reference counting or not.  I believe there is a well-known problem with reference counting not handling circular chains of pointers.  I can think of situations in JTS where this might arise, since it build arbitrary graph structures to represent arrangements of edges.  On the other hand, JTS has an advantage in that it allocates lots of small objects to accomplish it's internal tasks, but they can all be freed when those tasks are completed.  Some kind of internal memory pool might be a good way to approach this.

Also, am I right in thinking that smart pointers don't help you if you have functions which alloc memory structures and return them? (Which happens all over JTS - e.g. in indexes and edge graph structures).

Please not that I'm not saying this is not a good idea - I'm just cautious about making a fairly crucial implementation decision without considering all the pros and cons.

Martin Davis, Senior Technical Architect
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


> -----Original Message-----
> From: Norman Vine [mailto:nhv@cape.com]
> Sent: Wednesday, May 28, 2003 3:41 PM
> To: geos-devel@geos.refractions.net
> Subject: FW: [geos-devel] Issues with smart pointers and threads?
> 
> 
> Oops ... This was meant for the list
> 
> > -----Original Message-----
> > From: Norman Vine [mailto:nhv@cape.com]
> > Sent: Wednesday, May 28, 2003 9:30 AM
> > To: Ferdinando Villa
> > Subject: RE: [geos-devel] Issues with smart pointers and threads?
> >
> >
> > Ferdinando Villa
> > >
> > > On Wed, 2003-05-28 at 03:51, Norman Vine wrote:
> > > > The beauty of the auto_ptr auto_ref approach is that once
> > > > you accept the fact that it works much of the memory allocation
> > > > deallocation bookwork is taken care of for you auto magically
> > > > by the compiler and is guaranteed to be done correctly in an
> > > > 'exception safe way', and in general the resulting code 
> is *much*
> > > > cleaner.
> > > >
> > >
> > > Just like Java! :)
> >
> > Oooh..  that is a good selling point I forgot to mention :-)
> >
> > >> Smart pointers are probably the only thing that NEVER
> > > gave me a headache in years and years of C++ coding. On 
> the other hand,
> > > back to the shared PrecisionModel thing, a precision 
> model is three
> > > doubles and an int... and the copy constructor does a 
> fabs and a couple
> > > assignments. Once the constructor and setScale are 
> inlined (please)
> > > constructing one shouldn't really be slower than 
> assigning a pointer and
> > > incrementing a counter - and would probably be faster 
> than doing that
> > > with locking. So I guess it's your call - particularly if 
> this is the
> > > only place in GEOS where this is needed.
> >
> > Actually 'Smart Pointers' would help GEOS in many places.
> >
> > IMO It would behoove us to make a GEOSbase type from which all
> > GEOS classes were derived and this base type would of 
> course be nothing
> > more then a templated 'smart pointer' class.
> >
> > This way we could just forget about memory deallocation as it would
> > all be elegantly handled for us, JLJ.  < Just Like Java >
> >
> > Cheers
> >
> > Norman
> >
> 
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
> 

From pramsey at refractions.net  Wed May 28 20:06:05 2003
From: pramsey at refractions.net (Paul Ramsey)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] GNU Build Works Again
Message-ID: <1054166765.3ed54eedcb462@www>

OK, the GNU build is operational again, thanks Yury.
P.




From nhv at cape.com  Thu May 29 08:32:41 2003
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Smart Pointers solve all MM problems?
In-Reply-To: <5A94289A9268514C8D6C0F1FF44BA027225516@venus.VividSolutions.com>
Message-ID: <EKEJIKAILPONGGENMBGACEBKDJAA.nhv@cape.com>

Martin Davis writes:
> 
> I'm not clear on whether you're saying that SmartPointers should 
> include reference counting or not.  

Yes I am really talking about reference counting

> I believe there is a 
> well-known problem with reference counting not handling circular 
> chains of pointers. 

I am not familiar with this but I can 'imagine' where circular references 
'might' be a problem but there is usually a simple solution
 
> Also, am I right in thinking that smart pointers don't help you 
> if you have functions which alloc memory structures and return 
> them? (Which happens all over JTS - e.g. in indexes and edge 
> graph structures).

Long lived objects can be handled specially or just use the ref count 
bumping trick

AFAIK all the interesting GEOS calls return their results as a 
Geometry pointer which can be easily passed to the core GEOS
library so it will never be deleted by the GEOS core as then it's ref
count will never fall to zero inside the library

FWIW
Two other projects I am much more actively involved with
http://plib.sf.net  an http://www.openscenegraph.org
are both 'graph' based libraries which both successfully use
reference counting to 'simplify' memory management 

Ref counting certainly isn't the only way to manage memory
and all that really matters is that GEOS doesn't leak but ref 
counting is a fairly simple method that has been proven to 
help however I do realize that it takes a 'leap of faith' to trust it:-)

Cheers

Norman


From fvilla at zoo.uvm.edu  Thu May 29 09:13:30 2003
From: fvilla at zoo.uvm.edu (Ferdinando Villa)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Smart Pointers solve all MM problems?
In-Reply-To: <EKEJIKAILPONGGENMBGACEBKDJAA.nhv@cape.com>
References: <EKEJIKAILPONGGENMBGACEBKDJAA.nhv@cape.com>
Message-ID: <1054214010.1332.12.camel@basil>

On Thu, 2003-05-29 at 08:32, Norman Vine wrote:
> > I believe there is a 
> > well-known problem with reference counting not handling circular 
> > chains of pointers. 

I'll have to look into this when I'm back - I also remember this but I
couldn't find the problem mentioned in the docs I have, so I imagine
it's solved in general (myself., I always use tree structures, so if
there's a problem it's likely I haven't run into it). Anyway ref
counting isn't the only way to implement smart pointers although it is
the most popular - Alexandrescu has a great discussion (and I don't
remember seeing the circular pointer thing mentioned there).
 
> > Also, am I right in thinking that smart pointers don't help you 
> > if you have functions which alloc memory structures and return 
> > them? (Which happens all over JTS - e.g. in indexes and edge 
> > graph structures).
> 
> Long lived objects can be handled specially or just use the ref count 
> bumping trick
> 

If the only new operator you write is within the constructor of a smart
pointer (i.e. the function that allocates the memory returns a smart
pointer) then the copy constructor of the receiving memory bumps the
reference count, and you only lose the object if you don't assign the
return value (which is the correct behavior). The only thing to remember
is: never write a new outside a smart pointer constructor. Then it's
almost impossible to go wrong. Of course you need to use the right kind
of smart pointer - for long-lived object you don't use auto_ptr, but one
of the 'shared' family.

> -- 
> ferdinando villa, ph.d.                    associate professor
> gund institute for ecological economics, university of vermont
> 590 main street, burlington, vt 05405    phone: (802) 656-2972


From dblasby at refractions.net  Fri May 30 12:33:44 2003
From: dblasby at refractions.net (David Blasby)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] GEOS - is it 1.2 or 1.3
In-Reply-To: <1054214010.1332.12.camel@basil>
References: <EKEJIKAILPONGGENMBGACEBKDJAA.nhv@cape.com>
	<1054214010.1332.12.camel@basil>
Message-ID: <3ED787E8.5060609@refractions.net>

Has GEOS been updated to the new JTS 1.3?  I noticed that the isvalid() 
still doesnt like objects with repeated points.

dave


From nhv at cape.com  Fri May 30 12:43:54 2003
From: nhv at cape.com (Norman Vine)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] GEOS - is it 1.2 or 1.3
In-Reply-To: <3ED787E8.5060609@refractions.net>
Message-ID: <EKEJIKAILPONGGENMBGAAEEDDJAA.nhv@cape.com>

David Blasby writes:
> 
> Has GEOS been updated to the new JTS 1.3? 

Good question ?

I noticed 

$ source/bigtest/TestSweepLineSpeed.exe
# overlapping MCs: 406
# segment intersection tests: 232
n Pts: 1024000  Executed in   3806 ms.
Done

PIII 733 slightly modified GEOS code 

This is much faster then the last time I tried this

Norman

From pramsey at refractions.net  Fri May 30 19:11:41 2003
From: pramsey at refractions.net (Paul Ramsey)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Memory Management Fixes
Message-ID: <3ED7E52D.2040406@refractions.net>

What's the ETA on getting the memory management fixed so we can safely 
delete geometries? Until we get that we cannot cut a beat release of 
GEOS for use with the PostGIS 0.8 beta.
Thanks,
Paul


From mbdavis at VividSolutions.com  Fri May 30 19:12:03 2003
From: mbdavis at VividSolutions.com (Martin Davis)
Date: Fri Nov  2 20:52:07 2007
Subject: [geos-devel] Memory Management Fixes
Message-ID: <5A94289A9268514C8D6C0F1FF44BA0271DF72C@venus.VividSolutions.com>

There are two memory management issues that I'm aware of:

1. changing PrecisionModel to be a value type, so that deleting Geometries doesn't leak memory
2. ensure that all memory allocated during Geometry methods is freed correctly, including during  exception propagation

1. is pretty easy, and in fact I think Yury mentioned today that he had already implemented this fix.  Yury can confirm this, and if he does RR should test that the fix works

2 is much more work, and is slated to be started once the basic port of the code has been completed (which sounds like it should be done in a week or two).

Yury, I assume that the basic deletion of Geometrys is working (e.g. freeing the pointlists and envelopes) ?

Martin Davis, Senior Technical Architect
Vivid Solutions Inc.
Suite #1A-2328 Government Street   Victoria, B.C.   V8T 5G5
Phone: (250) 385 6040    Fax: (250) 385 6046
EMail: mbdavis@vividsolutions.com  Web: www.vividsolutions.com


> -----Original Message-----
> From: Paul Ramsey [mailto:pramsey@refractions.net]
> Sent: Friday, May 30, 2003 4:12 PM
> To: geos-devel@geos.refractions.net
> Subject: [geos-devel] Memory Management Fixes
> 
> 
> What's the ETA on getting the memory management fixed so we 
> can safely 
> delete geometries? Until we get that we cannot cut a beat release of 
> GEOS for use with the PostGIS 0.8 beta.
> Thanks,
> Paul
> 
> 
> _______________________________________________
> geos-devel mailing list
> geos-devel@geos.refractions.net
> http://geos.refractions.net/mailman/listinfo/geos-devel
> 

